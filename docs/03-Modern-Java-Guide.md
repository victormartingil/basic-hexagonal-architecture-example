# Gu√≠a de Java Moderno

## üìö √çndice

1. [Optional - Adi√≥s a los NullPointerException](#optional---adi√≥s-a-los-nullpointerexception)
2. [Streams - Procesamiento de Colecciones](#streams---procesamiento-de-colecciones)
3. [Lambdas y Programaci√≥n Funcional](#lambdas-y-programaci√≥n-funcional)
4. [Colecciones - Cu√°ndo usar cada una](#colecciones---cu√°ndo-usar-cada-una)
5. [Records - DTOs Inmutables](#records---dtos-inmutables)
6. [Inmutabilidad](#inmutabilidad)
7. [final Keyword - Garantizando Inmutabilidad](#final-keyword---garantizando-inmutabilidad)
8. [Inmutabilidad Profunda (Deep Immutability)](#inmutabilidad-profunda-deep-immutability)
9. [Records en Profundidad (Java 21)](#records-en-profundidad-java-21)
10. [var - Inferencia de Tipos](#var---inferencia-de-tipos-java-10)
11. [Try-with-Resources](#try-with-resources)
12. [Switch Expressions](#switch-expressions-java-14)

---

## Optional - Adi√≥s a los NullPointerException

### ¬øQu√© es Optional?

`Optional<T>` es un **contenedor** que puede tener o no tener un valor. Te obliga a pensar en el caso de "no hay valor" desde el principio.

### El Problema con null

```java
// ‚ùå C√ìDIGO PELIGROSO (pre-Optional)
public User findById(UUID id) {
    return userRepository.findById(id);  // ¬øQu√© pasa si no existe?
}

// Uso posterior
User user = findById(someId);
System.out.println(user.getUsername());  // üí• NullPointerException si user es null
```

### La Soluci√≥n: Optional

```java
// ‚úÖ C√ìDIGO SEGURO (con Optional)
public Optional<User> findById(UUID id) {
    return userRepository.findById(id);
}

// Uso posterior - OBLIGADO a manejar el caso "no existe"
Optional<User> userOpt = findById(someId);
if (userOpt.isPresent()) {
    User user = userOpt.get();
    System.out.println(user.getUsername());  // Seguro
}
```

### Crear Optional

```java
// 1. Optional con valor
Optional<String> opt1 = Optional.of("Hola");  // Lanza excepci√≥n si es null

// 2. Optional que puede ser null
Optional<String> opt2 = Optional.ofNullable(mightBeNull);  // No lanza excepci√≥n

// 3. Optional vac√≠o
Optional<String> opt3 = Optional.empty();
```

### M√©todos Importantes de Optional

#### 1. isPresent() / isEmpty()

```java
Optional<User> userOpt = findById(id);

// ‚úÖ Verificar si tiene valor
if (userOpt.isPresent()) {
    User user = userOpt.get();
    // usar user
}

// ‚úÖ Verificar si NO tiene valor (Java 11+)
if (userOpt.isEmpty()) {
    System.out.println("Usuario no encontrado");
}
```

#### 2. orElse() - Valor por defecto

```java
// ‚úÖ Si no existe, usa un valor por defecto
User user = userOpt.orElse(defaultUser);

String username = findUsername(id).orElse("Anonymous");
```

#### 3. orElseThrow() - Lanzar excepci√≥n

```java
// ‚úÖ Si no existe, lanza excepci√≥n personalizada
User user = userOpt.orElseThrow(() ->
    new UserNotFoundException("User not found: " + id)
);
```

**Ejemplo del proyecto:**
```java
// En el Service
@Override
public UserResult execute(UUID userId) {
    User user = userRepository.findById(userId)
        .orElseThrow(() -> new UserNotFoundException(userId));  // ‚úÖ

    return new UserResult(...);
}
```

#### 4. ifPresent() - Ejecutar si existe

```java
// ‚úÖ Ejecuta c√≥digo solo si tiene valor
userOpt.ifPresent(user -> {
    System.out.println("Usuario: " + user.getUsername());
});

// ‚úÖ Con m√©todo reference
userOpt.ifPresent(this::processUser);
```

#### 5. map() - Transformar el valor

```java
// ‚úÖ Transformar el valor si existe
Optional<String> usernameOpt = userOpt.map(User::getUsername);
Optional<String> emailOpt = userOpt.map(user -> user.getEmail().getValue());

// Si userOpt est√° vac√≠o, usernameOpt tambi√©n estar√° vac√≠o
```

#### 6. flatMap() - Transformar cuando el resultado es Optional

```java
// ‚úÖ Cuando el mapper devuelve Optional
Optional<User> userOpt = findById(userId);
Optional<Order> orderOpt = userOpt.flatMap(user -> findLastOrder(user.getId()));

// Sin flatMap ser√≠a Optional<Optional<Order>> ‚ùå
```

### ‚ö†Ô∏è Anti-patrones con Optional

```java
// ‚ùå NO HACER: llamar get() sin verificar
User user = userOpt.get();  // Puede lanzar NoSuchElementException

// ‚ùå NO HACER: usar isPresent() + get()
if (userOpt.isPresent()) {
    User user = userOpt.get();
    return user.getUsername();
}

// ‚úÖ HACER: usar map() + orElse()
return userOpt
    .map(User::getUsername)
    .orElse("Unknown");

// ‚ùå NO USAR Optional como par√°metro
public void updateUser(Optional<User> user) { }  // MAL

// ‚úÖ USAR null o sobrecarga
public void updateUser(User user) { }  // BIEN
```

### Resumen: Cu√°ndo usar Optional

| Situaci√≥n | Usar Optional |
|-----------|---------------|
| ‚úÖ Valor de retorno que puede no existir | `Optional<User> findById(UUID id)` |
| ‚úÖ Campo de clase opcional | `private Optional<Email> secondaryEmail;` |
| ‚ùå Par√°metros de m√©todo | NO usar, usar null o sobrecarga |
| ‚ùå Colecciones | NO usar `Optional<List<T>>`, usar lista vac√≠a |

---

## Streams - Procesamiento de Colecciones

### ¬øQu√© son los Streams?

Los **Streams** permiten procesar colecciones de forma **funcional** y **declarativa** (dices QU√â quieres, no C√ìMO hacerlo).

### Crear Streams

```java
// Desde una List
List<User> users = Arrays.asList(...);
Stream<User> stream = users.stream();

// Desde un array
String[] names = {"John", "Jane", "Bob"};
Stream<String> stream = Arrays.stream(names);

// Stream vac√≠o
Stream<String> empty = Stream.empty();

// Stream de valores
Stream<String> stream = Stream.of("a", "b", "c");
```

### Operaciones de Stream

#### 1. filter() - Filtrar elementos

```java
// ‚ùå FORMA IMPERATIVA (vieja)
List<User> activeUsers = new ArrayList<>();
for (User user : users) {
    if (user.isEnabled()) {
        activeUsers.add(user);
    }
}

// ‚úÖ FORMA DECLARATIVA (con Streams)
List<User> activeUsers = users.stream()
    .filter(user -> user.isEnabled())
    .collect(Collectors.toList());

// M√∫ltiples filtros
List<User> result = users.stream()
    .filter(user -> user.isEnabled())
    .filter(user -> user.getEmail().getValue().endsWith("@gmail.com"))
    .collect(Collectors.toList());
```

#### 2. map() - Transformar elementos

```java
// ‚ùå FORMA IMPERATIVA
List<String> usernames = new ArrayList<>();
for (User user : users) {
    usernames.add(user.getUsername().getValue());
}

// ‚úÖ FORMA DECLARATIVA
List<String> usernames = users.stream()
    .map(user -> user.getUsername().getValue())
    .collect(Collectors.toList());

// Con method reference (m√°s limpio)
List<String> usernames = users.stream()
    .map(User::getUsername)
    .map(Username::getValue)
    .collect(Collectors.toList());
```

#### 3. collect() - Recolectar resultados

```java
// A List
List<User> list = users.stream()
    .filter(User::isEnabled)
    .collect(Collectors.toList());

// A Set (sin duplicados)
Set<String> emails = users.stream()
    .map(user -> user.getEmail().getValue())
    .collect(Collectors.toSet());

// A Map
Map<UUID, User> userMap = users.stream()
    .collect(Collectors.toMap(User::getId, user -> user));

// Agrupar por campo
Map<Boolean, List<User>> usersByStatus = users.stream()
    .collect(Collectors.groupingBy(User::isEnabled));
```

#### 4. forEach() - Ejecutar acci√≥n para cada elemento

```java
// ‚úÖ Imprimir cada usuario
users.stream()
    .forEach(user -> System.out.println(user.getUsername()));

// Con method reference
users.stream()
    .forEach(System.out::println);

// NOTA: Para solo iterar, mejor usar forEach directamente
users.forEach(System.out::println);  // M√°s simple
```

#### 5. count() - Contar elementos

```java
// Contar usuarios activos
long count = users.stream()
    .filter(User::isEnabled)
    .count();
```

#### 6. anyMatch() / allMatch() / noneMatch()

```java
// ¬øHay alg√∫n usuario activo?
boolean hasActive = users.stream()
    .anyMatch(User::isEnabled);

// ¬øTodos los usuarios son activos?
boolean allActive = users.stream()
    .allMatch(User::isEnabled);

// ¬øNing√∫n usuario es activo?
boolean noneActive = users.stream()
    .noneMatch(User::isEnabled);
```

#### 7. findFirst() / findAny()

```java
// Encontrar el primer usuario activo
Optional<User> firstActive = users.stream()
    .filter(User::isEnabled)
    .findFirst();

// Encontrar cualquier usuario activo (√∫til en paralelo)
Optional<User> anyActive = users.stream()
    .filter(User::isEnabled)
    .findAny();
```

#### 8. sorted() - Ordenar

```java
// Ordenar por username
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(user -> user.getUsername().getValue()))
    .collect(Collectors.toList());

// Con method reference
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(User::getCreatedAt))
    .collect(Collectors.toList());

// Orden inverso
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(User::getCreatedAt).reversed())
    .collect(Collectors.toList());
```

#### 9. distinct() - Eliminar duplicados

```java
// Obtener emails √∫nicos
List<String> uniqueEmails = users.stream()
    .map(user -> user.getEmail().getValue())
    .distinct()
    .collect(Collectors.toList());
```

#### 10. limit() / skip()

```java
// Primeros 10 usuarios
List<User> first10 = users.stream()
    .limit(10)
    .collect(Collectors.toList());

// Saltar los primeros 5 y tomar los siguientes 10
List<User> page2 = users.stream()
    .skip(5)
    .limit(10)
    .collect(Collectors.toList());
```

### Ejemplo Completo del Proyecto

```java
// Obtener emails de usuarios activos, ordenados, sin duplicados
public List<String> getActiveUserEmails() {
    return userRepository.findAll().stream()
        .filter(User::isEnabled)                    // Solo activos
        .map(User::getEmail)                        // Extraer Email (Value Object)
        .map(Email::getValue)                       // Extraer String del VO
        .distinct()                                 // Sin duplicados
        .sorted()                                   // Ordenar
        .collect(Collectors.toList());             // A lista
}
```

### Streams Paralelos

```java
// Para colecciones grandes, procesar en paralelo
List<String> emails = users.parallelStream()  // ‚Üê parallel
    .filter(User::isEnabled)
    .map(user -> user.getEmail().getValue())
    .collect(Collectors.toList());

// Solo usar si la operaci√≥n es costosa y la colecci√≥n es grande (>10k elementos)
```

### ‚ö†Ô∏è Anti-patrones con Streams

```java
// ‚ùå NO: Modificar estado externo
List<User> result = new ArrayList<>();
users.stream().forEach(user -> result.add(user));  // MAL

// ‚úÖ USAR collect()
List<User> result = users.stream().collect(Collectors.toList());

// ‚ùå NO: Usar stream para operaciones simples
users.stream().forEach(System.out::println);  // Overkill

// ‚úÖ Usar forEach directo
users.forEach(System.out::println);
```

---

## Lambdas y Programaci√≥n Funcional

### ¬øQu√© es una Lambda?

Una **lambda** es una funci√≥n an√≥nima (sin nombre) que puedes pasar como par√°metro.

### Sintaxis de Lambda

```java
// Forma completa
(parametros) -> {
    cuerpo;
    return valor;
}

// Forma corta (una expresi√≥n)
(parametros) -> expresion

// Sin par√°metros
() -> System.out.println("Hola")

// Un par√°metro (sin par√©ntesis)
x -> x * 2

// M√∫ltiples par√°metros
(x, y) -> x + y

// Con tipos expl√≠citos
(String s) -> s.length()
```

### Ejemplos Pr√°cticos

#### Comparar: Clase An√≥nima vs Lambda

```java
// ‚ùå VIEJO: Clase an√≥nima (verbose)
users.sort(new Comparator<User>() {
    @Override
    public int compare(User u1, User u2) {
        return u1.getUsername().compareTo(u2.getUsername());
    }
});

// ‚úÖ MODERNO: Lambda (conciso)
users.sort((u1, u2) -> u1.getUsername().compareTo(u2.getUsername()));

// ‚úÖ A√öN MEJOR: Method reference
users.sort(Comparator.comparing(User::getUsername));
```

#### Interfaces Funcionales Comunes

```java
// 1. Predicate<T> - Funci√≥n que devuelve boolean
Predicate<User> isActive = user -> user.isEnabled();
boolean result = isActive.test(user);

// Uso en filter
users.stream().filter(isActive).collect(Collectors.toList());

// 2. Function<T, R> - Funci√≥n que transforma T en R
Function<User, String> getUsername = user -> user.getUsername().getValue();
String username = getUsername.apply(user);

// Uso en map
users.stream().map(getUsername).collect(Collectors.toList());

// 3. Consumer<T> - Funci√≥n que consume un valor (sin retorno)
Consumer<User> printUser = user -> System.out.println(user);
printUser.accept(user);

// Uso en forEach
users.forEach(printUser);

// 4. Supplier<T> - Funci√≥n que provee un valor (sin par√°metros)
Supplier<User> defaultUser = () -> User.create("default", "default@ex.com");
User user = defaultUser.get();

// Uso en orElseGet
Optional<User> userOpt = findById(id);
User user = userOpt.orElseGet(defaultUser);

// 5. BiFunction<T, U, R> - Funci√≥n con 2 par√°metros
BiFunction<String, String, User> createUser = (username, email) ->
    User.create(username, email);
User user = createUser.apply("john", "john@ex.com");
```

### Method References (Referencias a M√©todos)

Forma a√∫n m√°s corta cuando la lambda solo llama a un m√©todo:

```java
// Lambda: x -> metodo(x)
// Method Reference: Clase::metodo

// 1. M√©todo est√°tico
Function<String, Integer> parse = str -> Integer.parseInt(str);
Function<String, Integer> parse = Integer::parseInt;  // ‚úÖ

// 2. M√©todo de instancia
Function<User, String> getUsername = user -> user.getUsername().getValue();
Function<User, String> getUsername = User::getUsername;  // ‚úÖ (luego Username::getValue)

// 3. M√©todo de objeto espec√≠fico
Consumer<String> print = str -> System.out.println(str);
Consumer<String> print = System.out::println;  // ‚úÖ

// 4. Constructor
Supplier<ArrayList<String>> listSupplier = () -> new ArrayList<>();
Supplier<ArrayList<String>> listSupplier = ArrayList::new;  // ‚úÖ
```

### Ejemplos del Proyecto

```java
// En el Service
public List<UserResult> getAllActiveUsers() {
    return userRepository.findAll().stream()
        .filter(User::isEnabled)                    // Method reference
        .map(this::toResult)                        // Method reference a m√©todo de instancia
        .collect(Collectors.toList());
}

private UserResult toResult(User user) {
    return new UserResult(
        user.getId(),
        user.getUsername().getValue(),
        user.getEmail().getValue(),
        user.isEnabled(),
        user.getCreatedAt()
    );
}

// Con lambda inline
public List<String> getActiveUsernames() {
    return userRepository.findAll().stream()
        .filter(user -> user.isEnabled())           // Lambda
        .map(user -> user.getUsername().getValue()) // Lambda
        .collect(Collectors.toList());
}
```

---

## Colecciones - Cu√°ndo usar cada una

### List vs Set vs Map

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    COLECCIONES EN JAVA                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

LIST                    SET                     MAP
- Orden                 - Sin duplicados        - Clave ‚Üí Valor
- Permite duplicados    - Sin orden garantizado - Sin claves duplicadas
- Acceso por √≠ndice     - No tiene √≠ndice       - Acceso por clave

[A, B, C, A]           {A, B, C}               {1‚ÜíA, 2‚ÜíB, 3‚ÜíC}
```

### List - Colecci√≥n Ordenada

```java
// Crear listas
List<String> list1 = new ArrayList<>();         // M√°s com√∫n (r√°pido acceso)
List<String> list2 = new LinkedList<>();        // R√°pido insertar/eliminar
List<String> list3 = List.of("a", "b", "c");   // Inmutable (Java 9+)
List<String> list4 = Arrays.asList("a", "b");   // Tama√±o fijo

// Operaciones
list1.add("elemento");                          // Agregar al final
list1.add(0, "elemento");                       // Agregar en posici√≥n
String item = list1.get(0);                     // Obtener por √≠ndice
list1.remove(0);                                // Eliminar por √≠ndice
list1.remove("elemento");                       // Eliminar por valor
boolean contains = list1.contains("elemento");  // Verificar si existe
int size = list1.size();                        // Tama√±o
list1.clear();                                  // Vaciar
```

**Cu√°ndo usar:**
- ‚úÖ Cuando el orden importa
- ‚úÖ Cuando puedes tener duplicados
- ‚úÖ Cuando necesitas acceso por √≠ndice
- Ejemplos: lista de usuarios, historial, logs

### Set - Colecci√≥n Sin Duplicados

```java
// Crear sets
Set<String> set1 = new HashSet<>();             // M√°s r√°pido, sin orden
Set<String> set2 = new LinkedHashSet<>();       // Mantiene orden de inserci√≥n
Set<String> set3 = new TreeSet<>();             // Ordenado naturalmente
Set<String> set4 = Set.of("a", "b", "c");      // Inmutable (Java 9+)

// Operaciones
set1.add("elemento");                           // Agregar (ignora duplicados)
set1.remove("elemento");                        // Eliminar
boolean contains = set1.contains("elemento");   // Verificar (muy r√°pido O(1))
int size = set1.size();                         // Tama√±o

// Ejemplo: Eliminar duplicados de una lista
List<String> list = Arrays.asList("a", "b", "a", "c");
Set<String> unique = new HashSet<>(list);
System.out.println(unique);  // [a, b, c]
```

**Cu√°ndo usar:**
- ‚úÖ Cuando NO quieres duplicados
- ‚úÖ Cuando necesitas b√∫squeda r√°pida (`contains()`)
- ‚úÖ Cuando el orden no importa (HashSet)
- Ejemplos: IDs √∫nicos, tags, categor√≠as

### Map - Diccionario Clave-Valor

```java
// Crear maps
Map<String, User> map1 = new HashMap<>();       // M√°s com√∫n, sin orden
Map<String, User> map2 = new LinkedHashMap<>(); // Mantiene orden de inserci√≥n
Map<String, User> map3 = new TreeMap<>();       // Ordenado por clave
Map<String, User> map4 = Map.of("k1", v1, "k2", v2);  // Inmutable (Java 9+)

// Operaciones
map1.put("key", user);                          // Agregar/actualizar
User user = map1.get("key");                    // Obtener (null si no existe)
User user = map1.getOrDefault("key", defaultUser);  // Con valor por defecto
map1.remove("key");                             // Eliminar
boolean hasKey = map1.containsKey("key");       // Verificar clave
boolean hasValue = map1.containsValue(user);    // Verificar valor
int size = map1.size();                         // Tama√±o

// Iterar sobre Map
for (Map.Entry<String, User> entry : map1.entrySet()) {
    String key = entry.getKey();
    User value = entry.getValue();
}

// Con Streams
map1.forEach((key, value) -> System.out.println(key + ": " + value));
```

**Cu√°ndo usar:**
- ‚úÖ Cuando necesitas buscar por clave
- ‚úÖ Cuando tienes pares clave-valor
- ‚úÖ Como cach√© (ID ‚Üí Objeto)
- Ejemplos: usuarios por ID, configuraciones, cach√©

### Tabla de Decisi√≥n

| Necesitas | Usa |
|-----------|-----|
| Orden + Duplicados | `ArrayList<T>` |
| Sin duplicados + B√∫squeda r√°pida | `HashSet<T>` |
| Sin duplicados + Orden | `LinkedHashSet<T>` |
| Buscar por clave | `HashMap<K, V>` |
| Muchas inserciones/eliminaciones | `LinkedList<T>` |
| Ordenaci√≥n natural | `TreeSet<T>` o `TreeMap<K, V>` |

### Colecciones Inmutables (Java 9+)

```java
// ‚úÖ INMUTABLES (no se pueden modificar)
List<String> list = List.of("a", "b", "c");
Set<String> set = Set.of("a", "b", "c");
Map<String, Integer> map = Map.of("a", 1, "b", 2);

// Intentar modificar lanza UnsupportedOperationException
list.add("d");  // ‚ùå Error en tiempo de ejecuci√≥n

// Para versiones antiguas de Java
List<String> list = Collections.unmodifiableList(Arrays.asList("a", "b", "c"));
```

### Ejemplo del Proyecto

```java
// En el Repository Adapter
public class JpaUserRepositoryAdapter implements UserRepository {

    // Map como cach√©
    private final Map<UUID, User> cache = new HashMap<>();

    @Override
    public Optional<User> findById(UUID id) {
        // Buscar en cach√© primero (Map es r√°pido)
        if (cache.containsKey(id)) {
            return Optional.of(cache.get(id));
        }

        // Si no est√° en cach√©, buscar en BD
        return springDataRepo.findById(id)
            .map(mapper::toDomain)
            .map(user -> {
                cache.put(id, user);  // Guardar en cach√©
                return user;
            });
    }
}

// En el Service
public Set<String> getUniqueEmails() {
    // Set para eliminar duplicados autom√°ticamente
    return userRepository.findAll().stream()
        .map(user -> user.getEmail().getValue())
        .collect(Collectors.toSet());  // ‚Üê Set, no List
}
```

---

## Records - DTOs Inmutables

### ¬øQu√© son los Records? (Java 14+)

Los **Records** son clases especiales para crear DTOs inmutables con menos c√≥digo.

### Antes de Records

```java
// ‚ùå VIEJO: Clase con boilerplate
public final class UserResult {
    private final UUID id;
    private final String username;
    private final String email;

    public UserResult(UUID id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    public UUID getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }

    @Override
    public boolean equals(Object o) { /* ... */ }

    @Override
    public int hashCode() { /* ... */ }

    @Override
    public String toString() { /* ... */ }
}
```

**50 l√≠neas de c√≥digo!** üòµ

### Con Records

```java
// ‚úÖ MODERNO: Record (equivalente al anterior)
public record UserResult(
    UUID id,
    String username,
    String email
) {}
```

**4 l√≠neas!** üéâ

**El compilador genera autom√°ticamente:**
- Constructor
- Getters (sin `get` prefix: `id()`, `username()`, `email()`)
- `equals()` y `hashCode()`
- `toString()`

### Usar Records

```java
// Crear
UserResult result = new UserResult(id, "john", "john@ex.com");

// Acceder (sin "get")
UUID id = result.id();
String username = result.username();
String email = result.email();

// toString autom√°tico
System.out.println(result);
// UserResult[id=..., username=john, email=john@ex.com]

// equals por valor
UserResult r1 = new UserResult(id, "john", "john@ex.com");
UserResult r2 = new UserResult(id, "john", "john@ex.com");
r1.equals(r2);  // true
```

### Records con M√©todos

```java
public record UserResult(
    UUID id,
    String username,
    String email
) {
    // Validaci√≥n en el constructor
    public UserResult {  // Constructor compacto
        if (username == null || username.isBlank()) {
            throw new IllegalArgumentException("Username cannot be blank");
        }
    }

    // M√©todos adicionales
    public String getDisplayName() {
        return username + " (" + email + ")";
    }

    // M√©todo est√°tico
    public static UserResult from(User user) {
        return new UserResult(
            user.getId(),
            user.getUsername().getValue(),
            user.getEmail().getValue()
        );
    }
}
```

### Cu√°ndo usar Records

| Situaci√≥n | Usar Record |
|-----------|-------------|
| ‚úÖ DTOs inmutables | `CreateUserCommand`, `UserResult`, `UserResponse` |
| ‚úÖ Value Objects simples | `Coordinates(lat, lon)`, `Money(amount, currency)` |
| ‚úÖ Resultados de queries | `UserStats(count, avgAge)` |
| ‚ùå Entities con comportamiento | `User` (mejor clase normal) |
| ‚ùå Clases mutables | Necesitas setters (usar clase normal) |

### Ejemplos del Proyecto

```java
// Command
public record CreateUserCommand(String username, String email) {}

// Result
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Event
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}

// REST DTO
public record CreateUserRequest(String username, String email) {}
public record UserResponse(
    String id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

---

## Inmutabilidad

### ¬øQu√© es Inmutabilidad?

Un objeto **inmutable** NO puede cambiar despu√©s de crearse.

### Por qu√© es Importante

```java
// ‚ùå MUTABLE (peligroso)
public class User {
    private String username;

    public void setUsername(String username) {
        this.username = username;
    }
}

// Problema: Cambios inesperados
User user = new User("john");
processUser(user);  // ¬øCambi√≥ el username?
System.out.println(user.getUsername());  // ¬øQu√© imprime?

void processUser(User user) {
    user.setUsername("modified");  // üí• Efecto secundario!
}
```

```java
// ‚úÖ INMUTABLE (seguro)
public final class User {
    private final String username;

    public User(String username) {
        this.username = username;
    }

    // Sin setters

    // Para "cambiar", crear uno nuevo
    public User withUsername(String newUsername) {
        return new User(newUsername);
    }
}

// Uso seguro
User user = new User("john");
User modified = user.withUsername("johnny");
// user sigue siendo "john" ‚úÖ
// modified es "johnny" ‚úÖ
```

### Crear Clases Inmutables

```java
// Checklist para inmutabilidad:
public final class Email {  // 1. Clase final (no heredable)

    private final String value;  // 2. Campos final (no cambian)

    // 3. Sin setters
    // public void setValue(String value) { }  ‚ùå NO

    // 4. Constructor que inicializa todo
    public Email(String value) {
        this.value = value;
    }

    // 5. Solo getters
    public String getValue() {
        return value;
    }

    // 6. Para "modificar", crear nuevo objeto
    public Email withDomain(String newDomain) {
        String[] parts = value.split("@");
        return new Email(parts[0] + "@" + newDomain);
    }
}
```

### Inmutabilidad con Colecciones

```java
// ‚ùå MUTABLE: La lista puede cambiar
public class Order {
    private final List<Item> items;

    public Order(List<Item> items) {
        this.items = items;  // ¬°Referencia a lista mutable!
    }

    public List<Item> getItems() {
        return items;  // ¬°Expone lista mutable!
    }
}

// Problema:
Order order = new Order(items);
order.getItems().add(newItem);  // üí• Modific√≥ el Order!

// ‚úÖ INMUTABLE: Copias defensivas
public class Order {
    private final List<Item> items;

    public Order(List<Item> items) {
        this.items = new ArrayList<>(items);  // Copia defensiva
    }

    public List<Item> getItems() {
        return List.copyOf(items);  // Copia inmutable
        // o: Collections.unmodifiableList(items);
    }
}
```

### Beneficios de la Inmutabilidad

1. **Thread-safe**: No hay race conditions
2. **Predecible**: El objeto no cambia inesperadamente
3. **Cacheable**: Puedes guardar referencias sin preocuparte
4. **Testeable**: F√°cil de probar (sin estado mutable)

---

## final Keyword - Garantizando Inmutabilidad

### ¬øQu√© es final?

`final` es una palabra clave que **previene modificaciones**:
- **Variables**: No se puede cambiar el valor/referencia
- **M√©todos**: No se pueden sobrescribir (override)
- **Clases**: No se pueden heredar (extend)

---

### final en Variables

```java
// Variables locales
final String name = "John";
name = "Jane";  // ‚ùå Error de compilaci√≥n

// Par√°metros de m√©todo
public void processUser(final User user) {
    user = new User();  // ‚ùå Error de compilaci√≥n
    user.setName("x");  // ‚úÖ OK - solo la referencia es final
}

// Campos de clase
public class User {
    private final UUID id;  // ‚úÖ Debe inicializarse en constructor
    private final String name;

    public User(UUID id, String name) {
        this.id = id;
        this.name = name;
    }

    // No hay setters - inmutable ‚úÖ
}
```

**IMPORTANTE:** `final` en una variable **NO hace el objeto inmutable**, solo la referencia:

```java
final List<String> list = new ArrayList<>();
list = new ArrayList<>();  // ‚ùå Error - no puedes cambiar la referencia
list.add("item");          // ‚úÖ OK - el objeto List sigue siendo mutable

// Para inmutabilidad real, usa colecciones inmutables:
final List<String> immutableList = List.of("a", "b");
immutableList.add("c");  // ‚ùå UnsupportedOperationException
```

---

### final en Clases

```java
// ‚úÖ Clase final - no se puede heredar
public final class Email {
    private final String value;

    public Email(String value) {
        this.value = value;
    }
}

// ‚ùå Error de compilaci√≥n
public class GmailEmail extends Email {  // No se puede heredar de final
}
```

**¬øCu√°ndo hacer una clase final?**
- ‚úÖ Value Objects (Email, Username, Money)
- ‚úÖ DTOs que no necesitan herencia
- ‚úÖ Clases utilitarias (sin estado)
- ‚úÖ Cuando quieres garantizar comportamiento inmutable

---

### final en M√©todos

```java
public class BaseService {
    // ‚úÖ M√©todo final - no se puede sobrescribir
    public final void validateInput(String input) {
        if (input == null) throw new IllegalArgumentException();
    }

    // M√©todo normal - se puede sobrescribir
    public void process(String input) {
        validateInput(input);
        // ... procesamiento
    }
}

public class ExtendedService extends BaseService {
    @Override
    public void validateInput(String input) {  // ‚ùå Error - m√©todo es final
        // ...
    }

    @Override
    public void process(String input) {  // ‚úÖ OK - m√©todo no es final
        // ...
    }
}
```

**¬øCu√°ndo hacer un m√©todo final?**
- ‚úÖ M√©todos cr√≠ticos de seguridad
- ‚úÖ M√©todos de validaci√≥n
- ‚úÖ Template methods que no deben cambiar

---

### Ejemplo Completo del Proyecto

```java
/**
 * Value Object inmutable
 * - Clase final: No se puede heredar
 * - Campo final: No se puede modificar
 * - Sin setters: No hay mutaci√≥n
 */
public final class Email {

    private final String value;  // ‚úÖ Campo final - inmutable

    private Email(String value) {  // Constructor privado
        this.value = value;
    }

    // ‚úÖ Factory method est√°tico
    public static Email of(final String value) {  // ‚úÖ Par√°metro final
        validate(value);
        return new Email(value);
    }

    private static void validate(final String value) {
        if (value == null || value.isBlank()) {
            throw new ValidationException("Email no puede estar vac√≠o");
        }
        if (!value.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new ValidationException("Email inv√°lido");
        }
    }

    public String getValue() {
        return value;  // ‚úÖ Solo getter, no setter
    }

    // ‚úÖ Para "modificar", crear nuevo objeto
    public final Email withDomain(final String newDomain) {
        String localPart = value.split("@")[0];
        return Email.of(localPart + "@" + newDomain);
    }
}
```

Ver ejemplo real: `src/main/java/com/example/hexarch/user/domain/model/valueobject/Email.java`

---

## Inmutabilidad Profunda (Deep Immutability)

### Shallow vs Deep Immutability

```java
// ‚ùå SHALLOW IMMUTABILITY (solo la referencia es final)
public final class Order {
    private final List<Item> items;  // Lista es final, pero es MUTABLE
    private final Customer customer;  // Customer puede ser mutable

    public Order(List<Item> items, Customer customer) {
        this.items = items;      // ‚ö†Ô∏è Referencia compartida!
        this.customer = customer;  // ‚ö†Ô∏è Objeto mutable!
    }

    public List<Item> getItems() {
        return items;  // ‚ö†Ô∏è Expone lista mutable!
    }
}

// Problema:
List<Item> originalItems = new ArrayList<>();
Order order = new Order(originalItems, customer);

originalItems.add(newItem);  // üí• Modific√≥ el Order desde fuera!
order.getItems().clear();     // üí• Modific√≥ el Order desde dentro!
customer.setName("changed");   // üí• Modific√≥ el Customer!
```

```java
// ‚úÖ DEEP IMMUTABILITY (todo es inmutable)
public final class Order {
    private final List<Item> items;  // Copia defensiva
    private final Customer customer;  // Inmutable

    public Order(List<Item> items, Customer customer) {
        // ‚úÖ Copia defensiva en el constructor
        this.items = List.copyOf(items);  // Inmutable
        this.customer = customer;  // Asume que Customer es inmutable
    }

    public List<Item> getItems() {
        // ‚úÖ Ya es inmutable por List.copyOf()
        return items;
    }

    // ‚úÖ Para "modificar", crear nuevo Order
    public Order addItem(Item newItem) {
        List<Item> newItems = new ArrayList<>(this.items);
        newItems.add(newItem);
        return new Order(newItems, this.customer);
    }
}
```

---

### Defensive Copying (Copias Defensivas)

**Regla:** Nunca conf√≠es en referencias que vienen de fuera o salen hacia fuera.

```java
public final class User {
    private final List<Role> roles;  // Lista de roles

    // ‚úÖ CORRECTO: Copia defensiva en constructor
    public User(List<Role> roles) {
        this.roles = List.copyOf(roles);  // Inmutable
        // Alternativas:
        // this.roles = Collections.unmodifiableList(new ArrayList<>(roles));
        // this.roles = new ArrayList<>(roles);  // Si quieres mutable interno
    }

    // ‚úÖ CORRECTO: Devolver copia inmutable
    public List<Role> getRoles() {
        return roles;  // Ya es inmutable por List.copyOf()
        // O si es mutable interno:
        // return List.copyOf(roles);
        // return Collections.unmodifiableList(roles);
    }
}
```

**Ejemplo Real del Proyecto:**

```java
// En User.java (Aggregate Root)
public final class User {
    private final UUID id;
    private final Username username;  // ‚úÖ Username es inmutable
    private final Email email;        // ‚úÖ Email es inmutable
    private final boolean enabled;
    private final Instant createdAt;  // ‚úÖ Instant es inmutable

    // ‚úÖ Todo es final e inmutable (deep immutability)

    // No hay setters - para "modificar", crear nuevo User
    public User withUsername(Username newUsername) {
        return new User(this.id, newUsername, this.email, this.enabled, this.createdAt);
    }
}
```

Ver c√≥digo completo: `src/main/java/com/example/hexarch/user/domain/model/User.java:1-142`

---

### Colecciones Inmutables en Detalle

```java
// ========================================
// COLECCIONES INMUTABLES (Java 9+)
// ========================================

// ‚úÖ List.of() - Inmutable, tama√±o fijo, no acepta null
List<String> list = List.of("a", "b", "c");
list.add("d");     // ‚ùå UnsupportedOperationException
list.set(0, "x");  // ‚ùå UnsupportedOperationException
list.remove(0);    // ‚ùå UnsupportedOperationException

// ‚úÖ Set.of() - Inmutable, sin duplicados, no acepta null
Set<String> set = Set.of("a", "b", "c");
set.add("d");  // ‚ùå UnsupportedOperationException

// ‚úÖ Map.of() - Inmutable, no acepta null
Map<String, Integer> map = Map.of("a", 1, "b", 2, "c", 3);
map.put("d", 4);  // ‚ùå UnsupportedOperationException

// Para m√°s de 10 elementos en Map:
Map<String, Integer> bigMap = Map.ofEntries(
    Map.entry("a", 1),
    Map.entry("b", 2),
    // ... m√°s entradas
);

// ========================================
// ALTERNATIVAS PRE-JAVA 9
// ========================================

// Collections.unmodifiableList() - Inmutable VIEW (la original puede cambiar)
List<String> original = new ArrayList<>(Arrays.asList("a", "b"));
List<String> unmodifiable = Collections.unmodifiableList(original);

unmodifiable.add("c");  // ‚ùå UnsupportedOperationException
original.add("c");      // ‚úÖ OK - modifica la original
System.out.println(unmodifiable);  // [a, b, c] ‚ö†Ô∏è Cambi√≥!

// ‚úÖ Copia inmutable real
List<String> immutable = List.copyOf(original);
original.add("d");
System.out.println(immutable);  // [a, b] ‚úÖ No cambi√≥

// ========================================
// COMPARACI√ìN
// ========================================
```

| M√©todo | Inmutable | Acepta null | Performance | Versi√≥n |
|--------|-----------|-------------|-------------|---------|
| `List.of()` | ‚úÖ S√≠ | ‚ùå No | ‚ö° R√°pido | Java 9+ |
| `List.copyOf()` | ‚úÖ S√≠ | ‚ùå No | ‚ö° R√°pido | Java 10+ |
| `Collections.unmodifiableList()` | ‚ö†Ô∏è View | ‚úÖ S√≠ | ‚ö° R√°pido | Java 1.2+ |
| `new ArrayList<>()` | ‚ùå No | ‚úÖ S√≠ | üêå Lento | Siempre |

**Recomendaci√≥n:** Usa `List.of()`, `Set.of()`, `Map.of()` en Java 9+

---

## Records en Profundidad (Java 21)

### Compact Constructor - Validaciones

El **compact constructor** es la forma idiom√°tica de validar Records:

```java
// ‚úÖ Compact Constructor (sin par√°metros expl√≠citos)
public record Email(String value) {

    // ‚úÖ Este es el compact constructor
    public Email {
        // Se ejecuta ANTES de asignar los campos
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Email vac√≠o");
        }
        if (!value.contains("@")) {
            throw new IllegalArgumentException("Email inv√°lido");
        }
        // No necesitas asignar: this.value = value;
        // El compilador lo hace autom√°ticamente DESPU√âS de la validaci√≥n
    }
}

// ‚ùå Constructor can√≥nico expl√≠cito (m√°s verboso)
public record Email(String value) {

    public Email(String value) {  // Constructor can√≥nico
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Email vac√≠o");
        }
        this.value = value;  // ‚ùå Necesitas asignaci√≥n expl√≠cita
    }
}
```

**Ventaja del Compact Constructor:**
- M√°s conciso (no repites los par√°metros)
- No necesitas asignaci√≥n expl√≠cita
- El compilador garantiza que todos los campos se inicializan

---

### Records con Normalizaci√≥n

```java
public record Username(String value) {

    public Username {
        // Validar
        if (value == null || value.isBlank()) {
            throw new IllegalArgumentException("Username vac√≠o");
        }

        // ‚úÖ Normalizar (trim, lowercase)
        value = value.trim().toLowerCase();

        // Validar despu√©s de normalizar
        if (value.length() < 3 || value.length() > 50) {
            throw new IllegalArgumentException("Username debe tener 3-50 caracteres");
        }
    }
}

// Uso:
Username u1 = new Username("  JohnDoe  ");  // Normaliza a "johndoe"
Username u2 = new Username("johndoe");
u1.equals(u2);  // true - son iguales despu√©s de normalizaci√≥n
```

---

### Records vs Clases - Comparaci√≥n Detallada

| Caracter√≠stica | Record | Clase Normal |
|----------------|--------|--------------|
| **Boilerplate** | ‚ö° M√≠nimo (~5 l√≠neas) | üêå Mucho (~50 l√≠neas) |
| **Inmutabilidad** | ‚úÖ Garantizada | ‚ö†Ô∏è Manual |
| **Herencia** | ‚ùå No puede extender (solo implementar interfaces) | ‚úÖ Puede extender |
| **Campos** | ‚úÖ Todos final, p√∫blicos (v√≠a accessors) | ‚ö†Ô∏è T√∫ decides |
| **Constructor** | ‚úÖ Autom√°tico (can√≥nico + compacto) | ‚ö†Ô∏è Manual |
| **equals/hashCode** | ‚úÖ Autom√°tico (por valor) | ‚ö†Ô∏è Manual o @EqualsAndHashCode |
| **toString** | ‚úÖ Autom√°tico | ‚ö†Ô∏è Manual o @ToString |
| **Serializaci√≥n** | ‚úÖ Funciona con Jackson/JPA | ‚úÖ Funciona |
| **M√©todos adicionales** | ‚úÖ Puedes agregar | ‚úÖ Puedes agregar |
| **Uso t√≠pico** | DTOs, Value Objects simples, Commands/Queries | Entities, Aggregates, Services |

---

### Records con Jackson (Serializaci√≥n JSON)

```java
// ‚úÖ Records funcionan perfectamente con Jackson
public record CreateUserRequest(
    String username,
    String email
) {}

// Deserializaci√≥n (JSON ‚Üí Record)
String json = """
    {
        "username": "johndoe",
        "email": "john@example.com"
    }
    """;

ObjectMapper mapper = new ObjectMapper();
CreateUserRequest request = mapper.readValue(json, CreateUserRequest.class);
// ‚úÖ Jackson usa el constructor can√≥nico

// Serializaci√≥n (Record ‚Üí JSON)
String jsonOutput = mapper.writeValueAsString(request);
// {"username":"johndoe","email":"john@example.com"}

// ‚úÖ Con Jackson annotations
public record UserResponse(
    @JsonProperty("user_id") String id,  // Cambia nombre en JSON
    String username,
    String email,
    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
    Instant createdAt
) {}
```

---

### Records con Bean Validation

```java
// ‚úÖ Records con validaciones de Bean Validation
public record CreateUserRequest(
    @NotBlank(message = "Username es requerido")
    @Size(min = 3, max = 50, message = "Username debe tener 3-50 caracteres")
    String username,

    @NotBlank(message = "Email es requerido")
    @Email(message = "Email debe ser v√°lido")
    String email
) {}

// Validaci√≥n autom√°tica en Controllers
@PostMapping("/users")
public ResponseEntity<UserResponse> createUser(
    @Valid @RequestBody CreateUserRequest request  // @Valid activa validaciones
) {
    // Si la validaci√≥n falla, Spring lanza MethodArgumentNotValidException
    // ...
}
```

---

### Cu√°ndo NO Usar Records

‚ùå **No uses Records cuando:**

1. **Necesitas herencia (extends)**
   ```java
   // ‚ùå Records NO pueden extender clases
   public record AdminUser(String username) extends User { }  // Error

   // ‚úÖ Usa clase normal si necesitas herencia
   public class AdminUser extends User {
       public AdminUser(String username) {
           super(username);
       }
   }
   ```

2. **Necesitas mutabilidad (setters)**
   ```java
   // ‚ùå Records son inmutables
   public record User(String name) {
       public void setName(String name) {  // No tiene sentido
           this.name = name;  // ‚ùå final, no se puede cambiar
       }
   }

   // ‚úÖ Usa clase normal si necesitas mutabilidad
   public class User {
       private String name;
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

3. **Aggregates con l√≥gica compleja**
   ```java
   // ‚ùå Record para Aggregate con mucha l√≥gica (no idiom√°tico)
   public record User(UUID id, String username, String email) {
       public void validateBusinessRules() { }
       public void applyDomainEvent() { }
       // ... 50 m√©todos m√°s
   }

   // ‚úÖ Usa clase normal para Aggregates
   public class User {
       // L√≥gica de dominio compleja
   }
   ```

4. **Necesitas control fino sobre equals/hashCode**
   ```java
   // ‚ùå Record usa TODOS los campos para equals
   public record User(UUID id, String username, Instant lastLogin) {}
   // lastLogin participa en equals (probablemente no quieres eso)

   // ‚úÖ Usa clase normal si necesitas equals customizado
   public class User {
       @Override
       public boolean equals(Object o) {
           // Solo comparar por id
       }
   }
   ```

---

### Resumen: ¬øRecord o Clase?

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    DECISION TREE                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

¬øEs un DTO inmutable?
‚îú‚îÄ S√≠ ‚Üí ‚úÖ Record
‚îî‚îÄ No ‚Üì

¬øEs un Value Object simple?
‚îú‚îÄ S√≠ ‚Üí ‚úÖ Record
‚îî‚îÄ No ‚Üì

¬øNecesitas herencia?
‚îú‚îÄ S√≠ ‚Üí ‚ùå Clase normal
‚îî‚îÄ No ‚Üì

¬øNecesitas mutabilidad?
‚îú‚îÄ S√≠ ‚Üí ‚ùå Clase normal
‚îî‚îÄ No ‚Üì

¬øTiene l√≥gica de negocio compleja?
‚îú‚îÄ S√≠ ‚Üí ‚ùå Clase normal (Aggregate/Entity)
‚îî‚îÄ No ‚Üí ‚úÖ Record
```

---

### Ejemplos del Proyecto con Records

```java
// ‚úÖ Commands (CQRS Write side)
public record CreateUserCommand(String username, String email) {}

// ‚úÖ Queries (CQRS Read side)
public record GetUserQuery(UUID userId) {}

// ‚úÖ Results (DTOs de retorno)
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {
    // Factory method
    public static UserResult from(User user) {
        return new UserResult(
            user.getId(),
            user.getUsername().getValue(),
            user.getEmail().getValue(),
            user.isEnabled(),
            user.getCreatedAt()
        );
    }
}

// ‚úÖ Domain Events
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(User user) {
        return new UserCreatedEvent(
            user.getId(),
            user.getUsername().getValue(),
            user.getEmail().getValue(),
            Instant.now()
        );
    }
}

// ‚úÖ REST DTOs (OpenAPI generated)
public record CreateUserRequest(
    @NotBlank String username,
    @Email String email
) {}

public record UserResponse(
    String id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

Ver ejemplos reales en:
- Commands: `src/main/java/.../application/port/input/`
- DTOs: `src/main/java/.../infrastructure/adapter/input/rest/dto/`
- Events: `src/main/java/.../domain/event/`

---

## var - Inferencia de Tipos (Java 10+)

### ¬øQu√© es var?

`var` permite al compilador **inferir el tipo** autom√°ticamente.

### Uso B√°sico

```java
// Sin var (verboso)
List<String> names = new ArrayList<String>();
Map<UUID, User> userMap = new HashMap<UUID, User>();
UserResult result = new UserResult(id, username, email);

// Con var (conciso)
var names = new ArrayList<String>();
var userMap = new HashMap<UUID, User>();
var result = new UserResult(id, username, email);
```

### Cu√°ndo usar var

```java
// ‚úÖ Cuando el tipo es obvio
var user = new User("john", "john@ex.com");  // Obvio que es User
var users = userRepository.findAll();        // Obvio que es List<User>
var request = new CreateUserRequest("john", "john@ex.com");

// ‚úÖ Con tipos complejos/gen√©ricos
var map = new HashMap<UUID, Map<String, List<Order>>>();  // Evita repetir el tipo

// ‚ùå NO cuando el tipo no es claro
var result = process();  // ¬øQu√© devuelve process()?
var value = getValue();  // ¬øString? Integer? Object?

// ‚úÖ Mejor con tipo expl√≠cito cuando no es obvio
String result = process();
int value = getValue();
```

### Restricciones de var

```java
// ‚ùå NO se puede usar en:
var x;  // Sin inicializaci√≥n
var y = null;  // Sin tipo inferible
private var field;  // Campos de clase
public var method() { }  // Tipo de retorno
var lambda = x -> x * 2;  // Lambdas sin contexto
```

### Ejemplo del Proyecto

```java
// En el Service
public UserResult execute(CreateUserCommand command) {
    // ‚úÖ var cuando el tipo es obvio
    var username = Username.of(command.username());
    var email = Email.of(command.email());
    var user = User.create(command.username(), command.email());
    var savedUser = userRepository.save(user);
    var event = UserCreatedEvent.from(savedUser.getId(), ...);

    // ‚úÖ var en bucles
    for (var user : users) {
        System.out.println(user.getUsername());
    }

    return new UserResult(...);
}
```

---

## Try-with-Resources

### El Problema con Recursos

```java
// ‚ùå VIEJO: Cerrar manualmente (propenso a errores)
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    // usar fis
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        try {
            fis.close();  // Puede fallar!
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Try-with-Resources

```java
// ‚úÖ MODERNO: Cierra autom√°ticamente
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // usar fis
} catch (IOException e) {
    e.printStackTrace();
}  // fis se cierra autom√°ticamente, incluso si hay excepci√≥n
```

### M√∫ltiples Recursos

```java
// ‚úÖ M√∫ltiples recursos
try (
    var input = new FileInputStream("input.txt");
    var output = new FileOutputStream("output.txt");
    var reader = new BufferedReader(new InputStreamReader(input))
) {
    // usar input, output, reader
}  // Todos se cierran autom√°ticamente en orden inverso
```

### Recursos Personalizados

Cualquier clase que implemente `AutoCloseable` puede usarse:

```java
public class DatabaseConnection implements AutoCloseable {
    public void open() {
        // abrir conexi√≥n
    }

    @Override
    public void close() {
        // cerrar conexi√≥n (llamado autom√°ticamente)
    }
}

// Uso
try (var conn = new DatabaseConnection()) {
    conn.open();
    // usar conexi√≥n
}  // conn.close() llamado autom√°ticamente
```

---

## Switch Expressions (Java 14+)

### Switch Tradicional vs Switch Expression

```java
// ‚ùå VIEJO: Switch statement (verboso)
String message;
switch (status) {
    case ACTIVE:
        message = "Usuario activo";
        break;
    case DISABLED:
        message = "Usuario deshabilitado";
        break;
    case PENDING:
        message = "Usuario pendiente";
        break;
    default:
        message = "Estado desconocido";
        break;
}

// ‚úÖ MODERNO: Switch expression (conciso)
var message = switch (status) {
    case ACTIVE -> "Usuario activo";
    case DISABLED -> "Usuario deshabilitado";
    case PENDING -> "Usuario pendiente";
    default -> "Estado desconocido";
};  // Devuelve un valor!
```

### M√∫ltiples Casos

```java
var dayType = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "D√≠a laboral";
    case SATURDAY, SUNDAY -> "Fin de semana";
};
```

### Con Bloques

```java
var result = switch (value) {
    case 1 -> "Uno";
    case 2 -> {
        System.out.println("Es dos");
        yield "Dos";  // yield en lugar de return
    }
    case 3 -> "Tres";
    default -> "Otro";
};
```

### Pattern Matching (Java 17+)

```java
// Verificar tipo y castear en un paso
var description = switch (obj) {
    case String s -> "String de longitud " + s.length();
    case Integer i -> "Entero: " + i;
    case List list -> "Lista con " + list.size() + " elementos";
    case null -> "Es null";
    default -> "Tipo desconocido";
};
```

---

## Resumen: Cu√°ndo Usar Qu√©

| Necesitas | Usa |
|-----------|-----|
| Evitar nulls | `Optional<T>` |
| Procesar colecci√≥n | `Stream` + `filter/map/collect` |
| Funci√≥n an√≥nima | Lambda `x -> x * 2` |
| DTO inmutable | `record` |
| Lista ordenada | `ArrayList<T>` |
| Sin duplicados | `HashSet<T>` o `Set.of()` |
| B√∫squeda por clave | `HashMap<K, V>` |
| Tipo obvio | `var` |
| Cerrar recursos | `try-with-resources` |
| Switch con valor | Switch expression |
| Inmutabilidad | `final` fields + no setters |

---

## Checklist de Buenas Pr√°cticas

### ‚úÖ DO (Hacer)

- Usar Optional para valores que pueden no existir
- Usar Streams para procesar colecciones
- Usar Lambdas para c√≥digo conciso
- Usar Records para DTOs
- Usar colecciones inmutables cuando sea posible
- Usar var cuando el tipo es obvio
- Usar try-with-resources para recursos
- Preferir inmutabilidad

### ‚ùå DON'T (No Hacer)

- NO llamar `Optional.get()` sin verificar
- NO modificar colecciones durante iteraci√≥n
- NO usar Streams para operaciones simples
- NO usar Optional como par√°metro de m√©todo
- NO exponer colecciones mutables
- NO usar var cuando el tipo no es claro
- NO olvidar cerrar recursos
- NO hacer clases mutables sin raz√≥n

---

## Recursos para Seguir Aprendiendo

1. **Documentaci√≥n Oficial:** [Java SE Documentation](https://docs.oracle.com/en/java/)
2. **Modern Java in Action** - Libro sobre Java 8+
3. **Effective Java** - Joshua Bloch (mejores pr√°cticas)
4. **Java Brains** - Canal de YouTube con tutoriales

---

**¬°Usa estas features modernas para escribir c√≥digo m√°s limpio, seguro y conciso!** üöÄ
