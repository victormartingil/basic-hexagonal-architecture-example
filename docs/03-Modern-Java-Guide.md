# Gu√≠a de Java Moderno para Juniors

## üìö √çndice

1. [Optional - Adi√≥s a los NullPointerException](#optional)
2. [Streams - Procesamiento de Colecciones](#streams)
3. [Lambdas y Programaci√≥n Funcional](#lambdas)
4. [Colecciones - Cu√°ndo usar cada una](#colecciones)
5. [Records - DTOs Inmutables](#records)
6. [Inmutabilidad](#inmutabilidad)
7. [var - Inferencia de Tipos](#var)
8. [Try-with-Resources](#try-with-resources)
9. [Switch Expressions](#switch-expressions)

---

## Optional - Adi√≥s a los NullPointerException

### ¬øQu√© es Optional?

`Optional<T>` es un **contenedor** que puede tener o no tener un valor. Te obliga a pensar en el caso de "no hay valor" desde el principio.

### El Problema con null

```java
// ‚ùå C√ìDIGO PELIGROSO (pre-Optional)
public User findById(UUID id) {
    return userRepository.findById(id);  // ¬øQu√© pasa si no existe?
}

// Uso posterior
User user = findById(someId);
System.out.println(user.getUsername());  // üí• NullPointerException si user es null
```

### La Soluci√≥n: Optional

```java
// ‚úÖ C√ìDIGO SEGURO (con Optional)
public Optional<User> findById(UUID id) {
    return userRepository.findById(id);
}

// Uso posterior - OBLIGADO a manejar el caso "no existe"
Optional<User> userOpt = findById(someId);
if (userOpt.isPresent()) {
    User user = userOpt.get();
    System.out.println(user.getUsername());  // Seguro
}
```

### Crear Optional

```java
// 1. Optional con valor
Optional<String> opt1 = Optional.of("Hola");  // Lanza excepci√≥n si es null

// 2. Optional que puede ser null
Optional<String> opt2 = Optional.ofNullable(mightBeNull);  // No lanza excepci√≥n

// 3. Optional vac√≠o
Optional<String> opt3 = Optional.empty();
```

### M√©todos Importantes de Optional

#### 1. isPresent() / isEmpty()

```java
Optional<User> userOpt = findById(id);

// ‚úÖ Verificar si tiene valor
if (userOpt.isPresent()) {
    User user = userOpt.get();
    // usar user
}

// ‚úÖ Verificar si NO tiene valor (Java 11+)
if (userOpt.isEmpty()) {
    System.out.println("Usuario no encontrado");
}
```

#### 2. orElse() - Valor por defecto

```java
// ‚úÖ Si no existe, usa un valor por defecto
User user = userOpt.orElse(defaultUser);

String username = findUsername(id).orElse("Anonymous");
```

#### 3. orElseThrow() - Lanzar excepci√≥n

```java
// ‚úÖ Si no existe, lanza excepci√≥n personalizada
User user = userOpt.orElseThrow(() ->
    new UserNotFoundException("User not found: " + id)
);
```

**Ejemplo del proyecto:**
```java
// En el Service
@Override
public UserResult execute(UUID userId) {
    User user = userRepository.findById(userId)
        .orElseThrow(() -> new UserNotFoundException(userId));  // ‚úÖ

    return new UserResult(...);
}
```

#### 4. ifPresent() - Ejecutar si existe

```java
// ‚úÖ Ejecuta c√≥digo solo si tiene valor
userOpt.ifPresent(user -> {
    System.out.println("Usuario: " + user.getUsername());
});

// ‚úÖ Con m√©todo reference
userOpt.ifPresent(this::processUser);
```

#### 5. map() - Transformar el valor

```java
// ‚úÖ Transformar el valor si existe
Optional<String> usernameOpt = userOpt.map(User::getUsername);
Optional<String> emailOpt = userOpt.map(user -> user.getEmail().getValue());

// Si userOpt est√° vac√≠o, usernameOpt tambi√©n estar√° vac√≠o
```

#### 6. flatMap() - Transformar cuando el resultado es Optional

```java
// ‚úÖ Cuando el mapper devuelve Optional
Optional<User> userOpt = findById(userId);
Optional<Order> orderOpt = userOpt.flatMap(user -> findLastOrder(user.getId()));

// Sin flatMap ser√≠a Optional<Optional<Order>> ‚ùå
```

### ‚ö†Ô∏è Anti-patrones con Optional

```java
// ‚ùå NO HACER: llamar get() sin verificar
User user = userOpt.get();  // Puede lanzar NoSuchElementException

// ‚ùå NO HACER: usar isPresent() + get()
if (userOpt.isPresent()) {
    User user = userOpt.get();
    return user.getUsername();
}

// ‚úÖ HACER: usar map() + orElse()
return userOpt
    .map(User::getUsername)
    .orElse("Unknown");

// ‚ùå NO USAR Optional como par√°metro
public void updateUser(Optional<User> user) { }  // MAL

// ‚úÖ USAR null o sobrecarga
public void updateUser(User user) { }  // BIEN
```

### Resumen: Cu√°ndo usar Optional

| Situaci√≥n | Usar Optional |
|-----------|---------------|
| ‚úÖ Valor de retorno que puede no existir | `Optional<User> findById(UUID id)` |
| ‚úÖ Campo de clase opcional | `private Optional<Email> secondaryEmail;` |
| ‚ùå Par√°metros de m√©todo | NO usar, usar null o sobrecarga |
| ‚ùå Colecciones | NO usar `Optional<List<T>>`, usar lista vac√≠a |

---

## Streams - Procesamiento de Colecciones

### ¬øQu√© son los Streams?

Los **Streams** permiten procesar colecciones de forma **funcional** y **declarativa** (dices QU√â quieres, no C√ìMO hacerlo).

### Crear Streams

```java
// Desde una List
List<User> users = Arrays.asList(...);
Stream<User> stream = users.stream();

// Desde un array
String[] names = {"John", "Jane", "Bob"};
Stream<String> stream = Arrays.stream(names);

// Stream vac√≠o
Stream<String> empty = Stream.empty();

// Stream de valores
Stream<String> stream = Stream.of("a", "b", "c");
```

### Operaciones de Stream

#### 1. filter() - Filtrar elementos

```java
// ‚ùå FORMA IMPERATIVA (vieja)
List<User> activeUsers = new ArrayList<>();
for (User user : users) {
    if (user.isEnabled()) {
        activeUsers.add(user);
    }
}

// ‚úÖ FORMA DECLARATIVA (con Streams)
List<User> activeUsers = users.stream()
    .filter(user -> user.isEnabled())
    .collect(Collectors.toList());

// M√∫ltiples filtros
List<User> result = users.stream()
    .filter(user -> user.isEnabled())
    .filter(user -> user.getEmail().getValue().endsWith("@gmail.com"))
    .collect(Collectors.toList());
```

#### 2. map() - Transformar elementos

```java
// ‚ùå FORMA IMPERATIVA
List<String> usernames = new ArrayList<>();
for (User user : users) {
    usernames.add(user.getUsername().getValue());
}

// ‚úÖ FORMA DECLARATIVA
List<String> usernames = users.stream()
    .map(user -> user.getUsername().getValue())
    .collect(Collectors.toList());

// Con method reference (m√°s limpio)
List<String> usernames = users.stream()
    .map(User::getUsername)
    .map(Username::getValue)
    .collect(Collectors.toList());
```

#### 3. collect() - Recolectar resultados

```java
// A List
List<User> list = users.stream()
    .filter(User::isEnabled)
    .collect(Collectors.toList());

// A Set (sin duplicados)
Set<String> emails = users.stream()
    .map(user -> user.getEmail().getValue())
    .collect(Collectors.toSet());

// A Map
Map<UUID, User> userMap = users.stream()
    .collect(Collectors.toMap(User::getId, user -> user));

// Agrupar por campo
Map<Boolean, List<User>> usersByStatus = users.stream()
    .collect(Collectors.groupingBy(User::isEnabled));
```

#### 4. forEach() - Ejecutar acci√≥n para cada elemento

```java
// ‚úÖ Imprimir cada usuario
users.stream()
    .forEach(user -> System.out.println(user.getUsername()));

// Con method reference
users.stream()
    .forEach(System.out::println);

// NOTA: Para solo iterar, mejor usar forEach directamente
users.forEach(System.out::println);  // M√°s simple
```

#### 5. count() - Contar elementos

```java
// Contar usuarios activos
long count = users.stream()
    .filter(User::isEnabled)
    .count();
```

#### 6. anyMatch() / allMatch() / noneMatch()

```java
// ¬øHay alg√∫n usuario activo?
boolean hasActive = users.stream()
    .anyMatch(User::isEnabled);

// ¬øTodos los usuarios son activos?
boolean allActive = users.stream()
    .allMatch(User::isEnabled);

// ¬øNing√∫n usuario es activo?
boolean noneActive = users.stream()
    .noneMatch(User::isEnabled);
```

#### 7. findFirst() / findAny()

```java
// Encontrar el primer usuario activo
Optional<User> firstActive = users.stream()
    .filter(User::isEnabled)
    .findFirst();

// Encontrar cualquier usuario activo (√∫til en paralelo)
Optional<User> anyActive = users.stream()
    .filter(User::isEnabled)
    .findAny();
```

#### 8. sorted() - Ordenar

```java
// Ordenar por username
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(user -> user.getUsername().getValue()))
    .collect(Collectors.toList());

// Con method reference
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(User::getCreatedAt))
    .collect(Collectors.toList());

// Orden inverso
List<User> sorted = users.stream()
    .sorted(Comparator.comparing(User::getCreatedAt).reversed())
    .collect(Collectors.toList());
```

#### 9. distinct() - Eliminar duplicados

```java
// Obtener emails √∫nicos
List<String> uniqueEmails = users.stream()
    .map(user -> user.getEmail().getValue())
    .distinct()
    .collect(Collectors.toList());
```

#### 10. limit() / skip()

```java
// Primeros 10 usuarios
List<User> first10 = users.stream()
    .limit(10)
    .collect(Collectors.toList());

// Saltar los primeros 5 y tomar los siguientes 10
List<User> page2 = users.stream()
    .skip(5)
    .limit(10)
    .collect(Collectors.toList());
```

### Ejemplo Completo del Proyecto

```java
// Obtener emails de usuarios activos, ordenados, sin duplicados
public List<String> getActiveUserEmails() {
    return userRepository.findAll().stream()
        .filter(User::isEnabled)                    // Solo activos
        .map(User::getEmail)                        // Extraer Email (Value Object)
        .map(Email::getValue)                       // Extraer String del VO
        .distinct()                                 // Sin duplicados
        .sorted()                                   // Ordenar
        .collect(Collectors.toList());             // A lista
}
```

### Streams Paralelos

```java
// Para colecciones grandes, procesar en paralelo
List<String> emails = users.parallelStream()  // ‚Üê parallel
    .filter(User::isEnabled)
    .map(user -> user.getEmail().getValue())
    .collect(Collectors.toList());

// Solo usar si la operaci√≥n es costosa y la colecci√≥n es grande (>10k elementos)
```

### ‚ö†Ô∏è Anti-patrones con Streams

```java
// ‚ùå NO: Modificar estado externo
List<User> result = new ArrayList<>();
users.stream().forEach(user -> result.add(user));  // MAL

// ‚úÖ USAR collect()
List<User> result = users.stream().collect(Collectors.toList());

// ‚ùå NO: Usar stream para operaciones simples
users.stream().forEach(System.out::println);  // Overkill

// ‚úÖ Usar forEach directo
users.forEach(System.out::println);
```

---

## Lambdas y Programaci√≥n Funcional

### ¬øQu√© es una Lambda?

Una **lambda** es una funci√≥n an√≥nima (sin nombre) que puedes pasar como par√°metro.

### Sintaxis de Lambda

```java
// Forma completa
(parametros) -> {
    cuerpo;
    return valor;
}

// Forma corta (una expresi√≥n)
(parametros) -> expresion

// Sin par√°metros
() -> System.out.println("Hola")

// Un par√°metro (sin par√©ntesis)
x -> x * 2

// M√∫ltiples par√°metros
(x, y) -> x + y

// Con tipos expl√≠citos
(String s) -> s.length()
```

### Ejemplos Pr√°cticos

#### Comparar: Clase An√≥nima vs Lambda

```java
// ‚ùå VIEJO: Clase an√≥nima (verbose)
users.sort(new Comparator<User>() {
    @Override
    public int compare(User u1, User u2) {
        return u1.getUsername().compareTo(u2.getUsername());
    }
});

// ‚úÖ MODERNO: Lambda (conciso)
users.sort((u1, u2) -> u1.getUsername().compareTo(u2.getUsername()));

// ‚úÖ A√öN MEJOR: Method reference
users.sort(Comparator.comparing(User::getUsername));
```

#### Interfaces Funcionales Comunes

```java
// 1. Predicate<T> - Funci√≥n que devuelve boolean
Predicate<User> isActive = user -> user.isEnabled();
boolean result = isActive.test(user);

// Uso en filter
users.stream().filter(isActive).collect(Collectors.toList());

// 2. Function<T, R> - Funci√≥n que transforma T en R
Function<User, String> getUsername = user -> user.getUsername().getValue();
String username = getUsername.apply(user);

// Uso en map
users.stream().map(getUsername).collect(Collectors.toList());

// 3. Consumer<T> - Funci√≥n que consume un valor (sin retorno)
Consumer<User> printUser = user -> System.out.println(user);
printUser.accept(user);

// Uso en forEach
users.forEach(printUser);

// 4. Supplier<T> - Funci√≥n que provee un valor (sin par√°metros)
Supplier<User> defaultUser = () -> User.create("default", "default@ex.com");
User user = defaultUser.get();

// Uso en orElseGet
Optional<User> userOpt = findById(id);
User user = userOpt.orElseGet(defaultUser);

// 5. BiFunction<T, U, R> - Funci√≥n con 2 par√°metros
BiFunction<String, String, User> createUser = (username, email) ->
    User.create(username, email);
User user = createUser.apply("john", "john@ex.com");
```

### Method References (Referencias a M√©todos)

Forma a√∫n m√°s corta cuando la lambda solo llama a un m√©todo:

```java
// Lambda: x -> metodo(x)
// Method Reference: Clase::metodo

// 1. M√©todo est√°tico
Function<String, Integer> parse = str -> Integer.parseInt(str);
Function<String, Integer> parse = Integer::parseInt;  // ‚úÖ

// 2. M√©todo de instancia
Function<User, String> getUsername = user -> user.getUsername().getValue();
Function<User, String> getUsername = User::getUsername;  // ‚úÖ (luego Username::getValue)

// 3. M√©todo de objeto espec√≠fico
Consumer<String> print = str -> System.out.println(str);
Consumer<String> print = System.out::println;  // ‚úÖ

// 4. Constructor
Supplier<ArrayList<String>> listSupplier = () -> new ArrayList<>();
Supplier<ArrayList<String>> listSupplier = ArrayList::new;  // ‚úÖ
```

### Ejemplos del Proyecto

```java
// En el Service
public List<UserResult> getAllActiveUsers() {
    return userRepository.findAll().stream()
        .filter(User::isEnabled)                    // Method reference
        .map(this::toResult)                        // Method reference a m√©todo de instancia
        .collect(Collectors.toList());
}

private UserResult toResult(User user) {
    return new UserResult(
        user.getId(),
        user.getUsername().getValue(),
        user.getEmail().getValue(),
        user.isEnabled(),
        user.getCreatedAt()
    );
}

// Con lambda inline
public List<String> getActiveUsernames() {
    return userRepository.findAll().stream()
        .filter(user -> user.isEnabled())           // Lambda
        .map(user -> user.getUsername().getValue()) // Lambda
        .collect(Collectors.toList());
}
```

---

## Colecciones - Cu√°ndo usar cada una

### List vs Set vs Map

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    COLECCIONES EN JAVA                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

LIST                    SET                     MAP
- Orden                 - Sin duplicados        - Clave ‚Üí Valor
- Permite duplicados    - Sin orden garantizado - Sin claves duplicadas
- Acceso por √≠ndice     - No tiene √≠ndice       - Acceso por clave

[A, B, C, A]           {A, B, C}               {1‚ÜíA, 2‚ÜíB, 3‚ÜíC}
```

### List - Colecci√≥n Ordenada

```java
// Crear listas
List<String> list1 = new ArrayList<>();         // M√°s com√∫n (r√°pido acceso)
List<String> list2 = new LinkedList<>();        // R√°pido insertar/eliminar
List<String> list3 = List.of("a", "b", "c");   // Inmutable (Java 9+)
List<String> list4 = Arrays.asList("a", "b");   // Tama√±o fijo

// Operaciones
list1.add("elemento");                          // Agregar al final
list1.add(0, "elemento");                       // Agregar en posici√≥n
String item = list1.get(0);                     // Obtener por √≠ndice
list1.remove(0);                                // Eliminar por √≠ndice
list1.remove("elemento");                       // Eliminar por valor
boolean contains = list1.contains("elemento");  // Verificar si existe
int size = list1.size();                        // Tama√±o
list1.clear();                                  // Vaciar
```

**Cu√°ndo usar:**
- ‚úÖ Cuando el orden importa
- ‚úÖ Cuando puedes tener duplicados
- ‚úÖ Cuando necesitas acceso por √≠ndice
- Ejemplos: lista de usuarios, historial, logs

### Set - Colecci√≥n Sin Duplicados

```java
// Crear sets
Set<String> set1 = new HashSet<>();             // M√°s r√°pido, sin orden
Set<String> set2 = new LinkedHashSet<>();       // Mantiene orden de inserci√≥n
Set<String> set3 = new TreeSet<>();             // Ordenado naturalmente
Set<String> set4 = Set.of("a", "b", "c");      // Inmutable (Java 9+)

// Operaciones
set1.add("elemento");                           // Agregar (ignora duplicados)
set1.remove("elemento");                        // Eliminar
boolean contains = set1.contains("elemento");   // Verificar (muy r√°pido O(1))
int size = set1.size();                         // Tama√±o

// Ejemplo: Eliminar duplicados de una lista
List<String> list = Arrays.asList("a", "b", "a", "c");
Set<String> unique = new HashSet<>(list);
System.out.println(unique);  // [a, b, c]
```

**Cu√°ndo usar:**
- ‚úÖ Cuando NO quieres duplicados
- ‚úÖ Cuando necesitas b√∫squeda r√°pida (`contains()`)
- ‚úÖ Cuando el orden no importa (HashSet)
- Ejemplos: IDs √∫nicos, tags, categor√≠as

### Map - Diccionario Clave-Valor

```java
// Crear maps
Map<String, User> map1 = new HashMap<>();       // M√°s com√∫n, sin orden
Map<String, User> map2 = new LinkedHashMap<>(); // Mantiene orden de inserci√≥n
Map<String, User> map3 = new TreeMap<>();       // Ordenado por clave
Map<String, User> map4 = Map.of("k1", v1, "k2", v2);  // Inmutable (Java 9+)

// Operaciones
map1.put("key", user);                          // Agregar/actualizar
User user = map1.get("key");                    // Obtener (null si no existe)
User user = map1.getOrDefault("key", defaultUser);  // Con valor por defecto
map1.remove("key");                             // Eliminar
boolean hasKey = map1.containsKey("key");       // Verificar clave
boolean hasValue = map1.containsValue(user);    // Verificar valor
int size = map1.size();                         // Tama√±o

// Iterar sobre Map
for (Map.Entry<String, User> entry : map1.entrySet()) {
    String key = entry.getKey();
    User value = entry.getValue();
}

// Con Streams
map1.forEach((key, value) -> System.out.println(key + ": " + value));
```

**Cu√°ndo usar:**
- ‚úÖ Cuando necesitas buscar por clave
- ‚úÖ Cuando tienes pares clave-valor
- ‚úÖ Como cach√© (ID ‚Üí Objeto)
- Ejemplos: usuarios por ID, configuraciones, cach√©

### Tabla de Decisi√≥n

| Necesitas | Usa |
|-----------|-----|
| Orden + Duplicados | `ArrayList<T>` |
| Sin duplicados + B√∫squeda r√°pida | `HashSet<T>` |
| Sin duplicados + Orden | `LinkedHashSet<T>` |
| Buscar por clave | `HashMap<K, V>` |
| Muchas inserciones/eliminaciones | `LinkedList<T>` |
| Ordenaci√≥n natural | `TreeSet<T>` o `TreeMap<K, V>` |

### Colecciones Inmutables (Java 9+)

```java
// ‚úÖ INMUTABLES (no se pueden modificar)
List<String> list = List.of("a", "b", "c");
Set<String> set = Set.of("a", "b", "c");
Map<String, Integer> map = Map.of("a", 1, "b", 2);

// Intentar modificar lanza UnsupportedOperationException
list.add("d");  // ‚ùå Error en tiempo de ejecuci√≥n

// Para versiones antiguas de Java
List<String> list = Collections.unmodifiableList(Arrays.asList("a", "b", "c"));
```

### Ejemplo del Proyecto

```java
// En el Repository Adapter
public class JpaUserRepositoryAdapter implements UserRepository {

    // Map como cach√©
    private final Map<UUID, User> cache = new HashMap<>();

    @Override
    public Optional<User> findById(UUID id) {
        // Buscar en cach√© primero (Map es r√°pido)
        if (cache.containsKey(id)) {
            return Optional.of(cache.get(id));
        }

        // Si no est√° en cach√©, buscar en BD
        return springDataRepo.findById(id)
            .map(mapper::toDomain)
            .map(user -> {
                cache.put(id, user);  // Guardar en cach√©
                return user;
            });
    }
}

// En el Service
public Set<String> getUniqueEmails() {
    // Set para eliminar duplicados autom√°ticamente
    return userRepository.findAll().stream()
        .map(user -> user.getEmail().getValue())
        .collect(Collectors.toSet());  // ‚Üê Set, no List
}
```

---

## Records - DTOs Inmutables

### ¬øQu√© son los Records? (Java 14+)

Los **Records** son clases especiales para crear DTOs inmutables con menos c√≥digo.

### Antes de Records

```java
// ‚ùå VIEJO: Clase con boilerplate
public final class UserResult {
    private final UUID id;
    private final String username;
    private final String email;

    public UserResult(UUID id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    public UUID getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }

    @Override
    public boolean equals(Object o) { /* ... */ }

    @Override
    public int hashCode() { /* ... */ }

    @Override
    public String toString() { /* ... */ }
}
```

**50 l√≠neas de c√≥digo!** üòµ

### Con Records

```java
// ‚úÖ MODERNO: Record (equivalente al anterior)
public record UserResult(
    UUID id,
    String username,
    String email
) {}
```

**4 l√≠neas!** üéâ

**El compilador genera autom√°ticamente:**
- Constructor
- Getters (sin `get` prefix: `id()`, `username()`, `email()`)
- `equals()` y `hashCode()`
- `toString()`

### Usar Records

```java
// Crear
UserResult result = new UserResult(id, "john", "john@ex.com");

// Acceder (sin "get")
UUID id = result.id();
String username = result.username();
String email = result.email();

// toString autom√°tico
System.out.println(result);
// UserResult[id=..., username=john, email=john@ex.com]

// equals por valor
UserResult r1 = new UserResult(id, "john", "john@ex.com");
UserResult r2 = new UserResult(id, "john", "john@ex.com");
r1.equals(r2);  // true
```

### Records con M√©todos

```java
public record UserResult(
    UUID id,
    String username,
    String email
) {
    // Validaci√≥n en el constructor
    public UserResult {  // Constructor compacto
        if (username == null || username.isBlank()) {
            throw new IllegalArgumentException("Username cannot be blank");
        }
    }

    // M√©todos adicionales
    public String getDisplayName() {
        return username + " (" + email + ")";
    }

    // M√©todo est√°tico
    public static UserResult from(User user) {
        return new UserResult(
            user.getId(),
            user.getUsername().getValue(),
            user.getEmail().getValue()
        );
    }
}
```

### Cu√°ndo usar Records

| Situaci√≥n | Usar Record |
|-----------|-------------|
| ‚úÖ DTOs inmutables | `CreateUserCommand`, `UserResult`, `UserResponse` |
| ‚úÖ Value Objects simples | `Coordinates(lat, lon)`, `Money(amount, currency)` |
| ‚úÖ Resultados de queries | `UserStats(count, avgAge)` |
| ‚ùå Entities con comportamiento | `User` (mejor clase normal) |
| ‚ùå Clases mutables | Necesitas setters (usar clase normal) |

### Ejemplos del Proyecto

```java
// Command
public record CreateUserCommand(String username, String email) {}

// Result
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Event
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}

// REST DTO
public record CreateUserRequest(String username, String email) {}
public record UserResponse(
    String id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

---

## Inmutabilidad

### ¬øQu√© es Inmutabilidad?

Un objeto **inmutable** NO puede cambiar despu√©s de crearse.

### Por qu√© es Importante

```java
// ‚ùå MUTABLE (peligroso)
public class User {
    private String username;

    public void setUsername(String username) {
        this.username = username;
    }
}

// Problema: Cambios inesperados
User user = new User("john");
processUser(user);  // ¬øCambi√≥ el username?
System.out.println(user.getUsername());  // ¬øQu√© imprime?

void processUser(User user) {
    user.setUsername("modified");  // üí• Efecto secundario!
}
```

```java
// ‚úÖ INMUTABLE (seguro)
public final class User {
    private final String username;

    public User(String username) {
        this.username = username;
    }

    // Sin setters

    // Para "cambiar", crear uno nuevo
    public User withUsername(String newUsername) {
        return new User(newUsername);
    }
}

// Uso seguro
User user = new User("john");
User modified = user.withUsername("johnny");
// user sigue siendo "john" ‚úÖ
// modified es "johnny" ‚úÖ
```

### Crear Clases Inmutables

```java
// Checklist para inmutabilidad:
public final class Email {  // 1. Clase final (no heredable)

    private final String value;  // 2. Campos final (no cambian)

    // 3. Sin setters
    // public void setValue(String value) { }  ‚ùå NO

    // 4. Constructor que inicializa todo
    public Email(String value) {
        this.value = value;
    }

    // 5. Solo getters
    public String getValue() {
        return value;
    }

    // 6. Para "modificar", crear nuevo objeto
    public Email withDomain(String newDomain) {
        String[] parts = value.split("@");
        return new Email(parts[0] + "@" + newDomain);
    }
}
```

### Inmutabilidad con Colecciones

```java
// ‚ùå MUTABLE: La lista puede cambiar
public class Order {
    private final List<Item> items;

    public Order(List<Item> items) {
        this.items = items;  // ¬°Referencia a lista mutable!
    }

    public List<Item> getItems() {
        return items;  // ¬°Expone lista mutable!
    }
}

// Problema:
Order order = new Order(items);
order.getItems().add(newItem);  // üí• Modific√≥ el Order!

// ‚úÖ INMUTABLE: Copias defensivas
public class Order {
    private final List<Item> items;

    public Order(List<Item> items) {
        this.items = new ArrayList<>(items);  // Copia defensiva
    }

    public List<Item> getItems() {
        return List.copyOf(items);  // Copia inmutable
        // o: Collections.unmodifiableList(items);
    }
}
```

### Beneficios de la Inmutabilidad

1. **Thread-safe**: No hay race conditions
2. **Predecible**: El objeto no cambia inesperadamente
3. **Cacheable**: Puedes guardar referencias sin preocuparte
4. **Testeable**: F√°cil de probar (sin estado mutable)

---

## var - Inferencia de Tipos (Java 10+)

### ¬øQu√© es var?

`var` permite al compilador **inferir el tipo** autom√°ticamente.

### Uso B√°sico

```java
// Sin var (verboso)
List<String> names = new ArrayList<String>();
Map<UUID, User> userMap = new HashMap<UUID, User>();
UserResult result = new UserResult(id, username, email);

// Con var (conciso)
var names = new ArrayList<String>();
var userMap = new HashMap<UUID, User>();
var result = new UserResult(id, username, email);
```

### Cu√°ndo usar var

```java
// ‚úÖ Cuando el tipo es obvio
var user = new User("john", "john@ex.com");  // Obvio que es User
var users = userRepository.findAll();        // Obvio que es List<User>
var request = new CreateUserRequest("john", "john@ex.com");

// ‚úÖ Con tipos complejos/gen√©ricos
var map = new HashMap<UUID, Map<String, List<Order>>>();  // Evita repetir el tipo

// ‚ùå NO cuando el tipo no es claro
var result = process();  // ¬øQu√© devuelve process()?
var value = getValue();  // ¬øString? Integer? Object?

// ‚úÖ Mejor con tipo expl√≠cito cuando no es obvio
String result = process();
int value = getValue();
```

### Restricciones de var

```java
// ‚ùå NO se puede usar en:
var x;  // Sin inicializaci√≥n
var y = null;  // Sin tipo inferible
private var field;  // Campos de clase
public var method() { }  // Tipo de retorno
var lambda = x -> x * 2;  // Lambdas sin contexto
```

### Ejemplo del Proyecto

```java
// En el Service
public UserResult execute(CreateUserCommand command) {
    // ‚úÖ var cuando el tipo es obvio
    var username = Username.of(command.username());
    var email = Email.of(command.email());
    var user = User.create(command.username(), command.email());
    var savedUser = userRepository.save(user);
    var event = UserCreatedEvent.from(savedUser.getId(), ...);

    // ‚úÖ var en bucles
    for (var user : users) {
        System.out.println(user.getUsername());
    }

    return new UserResult(...);
}
```

---

## Try-with-Resources

### El Problema con Recursos

```java
// ‚ùå VIEJO: Cerrar manualmente (propenso a errores)
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    // usar fis
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        try {
            fis.close();  // Puede fallar!
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Try-with-Resources

```java
// ‚úÖ MODERNO: Cierra autom√°ticamente
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // usar fis
} catch (IOException e) {
    e.printStackTrace();
}  // fis se cierra autom√°ticamente, incluso si hay excepci√≥n
```

### M√∫ltiples Recursos

```java
// ‚úÖ M√∫ltiples recursos
try (
    var input = new FileInputStream("input.txt");
    var output = new FileOutputStream("output.txt");
    var reader = new BufferedReader(new InputStreamReader(input))
) {
    // usar input, output, reader
}  // Todos se cierran autom√°ticamente en orden inverso
```

### Recursos Personalizados

Cualquier clase que implemente `AutoCloseable` puede usarse:

```java
public class DatabaseConnection implements AutoCloseable {
    public void open() {
        // abrir conexi√≥n
    }

    @Override
    public void close() {
        // cerrar conexi√≥n (llamado autom√°ticamente)
    }
}

// Uso
try (var conn = new DatabaseConnection()) {
    conn.open();
    // usar conexi√≥n
}  // conn.close() llamado autom√°ticamente
```

---

## Switch Expressions (Java 14+)

### Switch Tradicional vs Switch Expression

```java
// ‚ùå VIEJO: Switch statement (verboso)
String message;
switch (status) {
    case ACTIVE:
        message = "Usuario activo";
        break;
    case DISABLED:
        message = "Usuario deshabilitado";
        break;
    case PENDING:
        message = "Usuario pendiente";
        break;
    default:
        message = "Estado desconocido";
        break;
}

// ‚úÖ MODERNO: Switch expression (conciso)
var message = switch (status) {
    case ACTIVE -> "Usuario activo";
    case DISABLED -> "Usuario deshabilitado";
    case PENDING -> "Usuario pendiente";
    default -> "Estado desconocido";
};  // Devuelve un valor!
```

### M√∫ltiples Casos

```java
var dayType = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "D√≠a laboral";
    case SATURDAY, SUNDAY -> "Fin de semana";
};
```

### Con Bloques

```java
var result = switch (value) {
    case 1 -> "Uno";
    case 2 -> {
        System.out.println("Es dos");
        yield "Dos";  // yield en lugar de return
    }
    case 3 -> "Tres";
    default -> "Otro";
};
```

### Pattern Matching (Java 17+)

```java
// Verificar tipo y castear en un paso
var description = switch (obj) {
    case String s -> "String de longitud " + s.length();
    case Integer i -> "Entero: " + i;
    case List list -> "Lista con " + list.size() + " elementos";
    case null -> "Es null";
    default -> "Tipo desconocido";
};
```

---

## Resumen: Cu√°ndo Usar Qu√©

| Necesitas | Usa |
|-----------|-----|
| Evitar nulls | `Optional<T>` |
| Procesar colecci√≥n | `Stream` + `filter/map/collect` |
| Funci√≥n an√≥nima | Lambda `x -> x * 2` |
| DTO inmutable | `record` |
| Lista ordenada | `ArrayList<T>` |
| Sin duplicados | `HashSet<T>` o `Set.of()` |
| B√∫squeda por clave | `HashMap<K, V>` |
| Tipo obvio | `var` |
| Cerrar recursos | `try-with-resources` |
| Switch con valor | Switch expression |
| Inmutabilidad | `final` fields + no setters |

---

## Checklist de Buenas Pr√°cticas

### ‚úÖ DO (Hacer)

- Usar Optional para valores que pueden no existir
- Usar Streams para procesar colecciones
- Usar Lambdas para c√≥digo conciso
- Usar Records para DTOs
- Usar colecciones inmutables cuando sea posible
- Usar var cuando el tipo es obvio
- Usar try-with-resources para recursos
- Preferir inmutabilidad

### ‚ùå DON'T (No Hacer)

- NO llamar `Optional.get()` sin verificar
- NO modificar colecciones durante iteraci√≥n
- NO usar Streams para operaciones simples
- NO usar Optional como par√°metro de m√©todo
- NO exponer colecciones mutables
- NO usar var cuando el tipo no es claro
- NO olvidar cerrar recursos
- NO hacer clases mutables sin raz√≥n

---

## Recursos para Seguir Aprendiendo

1. **Documentaci√≥n Oficial:** [Java SE Documentation](https://docs.oracle.com/en/java/)
2. **Modern Java in Action** - Libro sobre Java 8+
3. **Effective Java** - Joshua Bloch (mejores pr√°cticas)
4. **Java Brains** - Canal de YouTube con tutoriales

---

**¬°Usa estas features modernas para escribir c√≥digo m√°s limpio, seguro y conciso!** üöÄ
