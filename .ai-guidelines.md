# AI Guidelines - Hexagonal Architecture Project

> **PROPÃ“SITO:** Este archivo contiene las reglas arquitecturales, patrones y convenciones que DEBES seguir cuando generes, modifiques o sugieras cÃ³digo para este proyecto. Lee este archivo completo antes de hacer cualquier cambio.

---

## ğŸ“‹ Tabla de Contenidos

1. [Arquitectura General](#arquitectura-general)
2. [Reglas de Dependencias](#reglas-de-dependencias)
3. [Estructura de Directorios](#estructura-de-directorios)
4. [Nomenclatura Obligatoria](#nomenclatura-obligatoria)
5. [Patrones de ImplementaciÃ³n](#patrones-de-implementaciÃ³n)
6. [TecnologÃ­as y Frameworks](#tecnologÃ­as-y-frameworks)
7. [Testing](#testing)
8. [Checklist de ValidaciÃ³n](#checklist-de-validaciÃ³n)
9. [Observabilidad: Logs, MÃ©tricas y Trazas](#9-observabilidad-logs-mÃ©tricas-y-trazas)
10. [Spring Security + JWT Authentication & Authorization](#10-spring-security--jwt-authentication--authorization)

---

## Arquitectura General

### Paradigma: Hexagonal Architecture (Ports & Adapters) + DDD + CQRS ligero

Este proyecto sigue una arquitectura hexagonal estricta con 3 capas claramente separadas:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INFRASTRUCTURE                        â”‚
â”‚  (Spring, JPA, REST, Kafka, etc.)                        â”‚
â”‚  - Adapters (input: REST, output: JPA, Events)          â”‚
â”‚  - DTOs: Request, Response, Entity                       â”‚
â”‚  - Mappers: MapStruct                                    â”‚
â”‚  - Configuration: Spring Beans, Exception Handlers       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ depends on (implements ports)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    APPLICATION                           â”‚
â”‚  (Use Cases, Orchestration)                              â”‚
â”‚  - Ports: Input (UseCases), Output (Repositories)       â”‚
â”‚  - Services: Implement UseCases                          â”‚
â”‚  - DTOs: Command, Query, Result                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ depends on (uses domain)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       DOMAIN                             â”‚
â”‚  (Business Logic, Pure Java + Lombok)                    â”‚
â”‚  - Model: Aggregates, Entities, Value Objects           â”‚
â”‚  - Events: Domain Events (records)                       â”‚
â”‚  - Exceptions: Domain Exceptions                         â”‚
â”‚  - NO FRAMEWORKS (solo Lombok para reducir boilerplate) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Reglas de Dependencias

### ğŸš« PROHIBIDO (Dependency Rule Violations)

1. âŒ **Domain NO PUEDE depender de Application o Infrastructure**
   - âŒ No imports de Spring en Domain
   - âŒ No imports de JPA (@Entity) en Domain
   - âŒ No imports de Jackson en Domain
   - âœ… Solo: Java core, Lombok, y otros paquetes del Domain

2. âŒ **Application NO PUEDE depender de Infrastructure**
   - âŒ No imports de Controllers en Application
   - âŒ No imports de JPA Entities en Application
   - âŒ No imports de implementaciones concretas (adapters)
   - âœ… Solo: Domain, interfaces propias (ports), y Spring bÃ¡sico (@Service, @Transactional)

3. âŒ **Controllers NO PUEDEN llamar a Repositories directamente**
   - âŒ Controller â†’ Repository (bypass de Application layer)
   - âœ… Controller â†’ UseCase â†’ Repository

### âœ… PERMITIDO (Correct Dependencies)

```
Infrastructure â†’ Application âœ…
Infrastructure â†’ Domain     âœ…
Application    â†’ Domain     âœ…
```

---

## Estructura de Directorios

### Template de Carpetas (RESPETAR ESTRICTAMENTE)

```
src/main/java/com/example/hexarch/
â”‚
â”œâ”€â”€ {bounded-context}/              # ej: user, order, payment
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                     # CAPA 1: DOMINIO
â”‚   â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”‚   â”œâ”€â”€ {Aggregate}.java           # ej: User.java
â”‚   â”‚   â”‚   â””â”€â”€ valueobject/
â”‚   â”‚   â”‚       â”œâ”€â”€ {ValueObject}.java     # ej: Email.java, Username.java
â”‚   â”‚   â”œâ”€â”€ event/
â”‚   â”‚   â”‚   â””â”€â”€ {Entity}{Action}Event.java # ej: UserCreatedEvent.java
â”‚   â”‚   â””â”€â”€ exception/
â”‚   â”‚       â”œâ”€â”€ DomainException.java
â”‚   â”‚       â”œâ”€â”€ ValidationException.java
â”‚   â”‚       â””â”€â”€ {Entity}AlreadyExistsException.java
â”‚   â”‚
â”‚   â”œâ”€â”€ application/                # CAPA 2: APLICACIÃ“N
â”‚   â”‚   â”œâ”€â”€ port/
â”‚   â”‚   â”‚   â”œâ”€â”€ input/              # LO QUE LA APP OFRECE
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ {Action}{Entity}UseCase.java    # ej: CreateUserUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ {Action}{Entity}Command.java    # ej: CreateUserCommand.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Get{Entity}Query.java           # ej: GetUserQuery.java (CQRS)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {Entity}Result.java             # ej: UserResult.java
â”‚   â”‚   â”‚   â””â”€â”€ output/             # LO QUE LA APP NECESITA
â”‚   â”‚   â”‚       â”œâ”€â”€ {Entity}Repository.java         # ej: UserRepository.java
â”‚   â”‚   â”‚       â””â”€â”€ {Entity}EventPublisher.java     # ej: UserEventPublisher.java
â”‚   â”‚   â””â”€â”€ service/
â”‚   â”‚       â”œâ”€â”€ {Action}{Entity}Service.java        # ej: CreateUserService.java
â”‚   â”‚       â””â”€â”€ Get{Entity}QueryHandler.java        # ej: GetUserQueryHandler.java (CQRS)
â”‚   â”‚
â”‚   â””â”€â”€ infrastructure/             # CAPA 3: INFRAESTRUCTURA
â”‚       â””â”€â”€ adapter/
â”‚           â”œâ”€â”€ input/              # ADAPTADORES DE ENTRADA
â”‚           â”‚   â””â”€â”€ rest/
â”‚           â”‚       â”œâ”€â”€ {Entity}Controller.java     # ej: UserController.java
â”‚           â”‚       â”œâ”€â”€ dto/
â”‚           â”‚       â”‚   â”œâ”€â”€ {Action}{Entity}Request.java   # ej: CreateUserRequest.java
â”‚           â”‚       â”‚   â””â”€â”€ {Entity}Response.java          # ej: UserResponse.java
â”‚           â”‚       â””â”€â”€ mapper/
â”‚           â”‚           â””â”€â”€ {Entity}RestMapper.java        # ej: UserRestMapper.java
â”‚           â””â”€â”€ output/             # ADAPTADORES DE SALIDA
â”‚               â”œâ”€â”€ persistence/
â”‚               â”‚   â”œâ”€â”€ Jpa{Entity}RepositoryAdapter.java  # ej: JpaUserRepositoryAdapter.java
â”‚               â”‚   â”œâ”€â”€ {Entity}Entity.java                # ej: UserEntity.java
â”‚               â”‚   â”œâ”€â”€ SpringData{Entity}Repository.java  # ej: SpringDataUserRepository.java
â”‚               â”‚   â””â”€â”€ mapper/
â”‚               â”‚       â””â”€â”€ {Entity}EntityMapper.java      # ej: UserEntityMapper.java
â”‚               â””â”€â”€ event/
â”‚                   â””â”€â”€ {Technology}{Entity}EventPublisherAdapter.java  # ej: KafkaUserEventPublisherAdapter.java
â”‚
â””â”€â”€ shared/                         # CÃ“DIGO COMPARTIDO
    â””â”€â”€ infrastructure/
        â””â”€â”€ exception/
            â”œâ”€â”€ GlobalExceptionHandler.java
            â””â”€â”€ ErrorResponse.java
```

### Reglas de UbicaciÃ³n

1. **Bounded Contexts**: Cada mÃ³dulo de negocio (user, order, payment) tiene su propia carpeta raÃ­z
2. **NO mezclar capas**: Cada archivo va EXACTAMENTE en su carpeta correspondiente
3. **NO crear subcarpetas adicionales** sin justificaciÃ³n arquitectural
4. **Shared solo para infraestructura comÃºn** (exception handling, config, etc.)

---

## Nomenclatura Obligatoria

### Tabla de Nomenclatura (SEGUIR AL PIE DE LA LETRA)

| Capa | Tipo | PatrÃ³n | Ejemplo | UbicaciÃ³n |
|------|------|--------|---------|-----------|
| **Application (Input)** | Use Case Interface | `{Action}{Entity}UseCase` | `CreateUserUseCase` | `application/port/input/` |
| **Application (Input)** | Command | `{Action}{Entity}Command` | `CreateUserCommand` | `application/port/input/` |
| **Application (Input)** | Query | `Get{Entity}Query` | `GetUserQuery` | `application/port/input/` |
| **Application (Input)** | Result | `{Entity}Result` | `UserResult` | `application/port/input/` |
| **Application (Output)** | Repository Interface | `{Entity}Repository` | `UserRepository` | `application/port/output/` |
| **Application (Output)** | Event Publisher Interface | `{Entity}EventPublisher` | `UserEventPublisher` | `application/port/output/` |
| **Application (Service)** | Service Implementation | `{Action}{Entity}Service` | `CreateUserService` | `application/service/` |
| **Application (Service)** | Query Handler | `Get{Entity}QueryHandler` | `GetUserQueryHandler` | `application/service/` |
| **Domain** | Aggregate Root | `{Entity}` | `User` | `domain/model/` |
| **Domain** | Value Object | `{Concept}` | `Email`, `Username` | `domain/model/valueobject/` |
| **Domain** | Domain Event | `{Entity}{Action}Event` | `UserCreatedEvent` | `domain/event/` |
| **Domain** | Domain Exception | `{Entity}{Reason}Exception` | `UserAlreadyExistsException` | `domain/exception/` |
| **Infrastructure (Input)** | Controller | `{Entity}Controller` | `UserController` | `infrastructure/adapter/input/rest/` |
| **Infrastructure (Input)** | Request DTO | `{Action}{Entity}Request` | `CreateUserRequest` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | Response DTO | `{Entity}Response` | `UserResponse` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | REST Mapper | `{Entity}RestMapper` | `UserRestMapper` | `infrastructure/adapter/input/rest/mapper/` |
| **Infrastructure (Output)** | JPA Entity | `{Entity}Entity` | `UserEntity` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Repository Adapter | `Jpa{Entity}RepositoryAdapter` | `JpaUserRepositoryAdapter` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Spring Data Repo | `SpringData{Entity}Repository` | `SpringDataUserRepository` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Entity Mapper | `{Entity}EntityMapper` | `UserEntityMapper` | `infrastructure/adapter/output/persistence/mapper/` |
| **Infrastructure (Output)** | Event Publisher Adapter | `{Tech}{Entity}EventPublisherAdapter` | `KafkaUserEventPublisherAdapter` | `infrastructure/adapter/output/event/` |

### Reglas de Naming

1. **PascalCase** para nombres de clases: `CreateUserService`
2. **camelCase** para mÃ©todos y variables: `createUser()`, `userResult`
3. **UPPER_SNAKE_CASE** para constantes: `MAX_USERNAME_LENGTH`
4. **Verbos para mÃ©todos**: `create()`, `save()`, `find()`, `execute()`
5. **Sustantivos para clases**: `User`, `Email`, `UserController`

---

## Patrones de ImplementaciÃ³n

### 1. Domain Layer (Aggregate Roots, Entities)

**SIEMPRE seguir este patrÃ³n:**

```java
package com.example.hexarch.user.domain.model;

import com.example.hexarch.user.domain.model.valueobject.Email;
import com.example.hexarch.user.domain.model.valueobject.Username;
import lombok.*;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Aggregate Root
 *
 * REGLAS:
 * - Inmutable (final fields, sin setters)
 * - Factory methods: create() para nuevo, reconstitute() para existente
 * - MÃ©todos de negocio devuelven nueva instancia
 * - Usa Value Objects (no primitivos)
 * - Sin anotaciones de frameworks (solo Lombok)
 */
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class User {

    @EqualsAndHashCode.Include
    private final UUID id;
    private final Username username;  // Value Object
    private final Email email;        // Value Object
    private final boolean enabled;
    private final Instant createdAt;  // SIEMPRE Instant (no LocalDateTime)

    /**
     * Factory Method - Crear nuevo
     */
    public static User create(String username, String email) {
        return new User(
            UUID.randomUUID(),
            Username.of(username),
            Email.of(email),
            true,
            Instant.now()
        );
    }

    /**
     * Factory Method - Reconstruir existente
     */
    public static User reconstitute(UUID id, String username, String email,
                                     boolean enabled, Instant createdAt) {
        return new User(
            id,
            Username.of(username),
            Email.of(email),
            enabled,
            createdAt
        );
    }

    /**
     * MÃ©todo de negocio - Devuelve nueva instancia (inmutabilidad)
     */
    public User disable() {
        return new User(this.id, this.username, this.email, false, this.createdAt);
    }
}
```

**CHECKLIST Domain:**
- [ ] Clase con Lombok: `@Getter`, `@EqualsAndHashCode(onlyExplicitlyIncluded = true)`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Campos `final`
- [ ] Sin setters pÃºblicos
- [ ] Factory method `create()` para nuevos
- [ ] Factory method `reconstitute()` para existentes
- [ ] MÃ©todos de negocio devuelven nueva instancia
- [ ] Usa Value Objects (no String/int directos)
- [ ] Usa `Instant` para timestamps (NO `LocalDateTime`)
- [ ] `equals/hashCode` solo en el ID (agregar `@EqualsAndHashCode.Include` al ID)

---

### 2. Value Objects

**RECOMENDADO: Usar Records (Java 21) con Compact Constructor**

```java
package com.example.hexarch.user.domain.model.valueobject;

import com.example.hexarch.user.domain.exception.ValidationException;

/**
 * DOMAIN LAYER - Value Object (Java 21 Record)
 *
 * REGLAS:
 * - Inmutable (record garantiza inmutabilidad)
 * - Auto-valida en compact constructor
 * - Factory method: of(String) (opcional, para compatibilidad)
 * - Equals/hashCode/toString automÃ¡ticos
 */
public record Email(String value) {

    /**
     * Compact Constructor - Valida antes de asignar
     */
    public Email {
        validate(value);
    }

    /**
     * Factory Method - Alternativa explÃ­cita al constructor
     */
    public static Email of(String value) {
        return new Email(value);
    }

    private static void validate(String value) {
        if (value == null || value.isBlank()) {
            throw new ValidationException("Email no puede estar vacÃ­o", "EMAIL_001");
        }
        if (!value.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new ValidationException("Formato de email invÃ¡lido", "EMAIL_002");
        }
    }

    /**
     * MÃ©todo getValue() para compatibilidad con cÃ³digo legacy
     */
    public String getValue() {
        return value;
    }
}
```

**ALTERNATIVA: Clase tradicional con Lombok (para casos complejos)**

Si el Value Object necesita lÃ³gica compleja o mÃºltiples campos, usa clase:

```java
@Getter
@EqualsAndHashCode
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class ComplexValueObject {
    private final String field1;
    private final int field2;

    public static ComplexValueObject of(String field1, int field2) {
        validate(field1, field2);
        return new ComplexValueObject(field1, field2);
    }
}
```

**CHECKLIST Value Object:**
- [ ] **Record (preferido)**: Compact constructor con validaciÃ³n
- [ ] **Clase (alternativa)**: `final` class, campos `final`, sin setters
- [ ] Factory method `of(...)` que valida
- [ ] ValidaciÃ³n en mÃ©todo privado `validate()`
- [ ] Lanza `ValidationException` con cÃ³digo y mensaje
- [ ] MÃ©todo `getValue()` para compatibilidad (si es necesario)

---

### 3. Domain Events

**SIEMPRE usar records:**

```java
package com.example.hexarch.user.domain.event;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Domain Event
 *
 * REGLAS:
 * - Siempre record (inmutable)
 * - Nombrado en PASADO: {Entity}{Action}Event
 * - Contiene Instant occurredAt
 * - Factory method: from()
 */
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}
```

**CHECKLIST Domain Event:**
- [ ] Es un `record`
- [ ] Nombrado en pasado: `{Entity}{Action}Event`
- [ ] Tiene campo `Instant occurredAt`
- [ ] Factory method `from()` que genera `occurredAt`

---

### 4. Application Layer (Use Cases)

**PatrÃ³n Interface + Implementation:**

```java
// Interface (Input Port)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Input Port (Use Case)
 *
 * REGLAS:
 * - Interface pura
 * - MÃ©todo execute() con Command/Query
 * - Retorna Result
 */
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Command (DTO)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Command (CQRS Write)
 *
 * REGLAS:
 * - Siempre record
 * - Solo datos primitivos o inmutables
 * - Sin lÃ³gica
 */
public record CreateUserCommand(String username, String email) {}

// Result (DTO)
package com.example.hexarch.user.application.port.input;

import java.time.Instant;
import java.util.UUID;

/**
 * APPLICATION LAYER - Result
 *
 * REGLAS:
 * - Siempre record
 * - Datos primitivos o Instant (NO Value Objects)
 */
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Service (Implementation)
package com.example.hexarch.user.application.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * APPLICATION LAYER - Service (Use Case Implementation)
 *
 * REGLAS:
 * - Implementa UseCase interface
 * - @Service + @Transactional
 * - Constructor injection (no @Autowired)
 * - Orquesta dominio y output ports
 */
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // Constructor injection (preferido)
    public CreateUserService(UserRepository userRepository,
                             UserEventPublisher userEventPublisher) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 1. Validar precondiciones
        if (userRepository.existsByUsername(command.username())) {
            throw new UserAlreadyExistsException(command.username());
        }

        // 2. Crear dominio
        User user = User.create(command.username(), command.email());

        // 3. Persistir
        User savedUser = userRepository.save(user);

        // 4. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 5. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

**CHECKLIST Application Service:**
- [ ] Implementa UseCase interface
- [ ] Anotado con `@Service` y `@Transactional`
- [ ] Constructor injection (NO `@Autowired` en campos)
- [ ] Flujo: validar â†’ crear dominio â†’ persistir â†’ publicar evento â†’ retornar
- [ ] Extrae valores de Value Objects antes de retornar (`.getValue()`)

---

#### âš ï¸ IMPORTANTE: Â¿CuÃ¡ndo usar Interface (UseCase) vs Service sin interface?

**Esta es una pregunta frecuente y crÃ­tica en arquitectura hexagonal.**

##### UseCase = Interface + Service (Input Ports)

**CuÃ¡ndo SÃ usar interface:**
- âœ… **Puntos de entrada a la aplicaciÃ³n** (Input Ports)
- âœ… Casos de uso que el exterior invoca (Controllers, CLI, etc.)
- âœ… Operaciones de negocio principales (Commands/Queries CQRS)
- âœ… Cuando necesitas **inversiÃ³n de dependencias**

**Ejemplo:**
```java
// Interface - Input Port (lo que la aplicaciÃ³n OFRECE)
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Service - ImplementaciÃ³n
@Service
public class CreateUserService implements CreateUserUseCase {
    // ImplementaciÃ³n...
}

// Controller - Depende de la interfaz (no de la implementaciÃ³n)
@RestController
public class UserController {
    private final CreateUserUseCase createUserUseCase;  // â† Interface
}
```

**RazÃ³n:**
1. **InversiÃ³n de dependencias**: Infrastructure depende de abstracciÃ³n (interface), no de implementaciÃ³n
2. **Testabilidad**: Controllers pueden usar mocks de la interface
3. **Port explÃ­cito**: La interface documenta claramente "quÃ© ofrece la aplicaciÃ³n"
4. **Flexibilidad**: Puedes cambiar la implementaciÃ³n sin afectar el Controller

##### Service SIN interface (Servicios internos)

**CuÃ¡ndo NO usar interface:**
- âœ… **Servicios de aplicaciÃ³n internos** (no son Input Ports)
- âœ… Servicios que solo otros componentes de Application/Infrastructure invocan
- âœ… Servicios tÃ©cnicos (email, notificaciones, caching)
- âœ… Cuando NO necesitas inversiÃ³n de dependencias

**Ejemplo:**
```java
// Service directo - NO es un Input Port
@Service
public class EmailService {
    @CircuitBreaker(name = "emailService", fallbackMethod = "sendEmailFallback")
    public void sendWelcomeEmail(String email, String username) {
        // Enviar email...
    }
}

// Kafka Consumer - Depende directamente del servicio
@Component
public class UserEventsKafkaConsumer {
    private final EmailService emailService;  // â† Clase directa

    public void consume(UserCreatedEvent event) {
        emailService.sendWelcomeEmail(...);
    }
}
```

**RazÃ³n:**
1. **No es un Input Port**: El Kafka Consumer (Infrastructure) llama a EmailService, pero no es un "punto de entrada" desde el exterior de la aplicaciÃ³n
2. **Simplicidad**: No hay necesidad de abstracciÃ³n adicional
3. **Servicio tÃ©cnico**: EmailService es un detalle de implementaciÃ³n, no lÃ³gica de negocio principal
4. **Sin inversiÃ³n de dependencias necesaria**: El Consumer ya estÃ¡ en Infrastructure, no hay capa externa que dependa de Ã©l

##### Tabla Comparativa

| Aspecto | UseCase (con interface) | Service (sin interface) |
|---------|-------------------------|-------------------------|
| **PropÃ³sito** | Input Port - Punto de entrada | Servicio interno |
| **QuiÃ©n lo invoca** | Controllers (Infrastructure) | Otros services o consumers (Application/Infrastructure) |
| **InversiÃ³n de dependencias** | SÃ - Infrastructure depende de abstracciÃ³n | NO - Dependencia directa |
| **LÃ³gica** | OrquestaciÃ³n de negocio principal | LÃ³gica tÃ©cnica o secundaria |
| **Testabilidad** | Mock de interface | Mock o spy de clase |
| **Ejemplos** | CreateUserUseCase, GetUserQuery | EmailService, CacheService, MetricsService |

##### Regla PrÃ¡ctica

```
Â¿Es un CASO DE USO de negocio invocado desde el exterior (Controller, CLI)?
    SÃ â†’ UseCase interface + Service implementation
    NO â†’ Service directo sin interface

Â¿Es un servicio tÃ©cnico/auxiliar usado internamente?
    SÃ â†’ Service directo sin interface
    NO â†’ Probablemente es un UseCase
```

##### Ejemplo Completo

```
âœ… CreateUserUseCase (interface)
   â†’ Punto de entrada desde UserController
   â†’ Caso de uso de negocio principal
   â†’ Implementado por CreateUserService

âœ… EmailService (clase directa, NO interface)
   â†’ Invocado desde UserEventsKafkaConsumer
   â†’ Servicio tÃ©cnico de notificaciones
   â†’ No es un punto de entrada al negocio

âœ… GetUserQuery (interface)
   â†’ Punto de entrada desde UserController
   â†’ Query CQRS
   â†’ Implementado por GetUserQueryHandler

âœ… CacheService (clase directa, NO interface)
   â†’ Invocado internamente desde varios services
   â†’ Servicio tÃ©cnico de caching
   â†’ Detalle de implementaciÃ³n
```

**ConclusiÃ³n:** NO todo service necesita interface. Solo los **Input Ports** (puntos de entrada al negocio) necesitan abstracciÃ³n para mantener la inversiÃ³n de dependencias de arquitectura hexagonal

---

### 5. Infrastructure Layer (Adapters)

**Controller (Input Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

/**
 * INFRASTRUCTURE LAYER - REST Controller
 *
 * REGLAS:
 * - @RestController + @RequestMapping
 * - Constructor injection
 * - Usa UseCase (NO Repository)
 * - Mapea Request â†” Command y Result â†” Response
 */
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    private final CreateUserUseCase createUserUseCase;
    private final UserRestMapper mapper;

    public UserController(CreateUserUseCase createUserUseCase,
                          UserRestMapper mapper) {
        this.createUserUseCase = createUserUseCase;
        this.mapper = mapper;
    }

    @PostMapping
    public ResponseEntity<UserResponse> createUser(
        @Valid @RequestBody CreateUserRequest request
    ) {
        // 1. Mapear Request â†’ Command
        CreateUserCommand command = mapper.toCommand(request);

        // 2. Ejecutar UseCase
        UserResult result = createUserUseCase.execute(command);

        // 3. Mapear Result â†’ Response
        UserResponse response = mapper.toResponse(result);

        // 4. Retornar HTTP
        return ResponseEntity.status(201).body(response);
    }
}
```

**Request/Response DTOs (siempre records):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.dto;

import jakarta.validation.constraints.*;

/**
 * INFRASTRUCTURE LAYER - REST Request DTO
 *
 * REGLAS:
 * - Siempre record
 * - Bean Validation: @NotBlank, @Email, @Size, etc.
 */
public record CreateUserRequest(
    @NotBlank(message = "Username no puede estar vacÃ­o")
    @Size(min = 3, max = 50, message = "Username debe tener entre 3 y 50 caracteres")
    String username,

    @NotBlank(message = "Email no puede estar vacÃ­o")
    @Email(message = "Email debe tener formato vÃ¡lido")
    String email
) {}

public record UserResponse(
    String id,           // UUID como String
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

**Repository Adapter (Output Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - Repository Adapter
 *
 * REGLAS:
 * - @Repository
 * - Implementa interface de Application
 * - Constructor injection
 * - Delega a Spring Data Repository
 * - Mapea Entity â†” Domain
 */
@Repository
public class JpaUserRepositoryAdapter implements UserRepository {

    private final SpringDataUserRepository springDataRepo;
    private final UserEntityMapper mapper;

    public JpaUserRepositoryAdapter(SpringDataUserRepository springDataRepo,
                                     UserEntityMapper mapper) {
        this.springDataRepo = springDataRepo;
        this.mapper = mapper;
    }

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        UserEntity savedEntity = springDataRepo.save(entity);
        return mapper.toDomain(savedEntity);
    }

    @Override
    public Optional<User> findById(UUID id) {
        return springDataRepo.findById(id)
            .map(mapper::toDomain);
    }
}
```

**JPA Entity:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import jakarta.persistence.*;
import lombok.*;
import java.time.Instant;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - JPA Entity
 *
 * REGLAS:
 * - @Entity, @Table
 * - Mutable (tiene setters para JPA)
 * - NO es el modelo de dominio
 * - Lombok: @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor
 */
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {

    @Id
    private UUID id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
}
```

---

### 6. Mappers (MapStruct)

**SIEMPRE usar MapStruct:**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.mapper;

import org.mapstruct.*;

/**
 * INFRASTRUCTURE LAYER - REST Mapper
 *
 * REGLAS:
 * - @Mapper(componentModel = "spring")
 * - MÃ©todos: toCommand(), toResponse()
 * - Conversiones de tipos (UUID â†” String)
 */
@Mapper(componentModel = "spring")
public interface UserRestMapper {

    CreateUserCommand toCommand(CreateUserRequest request);

    @Mapping(target = "id", source = "id", qualifiedByName = "uuidToString")
    UserResponse toResponse(UserResult result);

    @Named("uuidToString")
    default String uuidToString(UUID uuid) {
        return uuid != null ? uuid.toString() : null;
    }
}
```

**CHECKLIST Mapper:**
- [ ] Interface (no clase)
- [ ] `@Mapper(componentModel = "spring")`
- [ ] MÃ©todos claros: `toCommand()`, `toResponse()`, `toDomain()`, `toEntity()`
- [ ] Custom mappings con `@Mapping` y `@Named`

---

### 7. Kafka Integration + Circuit Breaker + DLT

**PatrÃ³n: Event-Driven Architecture con Resilience**

Este proyecto implementa comunicaciÃ³n asÃ­ncrona entre microservicios usando Apache Kafka con patrones de resiliencia empresariales.

#### 7.1. Event Publisher Adapter (Output Adapter)

**SIEMPRE seguir este patrÃ³n:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.event;

import com.example.hexarch.user.application.port.output.UserEventPublisher;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

/**
 * INFRASTRUCTURE LAYER - Kafka Event Publisher
 *
 * REGLAS:
 * - @Component (no @Service, es un adapter)
 * - Implementa interface de output port
 * - Usa KafkaTemplate<String, Event>
 * - Key = ID de la entidad (para particionamiento)
 * - Fire-and-forget: no bloquea el flujo principal
 */
@Component
public class KafkaUserEventPublisherAdapter implements UserEventPublisher {

    private static final String TOPIC = "user.created";

    private final KafkaTemplate<String, UserCreatedEvent> kafkaTemplate;

    public KafkaUserEventPublisherAdapter(KafkaTemplate<String, UserCreatedEvent> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @Override
    public void publish(UserCreatedEvent event) {
        kafkaTemplate.send(
            TOPIC,
            event.userId().toString(),  // Key = userId (garantiza orden)
            event
        ).whenComplete((result, ex) -> {
            if (ex != null) {
                log.error("âŒ Failed to publish event to Kafka", ex);
            } else {
                log.info("ğŸ“¤ Published UserCreatedEvent: userId={}", event.userId());
            }
        });
    }
}
```

**CHECKLIST Kafka Publisher:**
- [ ] Implementa output port interface
- [ ] Usa `KafkaTemplate<String, EventType>`
- [ ] Key = ID de entidad (para orden y particionamiento)
- [ ] Logs de Ã©xito/error (no lanza excepciones)
- [ ] Constante para el topic name

#### 7.2. Kafka Consumer (Input Adapter)

**SIEMPRE seguir este patrÃ³n:**

```java
package com.example.hexarch.notifications.infrastructure.kafka.consumer;

import com.example.hexarch.notifications.application.service.EmailService;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;

/**
 * INFRASTRUCTURE LAYER - Kafka Consumer
 *
 * REGLAS:
 * - @Component (no @Service, es un adapter)
 * - @KafkaListener con topic y groupId
 * - Protegido por Circuit Breaker (en el service)
 * - NO propaga excepciones (maneja errores)
 * - Spring Kafka reintenta automÃ¡ticamente
 */
@Component
public class UserEventsKafkaConsumer {

    private final EmailService emailService;  // Con Circuit Breaker

    public UserEventsKafkaConsumer(EmailService emailService) {
        this.emailService = emailService;
    }

    @KafkaListener(
        topics = "user.created",
        groupId = "notifications-service",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(
        @Payload UserCreatedEvent event,
        @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
        @Header(KafkaHeaders.OFFSET) long offset,
        @Header(value = KafkaHeaders.RECEIVED_KEY, required = false) String key
    ) {
        log.info("ğŸ“¥ Consuming UserCreatedEvent: userId={}, partition={}, offset={}",
                 event.userId(), partition, offset);

        try {
            // Llamar a servicio con Circuit Breaker
            emailService.sendWelcomeEmail(event.email(), event.username());
        } catch (Exception ex) {
            // NO propagar: evita enviar a DLT por errores no crÃ­ticos
            log.error("âŒ Error processing event, but won't retry: {}", ex.getMessage());
        }
    }
}
```

**CHECKLIST Kafka Consumer:**
- [ ] `@Component` + `@KafkaListener`
- [ ] Topic y groupId configurados
- [ ] Headers de Kafka (partition, offset, key)
- [ ] Try-catch: NO propaga excepciones crÃ­ticas
- [ ] Llama a services con Circuit Breaker

#### 7.3. Circuit Breaker Pattern (Resilience4j)

**SIEMPRE usar en servicios externos (SMTP, HTTP APIs, etc.):**

```java
package com.example.hexarch.notifications.application.service;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;

/**
 * APPLICATION LAYER - Service con Circuit Breaker
 *
 * REGLAS:
 * - @CircuitBreaker con name y fallbackMethod
 * - Fallback method con misma firma + Throwable
 * - Fallback NO lanza excepciÃ³n (loguea y degrada gracefully)
 * - Estados: CLOSED â†’ OPEN â†’ HALF_OPEN
 */
@Service
public class EmailService {

    @CircuitBreaker(name = "emailService", fallbackMethod = "sendEmailFallback")
    public void sendWelcomeEmail(String email, String username) {
        // Simula llamada a servicio externo (SMTP, API, etc.)
        if (new Random().nextInt(100) > 70) {  // 30% chance de fallo
            throw new RuntimeException("Email service temporarily unavailable");
        }
        log.info("âœ… Email sent to {}", email);
    }

    /**
     * Fallback - Se ejecuta cuando Circuit Breaker estÃ¡ OPEN
     *
     * IMPORTANTE:
     * - Misma firma que mÃ©todo principal + Throwable
     * - NO lanza excepciÃ³n
     * - Loguea warning
     * - Puede encolar para retry manual
     */
    private void sendEmailFallback(String email, String username, Throwable ex) {
        log.warn("âš ï¸ Circuit breaker OPEN - Email not sent to {}: {}",
                 email, ex.getMessage());
        // Opcional: Encolar en sistema de retry o base de datos
    }
}
```

**ConfiguraciÃ³n Circuit Breaker (application.yml):**

```yaml
resilience4j:
  circuitbreaker:
    instances:
      emailService:
        sliding-window-size: 10          # Ventana de 10 llamadas
        minimum-number-of-calls: 5       # MÃ­nimo 5 llamadas para calcular
        failure-rate-threshold: 50       # Si 50% fallan â†’ OPEN
        wait-duration-in-open-state: 10s # Espera 10s antes de HALF_OPEN
        permitted-number-of-calls-in-half-open-state: 3
```

**CHECKLIST Circuit Breaker:**
- [ ] `@CircuitBreaker(name, fallbackMethod)`
- [ ] Fallback con misma firma + Throwable
- [ ] Fallback NO lanza excepciones
- [ ] ConfiguraciÃ³n en application.yml
- [ ] Solo en llamadas a servicios externos

#### 7.4. Dead Letter Topic (DLT) Consumer

**Cuando un mensaje falla N veces, va al DLT automÃ¡ticamente:**

```java
package com.example.hexarch.notifications.infrastructure.kafka.consumer;

import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import java.nio.charset.StandardCharsets;

/**
 * INFRASTRUCTURE LAYER - Dead Letter Topic Consumer
 *
 * REGLAS:
 * - Topic: {original-topic}.dlt
 * - NO reintenta (ya fallÃ³ mÃºltiples veces)
 * - Loguea error para investigaciÃ³n
 * - Extrae headers de error de Kafka
 * - Puede persistir en BD para anÃ¡lisis posterior
 */
@Component
public class UserCreatedEventDLTConsumer {

    @KafkaListener(
        topics = "user.created.dlt",
        groupId = "notifications-service-dlt"
    )
    public void consumeFailedMessage(
        @Payload UserCreatedEvent event,
        ConsumerRecord<String, UserCreatedEvent> record,
        @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
        @Header(KafkaHeaders.OFFSET) long offset,
        @Header(value = KafkaHeaders.RECEIVED_KEY, required = false) String key
    ) {
        // Extraer headers del DLT
        String originalTopic = extractHeader(record, "kafka_dlt-original-topic");
        String exceptionMessage = extractHeader(record, "kafka_dlt-exception-message");
        String stackTrace = extractHeader(record, "kafka_dlt-exception-stacktrace");

        log.error("""
            ğŸ’€ [DLT CONSUMER] Failed message received
            â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            Topic: user.created.dlt
            Partition: {} | Offset: {} | Key: {}
            Event: userId={}, username={}, email={}
            Original Topic: {}
            Exception: {}
            Stack Trace (first 500 chars):
            {}
            â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            """,
            partition, offset, key,
            event.userId(), event.username(), event.email(),
            originalTopic,
            exceptionMessage,
            stackTrace.substring(0, Math.min(500, stackTrace.length()))
        );

        // Opcional: Persistir en BD para anÃ¡lisis
        // dltRepository.save(new FailedMessage(...));
    }

    private String extractHeader(ConsumerRecord<?, ?> record, String headerKey) {
        byte[] headerValue = record.headers().lastHeader(headerKey).value();
        return new String(headerValue, StandardCharsets.UTF_8);
    }
}
```

**Headers que Spring Kafka aÃ±ade al DLT:**
- `kafka_dlt-original-topic`: Topic original
- `kafka_dlt-exception-message`: Mensaje del error
- `kafka_dlt-exception-stacktrace`: Stack trace completo
- `kafka_dlt-original-offset`: Offset original
- `kafka_dlt-original-partition`: ParticiÃ³n original

**CHECKLIST DLT Consumer:**
- [ ] Topic = `{original}.dlt`
- [ ] NO reintenta (es el fin de la lÃ­nea)
- [ ] Extrae y loguea headers de error
- [ ] Opcional: Persiste en BD para anÃ¡lisis
- [ ] GroupId diferente del consumer principal

#### 7.5. Kafka Configuration (KafkaConfig.java)

**ConfiguraciÃ³n de reintentos y DLT:**

```java
@Configuration
public class KafkaConfig {

    @Bean
    public DefaultErrorHandler errorHandler(
        DeadLetterPublishingRecoverer recoverer
    ) {
        // Backoff exponencial: 1s, 2s, 4s
        FixedBackOff backOff = new FixedBackOff(1000L, 3);  // 3 reintentos

        DefaultErrorHandler errorHandler = new DefaultErrorHandler(recoverer, backOff);

        // NO reintentar para errores de deserializaciÃ³n
        errorHandler.addNotRetryableExceptions(
            SerializationException.class,
            DeserializationException.class
        );

        return errorHandler;
    }

    @Bean
    public DeadLetterPublishingRecoverer deadLetterPublishingRecoverer(
        KafkaTemplate<String, Object> kafkaTemplate
    ) {
        return new DeadLetterPublishingRecoverer(
            kafkaTemplate,
            (record, ex) -> new TopicPartition(
                record.topic() + ".dlt",  // AÃ±ade .dlt al topic
                record.partition()
            )
        );
    }
}
```

**CHECKLIST Kafka Config:**
- [ ] `DefaultErrorHandler` con backoff
- [ ] `DeadLetterPublishingRecoverer` para DLT
- [ ] Reintentos limitados (3-5 mÃ¡ximo)
- [ ] Excluir errores no recuperables (deserializaciÃ³n)

---

## TecnologÃ­as y Frameworks

### Versiones Obligatorias

```xml
<properties>
    <java.version>21</java.version>
    <spring-boot.version>3.5.7</spring-boot.version>
    <mapstruct.version>1.6.3</mapstruct.version>
</properties>
```

### Dependencias Permitidas

**Domain Layer:**
- âœ… Java 21 core
- âœ… Lombok (solo para reducir boilerplate)
- âŒ NO Spring
- âŒ NO JPA
- âŒ NO Jackson

**Application Layer:**
- âœ… Domain
- âœ… Spring Core (`@Service`, `@Transactional`)
- âŒ NO Spring Web
- âŒ NO JPA

**Infrastructure Layer:**
- âœ… Application
- âœ… Domain
- âœ… Spring Boot (web, data-jpa, validation)
- âœ… PostgreSQL
- âœ… Flyway
- âœ… MapStruct
- âœ… Lombok

### Anotaciones por Capa

**Domain:**
- âœ… Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor`
- âŒ NO Spring annotations

**Application:**
- âœ… `@Service`
- âœ… `@Transactional`
- âŒ NO `@RestController`, `@Entity`

**Infrastructure:**
- âœ… `@RestController`, `@RequestMapping`
- âœ… `@Repository`, `@Entity`, `@Table`
- âœ… `@Mapper` (MapStruct)
- âœ… `@Valid`, `@NotBlank`, `@Email`

---

## Testing

### Tipos de Tests

**1. Domain Tests (Unit Tests):**
```java
// NO frameworks, solo JUnit + AssertJ
class UserTest {
    @Test
    void shouldCreateUserWithEnabledTrue() {
        User user = User.create("john", "john@example.com");
        assertTrue(user.isEnabled());
    }
}
```

**2. Application Tests (Unit Tests con Mocks):**
```java
@ExtendWith(MockitoExtension.class)
class CreateUserServiceTest {
    @Mock UserRepository userRepository;
    @Mock UserEventPublisher eventPublisher;
    @InjectMocks CreateUserService service;

    @Test
    void shouldCreateUser() {
        when(userRepository.existsByUsername(anyString())).thenReturn(false);
        when(userRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        UserResult result = service.execute(new CreateUserCommand("john", "john@example.com"));

        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

**3. Integration Tests (con Testcontainers):**
```java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine");

    @Autowired MockMvc mockMvc;

    @Test
    void shouldCreateUserViaRestApi() throws Exception {
        mockMvc.perform(post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("""
                {"username": "john", "email": "john@example.com"}
                """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("john"));
    }
}
```

**Naming Convention:**
- Unit tests: `{Class}Test.java`
- Integration tests: `{Class}IntegrationTest.java`

---

## Checklist de ValidaciÃ³n

### Antes de Generar/Modificar CÃ³digo

**VERIFICAR:**

#### Arquitectura
- [ ] Â¿La clase estÃ¡ en la capa correcta (Domain/Application/Infrastructure)?
- [ ] Â¿Las dependencias apuntan en la direcciÃ³n correcta?
- [ ] Â¿El nombre sigue la convenciÃ³n de nomenclatura?
- [ ] Â¿La ubicaciÃ³n del archivo es correcta segÃºn el template?

#### Domain Layer
- [ ] Â¿Es Java puro (sin Spring, JPA, Jackson)?
- [ ] Â¿Los campos son `final`?
- [ ] Â¿Tiene factory methods `create()` y `reconstitute()`?
- [ ] Â¿Usa Value Objects (no primitivos)?
- [ ] Â¿Usa `Instant` para timestamps (no `LocalDateTime`)?
- [ ] Â¿Lombok solo para reducir boilerplate?

#### Application Layer
- [ ] Â¿Los Use Cases son interfaces?
- [ ] Â¿Los Commands/Queries son records?
- [ ] Â¿Los Services tienen `@Service` y `@Transactional`?
- [ ] Â¿Constructor injection (no `@Autowired` en campos)?
- [ ] Â¿No depende de Infrastructure?

#### Infrastructure Layer
- [ ] Â¿Los Controllers llaman a Use Cases (no a Repositories)?
- [ ] Â¿Los DTOs son records?
- [ ] Â¿Request DTOs tienen Bean Validation?
- [ ] Â¿Los Mappers son interfaces MapStruct?
- [ ] Â¿Las Entities son mutables (para JPA)?

#### Testing
- [ ] Â¿Domain tests sin frameworks?
- [ ] Â¿Application tests con mocks?
- [ ] Â¿Integration tests con Testcontainers?
- [ ] Â¿Naming convention correcta (*Test, *IntegrationTest)?

---

## Ejemplos Completos

### Crear una Nueva Entidad: `Order`

**1. Domain Layer:**
```
src/main/java/com/example/hexarch/order/domain/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ Order.java                 # Aggregate Root
â”‚   â””â”€â”€ valueobject/
â”‚       â””â”€â”€ OrderNumber.java       # Value Object
â”œâ”€â”€ event/
â”‚   â””â”€â”€ OrderPlacedEvent.java      # Domain Event
â””â”€â”€ exception/
    â””â”€â”€ OrderNotFoundException.java
```

**2. Application Layer:**
```
src/main/java/com/example/hexarch/order/application/
â”œâ”€â”€ port/
â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â”œâ”€â”€ PlaceOrderUseCase.java
â”‚   â”‚   â”œâ”€â”€ PlaceOrderCommand.java
â”‚   â”‚   â””â”€â”€ OrderResult.java
â”‚   â””â”€â”€ output/
â”‚       â””â”€â”€ OrderRepository.java
â””â”€â”€ service/
    â””â”€â”€ PlaceOrderService.java
```

**3. Infrastructure Layer:**
```
src/main/java/com/example/hexarch/order/infrastructure/adapter/
â”œâ”€â”€ input/
â”‚   â””â”€â”€ rest/
â”‚       â”œâ”€â”€ OrderController.java
â”‚       â”œâ”€â”€ dto/
â”‚       â”‚   â”œâ”€â”€ PlaceOrderRequest.java
â”‚       â”‚   â””â”€â”€ OrderResponse.java
â”‚       â””â”€â”€ mapper/
â”‚           â””â”€â”€ OrderRestMapper.java
â””â”€â”€ output/
    â””â”€â”€ persistence/
        â”œâ”€â”€ JpaOrderRepositoryAdapter.java
        â”œâ”€â”€ OrderEntity.java
        â”œâ”€â”€ SpringDataOrderRepository.java
        â””â”€â”€ mapper/
            â””â”€â”€ OrderEntityMapper.java
```

---

## Respuestas RÃ¡pidas a Consultas Comunes

### "Â¿DÃ³nde pongo este cÃ³digo?"
- LÃ³gica de negocio â†’ **Domain** (model)
- Validaciones de dominio â†’ **Value Object** o **Aggregate**
- Validaciones HTTP â†’ **Request DTO** (Bean Validation)
- OrquestaciÃ³n â†’ **Application** (Service)
- Persistencia â†’ **Infrastructure** (JPA Adapter)
- REST endpoints â†’ **Infrastructure** (Controller)
- Conversiones â†’ **Mapper** (MapStruct)

### "Â¿QuÃ© tipo de DTO uso?"
- Entrada HTTP â†’ `{Action}{Entity}Request` (record con Bean Validation)
- Entrada Application â†’ `{Action}{Entity}Command` (record sin validaciÃ³n)
- Salida Application â†’ `{Entity}Result` (record)
- Salida HTTP â†’ `{Entity}Response` (record)
- BD â†’ `{Entity}Entity` (clase mutable con JPA)
- Dominio â†’ `{Entity}` (clase inmutable)

### "Â¿CuÃ¡ndo usar `@Transactional`?"
- En Services de Application que modifican datos
- NO en Controllers
- NO en Repositories (Spring Data ya lo maneja)

### "Â¿String o Value Object?"
- Si tiene validaciÃ³n â†’ **Value Object**
- Si es concepto de dominio â†’ **Value Object**
- Si es solo transporte de datos â†’ **String** (en DTOs)

### "Â¿Instant o LocalDateTime?"
- Para timestamps de sistema/auditorÃ­a â†’ **Instant** (UTC)
- Para fechas de negocio sin zona horaria â†’ **LocalDateTime**
- Para fechas con zona horaria â†’ **ZonedDateTime**

---

## Comandos Maven Ãštiles

```bash
# Build (excluye integration tests)
./mvnw clean install

# Solo unit tests
./mvnw test

# Todos los tests (requiere Docker)
./mvnw test -Pintegration-tests

# Run application
./mvnw spring-boot:run
```

---

## Errores Comunes a Evitar

1. âŒ Poner `@Entity` en clases del Domain â†’ Usar `UserEntity` en Infrastructure
2. âŒ Controller llama a Repository directamente â†’ Llamar a UseCase
3. âŒ Service devuelve Domain Object â†’ Devolver Result DTO
4. âŒ Usar `LocalDateTime` para timestamps â†’ Usar `Instant`
5. âŒ Value Object mutable â†’ Debe ser `final` e inmutable
6. âŒ Factory method `create()` sin validaciÃ³n â†’ Validar en Value Objects
7. âŒ `@Autowired` en campos â†’ Constructor injection
8. âŒ Domain depende de Spring â†’ Solo Lombok permitido

---

## 9. Observabilidad: Logs, MÃ©tricas y Trazas

### 9.1. Los 3 Pilares de Observabilidad

La observabilidad permite entender quÃ© estÃ¡ pasando en la aplicaciÃ³n en producciÃ³n mediante **3 pilares complementarios**:

1. **LOGS** ğŸ“: Eventos discretos con timestamp (Â¿QuÃ© pasÃ³?)
2. **MÃ‰TRICAS** ğŸ“ˆ: Valores numÃ©ricos agregados en el tiempo (Â¿CÃ³mo estÃ¡ funcionando?)
3. **TRAZAS** ğŸ”—: Seguimiento de requests a travÃ©s de servicios (Â¿DÃ³nde estÃ¡ el cuello de botella?)

**IMPORTANTE:** Los 3 pilares DEBEN usarse juntos para observabilidad completa.

---

### 9.2. Logs Estructurados (SLF4J + Logback)

#### 9.2.1. Niveles de Log y CuÃ¡ndo Usarlos

| Nivel | CuÃ¡ndo Usar | Ejemplo | En ProducciÃ³n |
|-------|-------------|---------|---------------|
| **ERROR** | Errores crÃ­ticos que requieren atenciÃ³n inmediata | `log.error("Failed to process payment", ex)` | âœ… ON |
| **WARN** | Problemas recuperables, configuraciÃ³n subÃ³ptima | `log.warn("Retrying failed request: attempt {}", retryCount)` | âœ… ON |
| **INFO** | Eventos de negocio importantes | `log.info("User created: userId={}", userId)` | âœ… ON |
| **DEBUG** | InformaciÃ³n de desarrollo, debugging | `log.debug("Query params: {}", params)` | âŒ OFF |
| **TRACE** | Debugging de librerÃ­as, muy detallado | `log.trace("Method entered: {}", methodName)` | âŒ OFF |

#### 9.2.2. ImplementaciÃ³n OBLIGATORIA

```java
// En CUALQUIER Service o clase de Application layer:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class CreateUserService implements CreateUserUseCase {

    // 1. Declarar logger (OBLIGATORIO en todos los Services)
    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 2. LOG INFO: Inicio de operaciÃ³n de negocio importante
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        // 3. LOG WARN: Problemas recuperables
        if (userRepository.existsByUsername(command.username())) {
            log.warn("Username already exists: {}", command.username());
            throw new UserAlreadyExistsException(command.username());
        }

        User savedUser = userRepository.save(user);

        // 4. LOG INFO: OperaciÃ³n exitosa con datos clave
        log.info("User created successfully: userId={}, username={}",
                 savedUser.getId(), savedUser.getUsername().getValue());

        return result;
    }
}
```

#### 9.2.3. Best Practices de Logging

**âœ… HACER:**
```java
// 1. Usar placeholders {} para performance
log.info("User {} performed action {}", userId, action);

// 2. Log de excepciones con stacktrace
log.error("Failed to send email to {}", email, exception);

// 3. Structured logging con datos clave
log.info("Order created: orderId={}, customerId={}, amount={}",
         orderId, customerId, amount);
```

**âŒ NO HACER:**
```java
// 1. ConcatenaciÃ³n de strings (bajo performance)
log.info("User " + userId + " performed " + action);  // âŒ MAL

// 2. Log de informaciÃ³n sensible
log.info("User password: {}", password);  // âŒ NUNCA

// 3. Log excesivo en loops
for (User user : users) {
    log.info("Processing {}", user);  // âŒ Genera miles de logs
}
```

#### 9.2.4. Correlation ID y Trace ID

El proyecto usa **Micrometer Tracing** para correlacionar logs de un mismo request:

```
2024-01-15 10:30:00 [f47ac10b,1a2b3c4d] 550e8400 INFO - User created: userId=123
                    â”‚         â”‚         â”‚
                    TraceId   SpanId    CorrelationId
```

**NO necesitas implementar esto manualmente** - Micrometer lo hace automÃ¡ticamente.

---

### 9.3. MÃ©tricas Custom (Micrometer + Prometheus)

#### 9.3.1. Tipos de MÃ©tricas

| Tipo | Uso | Ejemplo |
|------|-----|---------|
| **Counter** | Valores que solo aumentan | `users.created.total`, `orders.failed.total` |
| **Gauge** | Valores que suben y bajan | `active.connections`, `queue.size` |
| **Histogram** | DistribuciÃ³n de valores | `http.request.duration`, `order.amount` |
| **Timer** | Mide duraciÃ³n de eventos | `method.execution.time` |

#### 9.3.2. ImplementaciÃ³n OBLIGATORIA de MÃ©tricas Custom

```java
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    // 1. Inyectar MeterRegistry (OBLIGATORIO para mÃ©tricas custom)
    private final MeterRegistry meterRegistry;

    // 2. Inyectar environment para tags
    private final String environment;

    public CreateUserService(
            UserRepository userRepository,
            UserEventPublisher userEventPublisher,
            MeterRegistry meterRegistry,
            @Value("${ENVIRONMENT:local}") String environment
    ) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
        this.meterRegistry = meterRegistry;
        this.environment = environment;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        try {
            User savedUser = userRepository.save(user);

            // 3. Incrementar mÃ©trica custom de NEGOCIO
            meterRegistry.counter("users.created.total",
                                  "status", "success",
                                  "environment", environment)
                         .increment();

            log.info("User created successfully: userId={}", savedUser.getId());
            return result;

        } catch (Exception ex) {
            // 4. MÃ©trica de errores
            meterRegistry.counter("users.created.total",
                                  "status", "error",
                                  "environment", environment)
                         .increment();
            throw ex;
        }
    }
}
```

#### 9.3.3. Convenciones de Nombres de MÃ©tricas

**Formato:** `{entity}.{action}.{unit}`

```java
// âœ… BIEN (formato snake_case, claro, con unit)
"users.created.total"      // Counter: usuarios creados
"orders.amount.dollars"    // Gauge: monto en dÃ³lares
"email.sent.total"         // Counter: emails enviados
"payment.duration.seconds" // Timer: duraciÃ³n de pagos

// âŒ MAL (sin formato claro)
"userCreated"              // camelCase (usar snake_case)
"created"                  // Falta entity
"users"                    // Falta action
"users.created"            // Falta unit
```

#### 9.3.4. Tags Obligatorios

**SIEMPRE incluir tags para dimensionalidad:**
```java
// âœ… BIEN: Con tags para filtrar y agrupar
meterRegistry.counter("users.created.total",
                      "status", "success",        // success/error
                      "environment", environment) // local/dev/prod
             .increment();

// âŒ MAL: Sin tags (no puedes filtrar por status o environment)
meterRegistry.counter("users.created.total").increment();
```

#### 9.3.5. DÃ³nde Ver las MÃ©tricas

**Endpoint de Prometheus:**
```bash
# Ver todas las mÃ©tricas en formato Prometheus
curl http://localhost:8080/actuator/prometheus

# Filtrar mÃ©tricas custom
curl http://localhost:8080/actuator/prometheus | grep users_created
```

**Grafana Dashboards:**
- MÃ©tricas JVM: `jvm_memory_used_bytes`, `jvm_gc_pause_seconds`
- MÃ©tricas HTTP: `http_server_requests_seconds_count`
- MÃ©tricas custom: `users_created_total`

---

### 9.4. Trazas Distribuidas (Zipkin + Micrometer)

#### 9.4.1. QuÃ© Son las Trazas

Las trazas distribuidas permiten seguir un request a travÃ©s de mÃºltiples servicios:

```
POST /api/v1/users (250ms total)
  â”œâ”€ CreateUserUseCase (200ms)
  â”‚  â”œâ”€ PostgreSQL INSERT (40ms)
  â”‚  â””â”€ Kafka publish (150ms) â† 60% del tiempo aquÃ­
  â””â”€ Response (10ms)
```

#### 9.4.2. ConfiguraciÃ³n (Ya Incluida)

**application.yaml:**
```yaml
management:
  tracing:
    sampling:
      probability: 1.0  # 100% en desarrollo, 0.1 (10%) en producciÃ³n
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans
```

**NO necesitas cÃ³digo adicional** - Micrometer Tracing lo hace automÃ¡ticamente.

#### 9.4.3. CÃ³mo Ver Trazas

**Zipkin UI:**
```bash
# 1. Levantar Zipkin con docker-compose
docker-compose -f docker-compose-observability.yml up -d

# 2. Acceder a Zipkin UI
http://localhost:9411

# 3. Buscar trazas por:
- Service name: hexarch
- Span name: POST /api/v1/users
- TraceId: del log
```

---

### 9.5. Checklist de Observabilidad

Cuando crees o modifiques un Service:

- [ ] **Logs:**
  - [ ] AÃ±adir `private static final Logger log = ...`
  - [ ] Log INFO al inicio de operaciÃ³n de negocio
  - [ ] Log WARN para problemas recuperables
  - [ ] Log ERROR con stacktrace para excepciones
  - [ ] Log INFO al finalizar exitosamente con datos clave
  - [ ] Usar placeholders `{}` para parÃ¡metros

- [ ] **MÃ©tricas Custom:**
  - [ ] Inyectar `MeterRegistry` y `@Value("${ENVIRONMENT:local}")` en constructor
  - [ ] Crear Counter para operaciones de negocio (`{entity}.{action}.total`)
  - [ ] AÃ±adir tags `status` (success/error) y `environment`
  - [ ] Incrementar mÃ©trica en caso exitoso
  - [ ] Incrementar mÃ©trica en caso de error

- [ ] **Trazas:**
  - [ ] NO necesitas cÃ³digo adicional (automÃ¡tico con Micrometer)
  - [ ] Verificar que `management.tracing.sampling.probability` estÃ© configurado

---

### 9.6. Ejemplo Completo de Service con Observabilidad

```java
package com.example.hexarch.user.application.service;

import com.example.hexarch.user.application.port.input.CreateUserCommand;
import com.example.hexarch.user.application.port.input.CreateUserUseCase;
import com.example.hexarch.user.application.port.input.UserResult;
import com.example.hexarch.user.application.port.output.UserEventPublisher;
import com.example.hexarch.user.application.port.output.UserRepository;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import com.example.hexarch.user.domain.exception.UserAlreadyExistsException;
import com.example.hexarch.user.domain.model.User;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    // 1. Logger (OBLIGATORIO)
    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    // 2. Dependencies
    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // 3. Observability (OBLIGATORIO)
    private final MeterRegistry meterRegistry;
    private final String environment;

    // 4. Constructor con inyecciÃ³n de dependencias
    public CreateUserService(
            UserRepository userRepository,
            UserEventPublisher userEventPublisher,
            MeterRegistry meterRegistry,
            @Value("${ENVIRONMENT:local}") String environment
    ) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
        this.meterRegistry = meterRegistry;
        this.environment = environment;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {

        // 5. LOG INFO: Inicio de operaciÃ³n de negocio
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        // 6. Validaciones con LOG WARN
        if (userRepository.existsByUsername(command.username())) {
            log.warn("Username already exists: {}", command.username());
            throw new UserAlreadyExistsException(command.username());
        }

        if (userRepository.existsByEmail(command.email())) {
            log.warn("Email already exists: {}", command.email());
            throw new UserAlreadyExistsException(command.email());
        }

        // 7. LÃ³gica de negocio
        User user = User.create(command.username(), command.email());
        User savedUser = userRepository.save(user);

        // 8. LOG INFO: OperaciÃ³n exitosa con datos clave
        log.info("User created successfully: userId={}, username={}, email={}",
                savedUser.getId(),
                savedUser.getUsername().getValue(),
                savedUser.getEmail().getValue());

        // 9. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 10. MÃ‰TRICA CUSTOM: Contador de usuarios creados
        meterRegistry.counter("users.created.total",
                              "status", "success",
                              "environment", environment)
                     .increment();

        // 11. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

---

### 9.7. Errores Comunes de Observabilidad

**âŒ Error 1: No usar placeholders en logs**
```java
// âŒ MAL: ConcatenaciÃ³n de strings (bajo performance)
log.info("User " + userId + " created");

// âœ… BIEN: Placeholders (SLF4J optimiza)
log.info("User {} created", userId);
```

**âŒ Error 2: Log de informaciÃ³n sensible**
```java
// âŒ NUNCA loguear passwords, tokens, credit cards
log.info("User password: {}", password);
log.info("JWT token: {}", token);

// âœ… BIEN: Loguear solo identificadores
log.info("User authenticated: userId={}", userId);
```

**âŒ Error 3: MÃ©tricas sin tags**
```java
// âŒ MAL: No puedes filtrar por status o environment
meterRegistry.counter("users.created.total").increment();

// âœ… BIEN: Con tags para dimensionalidad
meterRegistry.counter("users.created.total",
                      "status", "success",
                      "environment", environment)
             .increment();
```

**âŒ Error 4: Usar System.out.println en lugar de logger**
```java
// âŒ MAL: No aparece en logs estructurados, no tiene timestamp, no tiene level
System.out.println("User created");

// âœ… BIEN: Usar logger con nivel apropiado
log.info("User created: userId={}", userId);
```

---

### 9.8. DocumentaciÃ³n de Referencia

Para aprender mÃ¡s sobre observabilidad en este proyecto:
- **GuÃ­a completa**: [docs/07-Monitoring-Observability.md](docs/07-Monitoring-Observability.md)
- **README**: SecciÃ³n "Observabilidad: Monitorizar la AplicaciÃ³n"
- **Bruno Collection**: Endpoint `/api/v1/monitoring/Prometheus.bru`

---

## 10. Spring Security + JWT Authentication & Authorization

### 10.1. Conceptos Clave

**AutenticaciÃ³n vs AutorizaciÃ³n:**
- **AutenticaciÃ³n (Authentication)**: Â¿QUIÃ‰N eres? â†’ Validar token JWT
- **AutorizaciÃ³n (Authorization)**: Â¿QUÃ‰ puedes hacer? â†’ Verificar roles

**Stateless JWT:**
- Sin sesiones HTTP (SessionCreationPolicy.STATELESS)
- Cada request incluye token JWT en header `Authorization: Bearer {token}`
- Token contiene: username + roles + timestamp

### 10.2. Estructura de Archivos (OBLIGATORIA)

```
src/main/java/com/example/hexarch/
â”‚
â”œâ”€â”€ shared/                                 â† Cross-cutting concerns
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â””â”€â”€ security/
â”‚   â”‚       â””â”€â”€ Role.java                   â† Enum de roles (DOMAIN)
â”‚   â”‚
â”‚   â””â”€â”€ infrastructure/
â”‚       â””â”€â”€ security/
â”‚           â”œâ”€â”€ SecurityConfig.java         â† ConfiguraciÃ³n Spring Security
â”‚           â””â”€â”€ jwt/
â”‚               â”œâ”€â”€ JwtProperties.java      â† @ConfigurationProperties
â”‚               â”œâ”€â”€ JwtTokenProvider.java   â† Core: genera/valida tokens
â”‚               â”œâ”€â”€ JwtAuthenticationFilter.java  â† Filtro HTTP
â”‚               â””â”€â”€ JwtAuthenticationEntryPoint.java  â† Errores 401
```

**REGLA:** Security es **transversal** â†’ va en `shared/`, NO en bounded context especÃ­fico

### 10.3. Role Enum (Domain Layer)

```java
// shared/domain/security/Role.java
public enum Role {
    ADMIN,      // Acceso completo
    MANAGER,    // Puede crear/leer usuarios
    VIEWER,     // Solo lectura
    SUPPLIER;   // Acceso limitado

    // Spring Security espera prefijo ROLE_
    public String getAuthority() {
        return "ROLE_" + this.name();
    }

    // Convertir desde String (case-insensitive, con/sin ROLE_)
    public static Role fromString(String roleName) {
        String cleanName = roleName.toUpperCase().replace("ROLE_", "");
        return Role.valueOf(cleanName);
    }
}
```

**Â¿Por quÃ© en Domain?**
- Los roles son concepto de negocio (no tÃ©cnico)
- Son independientes del framework (Spring Security)
- Se usan en mÃºltiples bounded contexts

### 10.4. JwtTokenProvider (Core Component)

```java
// shared/infrastructure/security/jwt/JwtTokenProvider.java
@Component
@RequiredArgsConstructor
@Slf4j
public class JwtTokenProvider {
    private final JwtProperties jwtProperties;
    private SecretKey secretKey;

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtProperties.getSecret().getBytes(StandardCharsets.UTF_8);
        this.secretKey = Keys.hmacShaKeyFor(keyBytes);
    }

    // Genera token JWT con username y roles
    public String generateToken(String username, List<Role> roles) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtProperties.getExpiration());

        List<String> roleNames = roles.stream()
            .map(Role::name)
            .collect(Collectors.toList());

        return Jwts.builder()
            .subject(username)
            .claim("roles", roleNames)
            .issuedAt(now)
            .expiration(expiryDate)
            .signWith(secretKey, Jwts.SIG.HS256)
            .compact();
    }

    // Valida token (firma + expiraciÃ³n)
    public boolean validateToken(String token) {
        try {
            getClaimsFromToken(token);
            return true;
        } catch (JwtException ex) {
            log.error("Invalid JWT: {}", ex.getMessage());
            return false;
        }
    }

    // Extrae username del token
    public String getUsernameFromToken(String token) {
        return getClaimsFromToken(token).getSubject();
    }

    // Extrae roles del token
    public List<Role> getRolesFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        List<String> roleNames = claims.get("roles", List.class);
        return roleNames.stream().map(Role::fromString).collect(Collectors.toList());
    }

    private Claims getClaimsFromToken(String token) {
        return Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }
}
```

### 10.5. JwtAuthenticationFilter (HTTP Filter)

```java
// shared/infrastructure/security/jwt/JwtAuthenticationFilter.java
@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {

        String token = extractTokenFromRequest(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsernameFromToken(token);
            List<Role> roles = jwtTokenProvider.getRolesFromToken(token);

            List<SimpleGrantedAuthority> authorities = roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.getAuthority()))
                .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, authorities);

            authentication.setDetails(
                new WebAuthenticationDetailsSource().buildDetails(request)
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 10.6. SecurityConfig (ConfiguraciÃ³n Principal)

```java
// shared/infrastructure/security/SecurityConfig.java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                // Endpoints pÃºblicos
                .requestMatchers("/actuator/health", "/swagger-ui/**").permitAll()

                // Endpoints protegidos por rol
                .requestMatchers(HttpMethod.POST, "/api/users")
                    .hasAnyRole("ADMIN", "MANAGER")

                .requestMatchers(HttpMethod.GET, "/api/users/**")
                    .authenticated()

                .anyRequest().authenticated()
            )
            .addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
            );

        return http.build();
    }
}
```

**IMPORTANTE:**
- `.hasAnyRole("ADMIN")` â†’ Spring aÃ±ade prefijo `ROLE_` automÃ¡ticamente
- NO uses `.hasAnyRole("ROLE_ADMIN")` (doble prefijo)

### 10.7. ConfiguraciÃ³n (application.yaml)

```yaml
jwt:
  # Secret key para firmar tokens (256 bits mÃ­nimo para HS256)
  # âš ï¸ En producciÃ³n: usar ${JWT_SECRET} (variable de entorno)
  secret: 5JYzCkNP8xQ2mVnRwTaFbGdKeShXrUvYy3t6v9yBxE4=

  # ExpiraciÃ³n en milisegundos (24 horas)
  expiration: 86400000
```

### 10.8. Matriz de AutorizaciÃ³n

| Endpoint | MÃ©todo | ADMIN | MANAGER | VIEWER | SUPPLIER | Sin Auth |
|----------|--------|-------|---------|--------|----------|----------|
| `/api/users` | POST | âœ… | âœ… | âŒ | âŒ | âŒ |
| `/api/users/{id}` | GET | âœ… | âœ… | âœ… | âœ… | âŒ |
| `/actuator/health` | GET | âœ… | âœ… | âœ… | âœ… | âœ… |

### 10.9. Testing de Seguridad

**Unit Tests:**

```java
// shared/infrastructure/security/jwt/JwtTokenProviderTest.java
@DisplayName("JWT Token Provider Unit Tests")
class JwtTokenProviderTest {
    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setUp() {
        JwtProperties props = new JwtProperties();
        props.setSecret("test-secret-key-256-bits...");
        props.setExpiration(86400000L);

        jwtTokenProvider = new JwtTokenProvider(props);
        jwtTokenProvider.init();
    }

    @Test
    void shouldGenerateValidJwtToken() {
        String token = jwtTokenProvider.generateToken("user", List.of(Role.ADMIN));

        assertThat(token).isNotNull();
        assertThat(jwtTokenProvider.validateToken(token)).isTrue();
    }
}
```

**Integration Tests:**

```java
// security/SecurityIntegrationTest.java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class SecurityIntegrationTest {
    @Autowired private MockMvc mockMvc;
    @Autowired private JwtTokenProvider jwtTokenProvider;

    private String adminToken;

    @BeforeEach
    void setUp() {
        adminToken = "Bearer " + jwtTokenProvider.generateToken(
            "admin", List.of(Role.ADMIN)
        );
    }

    @Test
    void shouldReturn401WhenCreatingUserWithoutToken() throws Exception {
        mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("{\"username\":\"test\",\"email\":\"test@test.com\"}"))
        .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldCreateUserWithAdminRole() throws Exception {
        mockMvc.perform(post("/api/users")
            .header("Authorization", adminToken)
            .contentType(MediaType.APPLICATION_JSON)
            .content("{\"username\":\"test\",\"email\":\"test@test.com\"}"))
        .andExpect(status().isCreated());
    }
}
```

### 10.10. Best Practices OBLIGATORIAS

**1. NUNCA hardcodear secret en cÃ³digo:**
```java
// âŒ MAL
private static final String SECRET = "my-secret";

// âœ… BIEN
@Value("${jwt.secret}")
private String secret;
```

**2. Secret key mÃ­nimo 256 bits (32 caracteres) para HS256**

**3. En producciÃ³n: usar variables de entorno**
```yaml
jwt:
  secret: ${JWT_SECRET}  # Variable de entorno
```

**4. HTTPS obligatorio en producciÃ³n**
- JWT en HTTP plano â†’ vulnerable a ataques

**5. ExpiraciÃ³n razonable:**
- Desarrollo/educaciÃ³n: 24 horas
- ProducciÃ³n: 15-60 minutos + refresh token

**6. Validar SIEMPRE:**
- Firma del token (con secret key)
- ExpiraciÃ³n (exp claim)
- Formato (3 partes separadas por puntos)

### 10.11. Errores Comunes

**âŒ Error 1: Usar ROLE_ dos veces**
```java
.hasAnyRole("ROLE_ADMIN")  // Spring aÃ±ade ROLE_ automÃ¡ticamente â†’ ROLE_ROLE_ADMIN
```
âœ… Correcto:
```java
.hasAnyRole("ADMIN")  // Spring lo convierte a ROLE_ADMIN
```

**âŒ Error 2: Token sin prefijo Bearer**
```java
request.setHeader("Authorization", token);  // Sin "Bearer "
```
âœ… Correcto:
```java
request.setHeader("Authorization", "Bearer " + token);
```

**âŒ Error 3: Secret key muy corto**
```yaml
jwt:
  secret: short  # < 256 bits â†’ WeakKeyException
```
âœ… Correcto:
```yaml
jwt:
  secret: 5JYzCkNP8xQ2mVnRwTaFbGdKeShXrUvYy3t6v9yBxE4=  # 256 bits
```

### 10.12. Checklist de ImplementaciÃ³n

Cuando aÃ±adas seguridad JWT:

- [ ] Crear `Role` enum en `shared/domain/security/`
- [ ] Crear `JwtProperties` con `@ConfigurationProperties`
- [ ] Crear `JwtTokenProvider` con mÃ©todos generate/validate/extract
- [ ] Crear `JwtAuthenticationFilter` extends `OncePerRequestFilter`
- [ ] Crear `JwtAuthenticationEntryPoint` implements `AuthenticationEntryPoint`
- [ ] Crear `SecurityConfig` con `@EnableWebSecurity`
- [ ] Configurar `application.yaml` con secret y expiration
- [ ] AÃ±adir autorizaciÃ³n por endpoint en `SecurityConfig`
- [ ] Escribir unit tests para `JwtTokenProvider` y `Role`
- [ ] Escribir integration tests para endpoints protegidos
- [ ] Documentar en guÃ­a `docs/08-Spring-Security-JWT.md`

---

## Fin de Guidelines

**RECUERDA:** Estas reglas NO son sugerencias, son **OBLIGATORIAS**. Si generas cÃ³digo que viole estas reglas, el proyecto no compilarÃ¡ o fallarÃ¡ en los tests de arquitectura.

**Ante cualquier duda:** Revisa los ejemplos completos en el proyecto existente y sigue el patrÃ³n al pie de la letra.

**Prioridades:**
1. Respeta la Dependency Rule (lo mÃ¡s importante)
2. Sigue la nomenclatura exacta
3. Usa los patrones de implementaciÃ³n
4. Coloca archivos en ubicaciones correctas
5. Escribe tests adecuados

---

**VersiÃ³n de Guidelines:** 1.2 (Actualizado con Records para Value Objects)
**Ãšltima actualizaciÃ³n:** 2025-01-30
