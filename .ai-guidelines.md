# AI Guidelines - Hexagonal Architecture Project

> **PROPÃ“SITO:** Este archivo contiene las reglas arquitecturales, patrones y convenciones que DEBES seguir cuando generes, modifiques o sugieras cÃ³digo para este proyecto. Lee este archivo completo antes de hacer cualquier cambio.

---

## ğŸ“‹ Tabla de Contenidos

1. [Arquitectura General](#arquitectura-general)
2. [Reglas de Dependencias](#reglas-de-dependencias)
3. [Estructura de Directorios](#estructura-de-directorios)
4. [Nomenclatura Obligatoria](#nomenclatura-obligatoria)
5. [Patrones de ImplementaciÃ³n](#patrones-de-implementaciÃ³n)
6. [TecnologÃ­as y Frameworks](#tecnologÃ­as-y-frameworks)
7. [Testing](#testing)
8. [Checklist de ValidaciÃ³n](#checklist-de-validaciÃ³n)

---

## Arquitectura General

### Paradigma: Hexagonal Architecture (Ports & Adapters) + DDD + CQRS ligero

Este proyecto sigue una arquitectura hexagonal estricta con 3 capas claramente separadas:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INFRASTRUCTURE                        â”‚
â”‚  (Spring, JPA, REST, Kafka, etc.)                        â”‚
â”‚  - Adapters (input: REST, output: JPA, Events)          â”‚
â”‚  - DTOs: Request, Response, Entity                       â”‚
â”‚  - Mappers: MapStruct                                    â”‚
â”‚  - Configuration: Spring Beans, Exception Handlers       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ depends on (implements ports)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    APPLICATION                           â”‚
â”‚  (Use Cases, Orchestration)                              â”‚
â”‚  - Ports: Input (UseCases), Output (Repositories)       â”‚
â”‚  - Services: Implement UseCases                          â”‚
â”‚  - DTOs: Command, Query, Result                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ depends on (uses domain)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       DOMAIN                             â”‚
â”‚  (Business Logic, Pure Java + Lombok)                    â”‚
â”‚  - Model: Aggregates, Entities, Value Objects           â”‚
â”‚  - Events: Domain Events (records)                       â”‚
â”‚  - Exceptions: Domain Exceptions                         â”‚
â”‚  - NO FRAMEWORKS (solo Lombok para reducir boilerplate) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Reglas de Dependencias

### ğŸš« PROHIBIDO (Dependency Rule Violations)

1. âŒ **Domain NO PUEDE depender de Application o Infrastructure**
   - âŒ No imports de Spring en Domain
   - âŒ No imports de JPA (@Entity) en Domain
   - âŒ No imports de Jackson en Domain
   - âœ… Solo: Java core, Lombok, y otros paquetes del Domain

2. âŒ **Application NO PUEDE depender de Infrastructure**
   - âŒ No imports de Controllers en Application
   - âŒ No imports de JPA Entities en Application
   - âŒ No imports de implementaciones concretas (adapters)
   - âœ… Solo: Domain, interfaces propias (ports), y Spring bÃ¡sico (@Service, @Transactional)

3. âŒ **Controllers NO PUEDEN llamar a Repositories directamente**
   - âŒ Controller â†’ Repository (bypass de Application layer)
   - âœ… Controller â†’ UseCase â†’ Repository

### âœ… PERMITIDO (Correct Dependencies)

```
Infrastructure â†’ Application âœ…
Infrastructure â†’ Domain     âœ…
Application    â†’ Domain     âœ…
```

---

## Estructura de Directorios

### Template de Carpetas (RESPETAR ESTRICTAMENTE)

```
src/main/java/com/example/hexarch/
â”‚
â”œâ”€â”€ {bounded-context}/              # ej: user, order, payment
â”‚   â”‚
â”‚   â”œâ”€â”€ domain/                     # CAPA 1: DOMINIO
â”‚   â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”‚   â”œâ”€â”€ {Aggregate}.java           # ej: User.java
â”‚   â”‚   â”‚   â””â”€â”€ valueobject/
â”‚   â”‚   â”‚       â”œâ”€â”€ {ValueObject}.java     # ej: Email.java, Username.java
â”‚   â”‚   â”œâ”€â”€ event/
â”‚   â”‚   â”‚   â””â”€â”€ {Entity}{Action}Event.java # ej: UserCreatedEvent.java
â”‚   â”‚   â””â”€â”€ exception/
â”‚   â”‚       â”œâ”€â”€ DomainException.java
â”‚   â”‚       â”œâ”€â”€ ValidationException.java
â”‚   â”‚       â””â”€â”€ {Entity}AlreadyExistsException.java
â”‚   â”‚
â”‚   â”œâ”€â”€ application/                # CAPA 2: APLICACIÃ“N
â”‚   â”‚   â”œâ”€â”€ port/
â”‚   â”‚   â”‚   â”œâ”€â”€ input/              # LO QUE LA APP OFRECE
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ {Action}{Entity}UseCase.java    # ej: CreateUserUseCase.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ {Action}{Entity}Command.java    # ej: CreateUserCommand.java
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Get{Entity}Query.java           # ej: GetUserQuery.java (CQRS)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ {Entity}Result.java             # ej: UserResult.java
â”‚   â”‚   â”‚   â””â”€â”€ output/             # LO QUE LA APP NECESITA
â”‚   â”‚   â”‚       â”œâ”€â”€ {Entity}Repository.java         # ej: UserRepository.java
â”‚   â”‚   â”‚       â””â”€â”€ {Entity}EventPublisher.java     # ej: UserEventPublisher.java
â”‚   â”‚   â””â”€â”€ service/
â”‚   â”‚       â”œâ”€â”€ {Action}{Entity}Service.java        # ej: CreateUserService.java
â”‚   â”‚       â””â”€â”€ Get{Entity}QueryHandler.java        # ej: GetUserQueryHandler.java (CQRS)
â”‚   â”‚
â”‚   â””â”€â”€ infrastructure/             # CAPA 3: INFRAESTRUCTURA
â”‚       â””â”€â”€ adapter/
â”‚           â”œâ”€â”€ input/              # ADAPTADORES DE ENTRADA
â”‚           â”‚   â””â”€â”€ rest/
â”‚           â”‚       â”œâ”€â”€ {Entity}Controller.java     # ej: UserController.java
â”‚           â”‚       â”œâ”€â”€ dto/
â”‚           â”‚       â”‚   â”œâ”€â”€ {Action}{Entity}Request.java   # ej: CreateUserRequest.java
â”‚           â”‚       â”‚   â””â”€â”€ {Entity}Response.java          # ej: UserResponse.java
â”‚           â”‚       â””â”€â”€ mapper/
â”‚           â”‚           â””â”€â”€ {Entity}RestMapper.java        # ej: UserRestMapper.java
â”‚           â””â”€â”€ output/             # ADAPTADORES DE SALIDA
â”‚               â”œâ”€â”€ persistence/
â”‚               â”‚   â”œâ”€â”€ Jpa{Entity}RepositoryAdapter.java  # ej: JpaUserRepositoryAdapter.java
â”‚               â”‚   â”œâ”€â”€ {Entity}Entity.java                # ej: UserEntity.java
â”‚               â”‚   â”œâ”€â”€ SpringData{Entity}Repository.java  # ej: SpringDataUserRepository.java
â”‚               â”‚   â””â”€â”€ mapper/
â”‚               â”‚       â””â”€â”€ {Entity}EntityMapper.java      # ej: UserEntityMapper.java
â”‚               â””â”€â”€ event/
â”‚                   â””â”€â”€ {Technology}{Entity}EventPublisherAdapter.java  # ej: KafkaUserEventPublisherAdapter.java
â”‚
â””â”€â”€ shared/                         # CÃ“DIGO COMPARTIDO
    â””â”€â”€ infrastructure/
        â””â”€â”€ exception/
            â”œâ”€â”€ GlobalExceptionHandler.java
            â””â”€â”€ ErrorResponse.java
```

### Reglas de UbicaciÃ³n

1. **Bounded Contexts**: Cada mÃ³dulo de negocio (user, order, payment) tiene su propia carpeta raÃ­z
2. **NO mezclar capas**: Cada archivo va EXACTAMENTE en su carpeta correspondiente
3. **NO crear subcarpetas adicionales** sin justificaciÃ³n arquitectural
4. **Shared solo para infraestructura comÃºn** (exception handling, config, etc.)

---

## Nomenclatura Obligatoria

### Tabla de Nomenclatura (SEGUIR AL PIE DE LA LETRA)

| Capa | Tipo | PatrÃ³n | Ejemplo | UbicaciÃ³n |
|------|------|--------|---------|-----------|
| **Application (Input)** | Use Case Interface | `{Action}{Entity}UseCase` | `CreateUserUseCase` | `application/port/input/` |
| **Application (Input)** | Command | `{Action}{Entity}Command` | `CreateUserCommand` | `application/port/input/` |
| **Application (Input)** | Query | `Get{Entity}Query` | `GetUserQuery` | `application/port/input/` |
| **Application (Input)** | Result | `{Entity}Result` | `UserResult` | `application/port/input/` |
| **Application (Output)** | Repository Interface | `{Entity}Repository` | `UserRepository` | `application/port/output/` |
| **Application (Output)** | Event Publisher Interface | `{Entity}EventPublisher` | `UserEventPublisher` | `application/port/output/` |
| **Application (Service)** | Service Implementation | `{Action}{Entity}Service` | `CreateUserService` | `application/service/` |
| **Application (Service)** | Query Handler | `Get{Entity}QueryHandler` | `GetUserQueryHandler` | `application/service/` |
| **Domain** | Aggregate Root | `{Entity}` | `User` | `domain/model/` |
| **Domain** | Value Object | `{Concept}` | `Email`, `Username` | `domain/model/valueobject/` |
| **Domain** | Domain Event | `{Entity}{Action}Event` | `UserCreatedEvent` | `domain/event/` |
| **Domain** | Domain Exception | `{Entity}{Reason}Exception` | `UserAlreadyExistsException` | `domain/exception/` |
| **Infrastructure (Input)** | Controller | `{Entity}Controller` | `UserController` | `infrastructure/adapter/input/rest/` |
| **Infrastructure (Input)** | Request DTO | `{Action}{Entity}Request` | `CreateUserRequest` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | Response DTO | `{Entity}Response` | `UserResponse` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | REST Mapper | `{Entity}RestMapper` | `UserRestMapper` | `infrastructure/adapter/input/rest/mapper/` |
| **Infrastructure (Output)** | JPA Entity | `{Entity}Entity` | `UserEntity` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Repository Adapter | `Jpa{Entity}RepositoryAdapter` | `JpaUserRepositoryAdapter` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Spring Data Repo | `SpringData{Entity}Repository` | `SpringDataUserRepository` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Entity Mapper | `{Entity}EntityMapper` | `UserEntityMapper` | `infrastructure/adapter/output/persistence/mapper/` |
| **Infrastructure (Output)** | Event Publisher Adapter | `{Tech}{Entity}EventPublisherAdapter` | `KafkaUserEventPublisherAdapter` | `infrastructure/adapter/output/event/` |

### Reglas de Naming

1. **PascalCase** para nombres de clases: `CreateUserService`
2. **camelCase** para mÃ©todos y variables: `createUser()`, `userResult`
3. **UPPER_SNAKE_CASE** para constantes: `MAX_USERNAME_LENGTH`
4. **Verbos para mÃ©todos**: `create()`, `save()`, `find()`, `execute()`
5. **Sustantivos para clases**: `User`, `Email`, `UserController`

---

## Patrones de ImplementaciÃ³n

### 1. Domain Layer (Aggregate Roots, Entities)

**SIEMPRE seguir este patrÃ³n:**

```java
package com.example.hexarch.user.domain.model;

import com.example.hexarch.user.domain.model.valueobject.Email;
import com.example.hexarch.user.domain.model.valueobject.Username;
import lombok.*;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Aggregate Root
 *
 * REGLAS:
 * - Inmutable (final fields, sin setters)
 * - Factory methods: create() para nuevo, reconstitute() para existente
 * - MÃ©todos de negocio devuelven nueva instancia
 * - Usa Value Objects (no primitivos)
 * - Sin anotaciones de frameworks (solo Lombok)
 */
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class User {

    @EqualsAndHashCode.Include
    private final UUID id;
    private final Username username;  // Value Object
    private final Email email;        // Value Object
    private final boolean enabled;
    private final Instant createdAt;  // SIEMPRE Instant (no LocalDateTime)

    /**
     * Factory Method - Crear nuevo
     */
    public static User create(String username, String email) {
        return new User(
            UUID.randomUUID(),
            Username.of(username),
            Email.of(email),
            true,
            Instant.now()
        );
    }

    /**
     * Factory Method - Reconstruir existente
     */
    public static User reconstitute(UUID id, String username, String email,
                                     boolean enabled, Instant createdAt) {
        return new User(
            id,
            Username.of(username),
            Email.of(email),
            enabled,
            createdAt
        );
    }

    /**
     * MÃ©todo de negocio - Devuelve nueva instancia (inmutabilidad)
     */
    public User disable() {
        return new User(this.id, this.username, this.email, false, this.createdAt);
    }
}
```

**CHECKLIST Domain:**
- [ ] Clase con Lombok: `@Getter`, `@EqualsAndHashCode(onlyExplicitlyIncluded = true)`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Campos `final`
- [ ] Sin setters pÃºblicos
- [ ] Factory method `create()` para nuevos
- [ ] Factory method `reconstitute()` para existentes
- [ ] MÃ©todos de negocio devuelven nueva instancia
- [ ] Usa Value Objects (no String/int directos)
- [ ] Usa `Instant` para timestamps (NO `LocalDateTime`)
- [ ] `equals/hashCode` solo en el ID (agregar `@EqualsAndHashCode.Include` al ID)

---

### 2. Value Objects

**SIEMPRE seguir este patrÃ³n:**

```java
package com.example.hexarch.user.domain.model.valueobject;

import com.example.hexarch.user.domain.exception.ValidationException;
import lombok.*;

import java.util.regex.Pattern;

/**
 * DOMAIN LAYER - Value Object
 *
 * REGLAS:
 * - Inmutable (final class, final field)
 * - Auto-valida en el constructor
 * - Factory method: of(String)
 * - Sin setters
 * - Equals por valor (no por identidad)
 */
@Getter
@EqualsAndHashCode
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class Email {

    private static final Pattern EMAIL_PATTERN =
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");

    private final String value;

    /**
     * Factory Method - Crea y valida
     */
    public static Email of(String value) {
        validate(value);
        return new Email(value);
    }

    private static void validate(String value) {
        if (value == null || value.isBlank()) {
            throw new ValidationException("EMAIL_001", "Email no puede estar vacÃ­o");
        }
        if (!EMAIL_PATTERN.matcher(value).matches()) {
            throw new ValidationException("EMAIL_002", "Formato de email invÃ¡lido");
        }
    }
}
```

**CHECKLIST Value Object:**
- [ ] Clase `final`
- [ ] Campo `final`
- [ ] Sin setters
- [ ] Factory method `of(String)` que valida
- [ ] ValidaciÃ³n en mÃ©todo privado `validate()`
- [ ] Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Lanza `ValidationException` con cÃ³digo de error

---

### 3. Domain Events

**SIEMPRE usar records:**

```java
package com.example.hexarch.user.domain.event;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Domain Event
 *
 * REGLAS:
 * - Siempre record (inmutable)
 * - Nombrado en PASADO: {Entity}{Action}Event
 * - Contiene Instant occurredAt
 * - Factory method: from()
 */
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}
```

**CHECKLIST Domain Event:**
- [ ] Es un `record`
- [ ] Nombrado en pasado: `{Entity}{Action}Event`
- [ ] Tiene campo `Instant occurredAt`
- [ ] Factory method `from()` que genera `occurredAt`

---

### 4. Application Layer (Use Cases)

**PatrÃ³n Interface + Implementation:**

```java
// Interface (Input Port)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Input Port (Use Case)
 *
 * REGLAS:
 * - Interface pura
 * - MÃ©todo execute() con Command/Query
 * - Retorna Result
 */
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Command (DTO)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Command (CQRS Write)
 *
 * REGLAS:
 * - Siempre record
 * - Solo datos primitivos o inmutables
 * - Sin lÃ³gica
 */
public record CreateUserCommand(String username, String email) {}

// Result (DTO)
package com.example.hexarch.user.application.port.input;

import java.time.Instant;
import java.util.UUID;

/**
 * APPLICATION LAYER - Result
 *
 * REGLAS:
 * - Siempre record
 * - Datos primitivos o Instant (NO Value Objects)
 */
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Service (Implementation)
package com.example.hexarch.user.application.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * APPLICATION LAYER - Service (Use Case Implementation)
 *
 * REGLAS:
 * - Implementa UseCase interface
 * - @Service + @Transactional
 * - Constructor injection (no @Autowired)
 * - Orquesta dominio y output ports
 */
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // Constructor injection (preferido)
    public CreateUserService(UserRepository userRepository,
                             UserEventPublisher userEventPublisher) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 1. Validar precondiciones
        if (userRepository.existsByUsername(command.username())) {
            throw new UserAlreadyExistsException(command.username());
        }

        // 2. Crear dominio
        User user = User.create(command.username(), command.email());

        // 3. Persistir
        User savedUser = userRepository.save(user);

        // 4. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 5. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

**CHECKLIST Application Service:**
- [ ] Implementa UseCase interface
- [ ] Anotado con `@Service` y `@Transactional`
- [ ] Constructor injection (NO `@Autowired` en campos)
- [ ] Flujo: validar â†’ crear dominio â†’ persistir â†’ publicar evento â†’ retornar
- [ ] Extrae valores de Value Objects antes de retornar (`.getValue()`)

---

### 5. Infrastructure Layer (Adapters)

**Controller (Input Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

/**
 * INFRASTRUCTURE LAYER - REST Controller
 *
 * REGLAS:
 * - @RestController + @RequestMapping
 * - Constructor injection
 * - Usa UseCase (NO Repository)
 * - Mapea Request â†” Command y Result â†” Response
 */
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    private final CreateUserUseCase createUserUseCase;
    private final UserRestMapper mapper;

    public UserController(CreateUserUseCase createUserUseCase,
                          UserRestMapper mapper) {
        this.createUserUseCase = createUserUseCase;
        this.mapper = mapper;
    }

    @PostMapping
    public ResponseEntity<UserResponse> createUser(
        @Valid @RequestBody CreateUserRequest request
    ) {
        // 1. Mapear Request â†’ Command
        CreateUserCommand command = mapper.toCommand(request);

        // 2. Ejecutar UseCase
        UserResult result = createUserUseCase.execute(command);

        // 3. Mapear Result â†’ Response
        UserResponse response = mapper.toResponse(result);

        // 4. Retornar HTTP
        return ResponseEntity.status(201).body(response);
    }
}
```

**Request/Response DTOs (siempre records):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.dto;

import jakarta.validation.constraints.*;

/**
 * INFRASTRUCTURE LAYER - REST Request DTO
 *
 * REGLAS:
 * - Siempre record
 * - Bean Validation: @NotBlank, @Email, @Size, etc.
 */
public record CreateUserRequest(
    @NotBlank(message = "Username no puede estar vacÃ­o")
    @Size(min = 3, max = 50, message = "Username debe tener entre 3 y 50 caracteres")
    String username,

    @NotBlank(message = "Email no puede estar vacÃ­o")
    @Email(message = "Email debe tener formato vÃ¡lido")
    String email
) {}

public record UserResponse(
    String id,           // UUID como String
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

**Repository Adapter (Output Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - Repository Adapter
 *
 * REGLAS:
 * - @Repository
 * - Implementa interface de Application
 * - Constructor injection
 * - Delega a Spring Data Repository
 * - Mapea Entity â†” Domain
 */
@Repository
public class JpaUserRepositoryAdapter implements UserRepository {

    private final SpringDataUserRepository springDataRepo;
    private final UserEntityMapper mapper;

    public JpaUserRepositoryAdapter(SpringDataUserRepository springDataRepo,
                                     UserEntityMapper mapper) {
        this.springDataRepo = springDataRepo;
        this.mapper = mapper;
    }

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        UserEntity savedEntity = springDataRepo.save(entity);
        return mapper.toDomain(savedEntity);
    }

    @Override
    public Optional<User> findById(UUID id) {
        return springDataRepo.findById(id)
            .map(mapper::toDomain);
    }
}
```

**JPA Entity:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import jakarta.persistence.*;
import lombok.*;
import java.time.Instant;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - JPA Entity
 *
 * REGLAS:
 * - @Entity, @Table
 * - Mutable (tiene setters para JPA)
 * - NO es el modelo de dominio
 * - Lombok: @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor
 */
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {

    @Id
    private UUID id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
}
```

---

### 6. Mappers (MapStruct)

**SIEMPRE usar MapStruct:**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.mapper;

import org.mapstruct.*;

/**
 * INFRASTRUCTURE LAYER - REST Mapper
 *
 * REGLAS:
 * - @Mapper(componentModel = "spring")
 * - MÃ©todos: toCommand(), toResponse()
 * - Conversiones de tipos (UUID â†” String)
 */
@Mapper(componentModel = "spring")
public interface UserRestMapper {

    CreateUserCommand toCommand(CreateUserRequest request);

    @Mapping(target = "id", source = "id", qualifiedByName = "uuidToString")
    UserResponse toResponse(UserResult result);

    @Named("uuidToString")
    default String uuidToString(UUID uuid) {
        return uuid != null ? uuid.toString() : null;
    }
}
```

**CHECKLIST Mapper:**
- [ ] Interface (no clase)
- [ ] `@Mapper(componentModel = "spring")`
- [ ] MÃ©todos claros: `toCommand()`, `toResponse()`, `toDomain()`, `toEntity()`
- [ ] Custom mappings con `@Mapping` y `@Named`

---

## TecnologÃ­as y Frameworks

### Versiones Obligatorias

```xml
<properties>
    <java.version>21</java.version>
    <spring-boot.version>3.5.7</spring-boot.version>
    <mapstruct.version>1.6.3</mapstruct.version>
</properties>
```

### Dependencias Permitidas

**Domain Layer:**
- âœ… Java 21 core
- âœ… Lombok (solo para reducir boilerplate)
- âŒ NO Spring
- âŒ NO JPA
- âŒ NO Jackson

**Application Layer:**
- âœ… Domain
- âœ… Spring Core (`@Service`, `@Transactional`)
- âŒ NO Spring Web
- âŒ NO JPA

**Infrastructure Layer:**
- âœ… Application
- âœ… Domain
- âœ… Spring Boot (web, data-jpa, validation)
- âœ… PostgreSQL
- âœ… Flyway
- âœ… MapStruct
- âœ… Lombok

### Anotaciones por Capa

**Domain:**
- âœ… Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor`
- âŒ NO Spring annotations

**Application:**
- âœ… `@Service`
- âœ… `@Transactional`
- âŒ NO `@RestController`, `@Entity`

**Infrastructure:**
- âœ… `@RestController`, `@RequestMapping`
- âœ… `@Repository`, `@Entity`, `@Table`
- âœ… `@Mapper` (MapStruct)
- âœ… `@Valid`, `@NotBlank`, `@Email`

---

## Testing

### Tipos de Tests

**1. Domain Tests (Unit Tests):**
```java
// NO frameworks, solo JUnit + AssertJ
class UserTest {
    @Test
    void shouldCreateUserWithEnabledTrue() {
        User user = User.create("john", "john@example.com");
        assertTrue(user.isEnabled());
    }
}
```

**2. Application Tests (Unit Tests con Mocks):**
```java
@ExtendWith(MockitoExtension.class)
class CreateUserServiceTest {
    @Mock UserRepository userRepository;
    @Mock UserEventPublisher eventPublisher;
    @InjectMocks CreateUserService service;

    @Test
    void shouldCreateUser() {
        when(userRepository.existsByUsername(anyString())).thenReturn(false);
        when(userRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        UserResult result = service.execute(new CreateUserCommand("john", "john@example.com"));

        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

**3. Integration Tests (con Testcontainers):**
```java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine");

    @Autowired MockMvc mockMvc;

    @Test
    void shouldCreateUserViaRestApi() throws Exception {
        mockMvc.perform(post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("""
                {"username": "john", "email": "john@example.com"}
                """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("john"));
    }
}
```

**Naming Convention:**
- Unit tests: `{Class}Test.java`
- Integration tests: `{Class}IntegrationTest.java`

---

## Checklist de ValidaciÃ³n

### Antes de Generar/Modificar CÃ³digo

**VERIFICAR:**

#### Arquitectura
- [ ] Â¿La clase estÃ¡ en la capa correcta (Domain/Application/Infrastructure)?
- [ ] Â¿Las dependencias apuntan en la direcciÃ³n correcta?
- [ ] Â¿El nombre sigue la convenciÃ³n de nomenclatura?
- [ ] Â¿La ubicaciÃ³n del archivo es correcta segÃºn el template?

#### Domain Layer
- [ ] Â¿Es Java puro (sin Spring, JPA, Jackson)?
- [ ] Â¿Los campos son `final`?
- [ ] Â¿Tiene factory methods `create()` y `reconstitute()`?
- [ ] Â¿Usa Value Objects (no primitivos)?
- [ ] Â¿Usa `Instant` para timestamps (no `LocalDateTime`)?
- [ ] Â¿Lombok solo para reducir boilerplate?

#### Application Layer
- [ ] Â¿Los Use Cases son interfaces?
- [ ] Â¿Los Commands/Queries son records?
- [ ] Â¿Los Services tienen `@Service` y `@Transactional`?
- [ ] Â¿Constructor injection (no `@Autowired` en campos)?
- [ ] Â¿No depende de Infrastructure?

#### Infrastructure Layer
- [ ] Â¿Los Controllers llaman a Use Cases (no a Repositories)?
- [ ] Â¿Los DTOs son records?
- [ ] Â¿Request DTOs tienen Bean Validation?
- [ ] Â¿Los Mappers son interfaces MapStruct?
- [ ] Â¿Las Entities son mutables (para JPA)?

#### Testing
- [ ] Â¿Domain tests sin frameworks?
- [ ] Â¿Application tests con mocks?
- [ ] Â¿Integration tests con Testcontainers?
- [ ] Â¿Naming convention correcta (*Test, *IntegrationTest)?

---

## Ejemplos Completos

### Crear una Nueva Entidad: `Order`

**1. Domain Layer:**
```
src/main/java/com/example/hexarch/order/domain/
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ Order.java                 # Aggregate Root
â”‚   â””â”€â”€ valueobject/
â”‚       â””â”€â”€ OrderNumber.java       # Value Object
â”œâ”€â”€ event/
â”‚   â””â”€â”€ OrderPlacedEvent.java      # Domain Event
â””â”€â”€ exception/
    â””â”€â”€ OrderNotFoundException.java
```

**2. Application Layer:**
```
src/main/java/com/example/hexarch/order/application/
â”œâ”€â”€ port/
â”‚   â”œâ”€â”€ input/
â”‚   â”‚   â”œâ”€â”€ PlaceOrderUseCase.java
â”‚   â”‚   â”œâ”€â”€ PlaceOrderCommand.java
â”‚   â”‚   â””â”€â”€ OrderResult.java
â”‚   â””â”€â”€ output/
â”‚       â””â”€â”€ OrderRepository.java
â””â”€â”€ service/
    â””â”€â”€ PlaceOrderService.java
```

**3. Infrastructure Layer:**
```
src/main/java/com/example/hexarch/order/infrastructure/adapter/
â”œâ”€â”€ input/
â”‚   â””â”€â”€ rest/
â”‚       â”œâ”€â”€ OrderController.java
â”‚       â”œâ”€â”€ dto/
â”‚       â”‚   â”œâ”€â”€ PlaceOrderRequest.java
â”‚       â”‚   â””â”€â”€ OrderResponse.java
â”‚       â””â”€â”€ mapper/
â”‚           â””â”€â”€ OrderRestMapper.java
â””â”€â”€ output/
    â””â”€â”€ persistence/
        â”œâ”€â”€ JpaOrderRepositoryAdapter.java
        â”œâ”€â”€ OrderEntity.java
        â”œâ”€â”€ SpringDataOrderRepository.java
        â””â”€â”€ mapper/
            â””â”€â”€ OrderEntityMapper.java
```

---

## Respuestas RÃ¡pidas a Consultas Comunes

### "Â¿DÃ³nde pongo este cÃ³digo?"
- LÃ³gica de negocio â†’ **Domain** (model)
- Validaciones de dominio â†’ **Value Object** o **Aggregate**
- Validaciones HTTP â†’ **Request DTO** (Bean Validation)
- OrquestaciÃ³n â†’ **Application** (Service)
- Persistencia â†’ **Infrastructure** (JPA Adapter)
- REST endpoints â†’ **Infrastructure** (Controller)
- Conversiones â†’ **Mapper** (MapStruct)

### "Â¿QuÃ© tipo de DTO uso?"
- Entrada HTTP â†’ `{Action}{Entity}Request` (record con Bean Validation)
- Entrada Application â†’ `{Action}{Entity}Command` (record sin validaciÃ³n)
- Salida Application â†’ `{Entity}Result` (record)
- Salida HTTP â†’ `{Entity}Response` (record)
- BD â†’ `{Entity}Entity` (clase mutable con JPA)
- Dominio â†’ `{Entity}` (clase inmutable)

### "Â¿CuÃ¡ndo usar `@Transactional`?"
- En Services de Application que modifican datos
- NO en Controllers
- NO en Repositories (Spring Data ya lo maneja)

### "Â¿String o Value Object?"
- Si tiene validaciÃ³n â†’ **Value Object**
- Si es concepto de dominio â†’ **Value Object**
- Si es solo transporte de datos â†’ **String** (en DTOs)

### "Â¿Instant o LocalDateTime?"
- Para timestamps de sistema/auditorÃ­a â†’ **Instant** (UTC)
- Para fechas de negocio sin zona horaria â†’ **LocalDateTime**
- Para fechas con zona horaria â†’ **ZonedDateTime**

---

## Comandos Maven Ãštiles

```bash
# Build (excluye integration tests)
./mvnw clean install

# Solo unit tests
./mvnw test

# Todos los tests (requiere Docker)
./mvnw test -Pintegration-tests

# Run application
./mvnw spring-boot:run
```

---

## Errores Comunes a Evitar

1. âŒ Poner `@Entity` en clases del Domain â†’ Usar `UserEntity` en Infrastructure
2. âŒ Controller llama a Repository directamente â†’ Llamar a UseCase
3. âŒ Service devuelve Domain Object â†’ Devolver Result DTO
4. âŒ Usar `LocalDateTime` para timestamps â†’ Usar `Instant`
5. âŒ Value Object mutable â†’ Debe ser `final` e inmutable
6. âŒ Factory method `create()` sin validaciÃ³n â†’ Validar en Value Objects
7. âŒ `@Autowired` en campos â†’ Constructor injection
8. âŒ Domain depende de Spring â†’ Solo Lombok permitido

---

## Fin de Guidelines

**RECUERDA:** Estas reglas NO son sugerencias, son **OBLIGATORIAS**. Si generas cÃ³digo que viole estas reglas, el proyecto no compilarÃ¡ o fallarÃ¡ en los tests de arquitectura.

**Ante cualquier duda:** Revisa los ejemplos completos en el proyecto existente y sigue el patrÃ³n al pie de la letra.

**Prioridades:**
1. Respeta la Dependency Rule (lo mÃ¡s importante)
2. Sigue la nomenclatura exacta
3. Usa los patrones de implementaciÃ³n
4. Coloca archivos en ubicaciones correctas
5. Escribe tests adecuados

---

**VersiÃ³n de Guidelines:** 1.0
**Ãšltima actualizaciÃ³n:** 2025-01-15
