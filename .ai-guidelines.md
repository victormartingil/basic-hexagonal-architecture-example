# AI Guidelines - Hexagonal Architecture Project

> **PROPÓSITO:** Este archivo contiene las reglas arquitecturales, patrones y convenciones que DEBES seguir cuando generes, modifiques o sugieras código para este proyecto. Lee este archivo completo antes de hacer cualquier cambio.

---

## 📋 Tabla de Contenidos

1. [Arquitectura General](#arquitectura-general)
2. [Reglas de Dependencias](#reglas-de-dependencias)
3. [Estructura de Directorios](#estructura-de-directorios)
4. [Nomenclatura Obligatoria](#nomenclatura-obligatoria)
5. [Patrones de Implementación](#patrones-de-implementación)
6. [Tecnologías y Frameworks](#tecnologías-y-frameworks)
7. [Testing](#testing)
8. [Checklist de Validación](#checklist-de-validación)

---

## Arquitectura General

### Paradigma: Hexagonal Architecture (Ports & Adapters) + DDD + CQRS ligero

Este proyecto sigue una arquitectura hexagonal estricta con 3 capas claramente separadas:

```
┌─────────────────────────────────────────────────────────┐
│                    INFRASTRUCTURE                        │
│  (Spring, JPA, REST, Kafka, etc.)                        │
│  - Adapters (input: REST, output: JPA, Events)          │
│  - DTOs: Request, Response, Entity                       │
│  - Mappers: MapStruct                                    │
│  - Configuration: Spring Beans, Exception Handlers       │
└──────────────────────┬──────────────────────────────────┘
                       │ depends on (implements ports)
┌──────────────────────▼──────────────────────────────────┐
│                    APPLICATION                           │
│  (Use Cases, Orchestration)                              │
│  - Ports: Input (UseCases), Output (Repositories)       │
│  - Services: Implement UseCases                          │
│  - DTOs: Command, Query, Result                          │
└──────────────────────┬──────────────────────────────────┘
                       │ depends on (uses domain)
┌──────────────────────▼──────────────────────────────────┐
│                       DOMAIN                             │
│  (Business Logic, Pure Java + Lombok)                    │
│  - Model: Aggregates, Entities, Value Objects           │
│  - Events: Domain Events (records)                       │
│  - Exceptions: Domain Exceptions                         │
│  - NO FRAMEWORKS (solo Lombok para reducir boilerplate) │
└─────────────────────────────────────────────────────────┘
```

---

## Reglas de Dependencias

### 🚫 PROHIBIDO (Dependency Rule Violations)

1. ❌ **Domain NO PUEDE depender de Application o Infrastructure**
   - ❌ No imports de Spring en Domain
   - ❌ No imports de JPA (@Entity) en Domain
   - ❌ No imports de Jackson en Domain
   - ✅ Solo: Java core, Lombok, y otros paquetes del Domain

2. ❌ **Application NO PUEDE depender de Infrastructure**
   - ❌ No imports de Controllers en Application
   - ❌ No imports de JPA Entities en Application
   - ❌ No imports de implementaciones concretas (adapters)
   - ✅ Solo: Domain, interfaces propias (ports), y Spring básico (@Service, @Transactional)

3. ❌ **Controllers NO PUEDEN llamar a Repositories directamente**
   - ❌ Controller → Repository (bypass de Application layer)
   - ✅ Controller → UseCase → Repository

### ✅ PERMITIDO (Correct Dependencies)

```
Infrastructure → Application ✅
Infrastructure → Domain     ✅
Application    → Domain     ✅
```

---

## Estructura de Directorios

### Template de Carpetas (RESPETAR ESTRICTAMENTE)

```
src/main/java/com/example/hexarch/
│
├── {bounded-context}/              # ej: user, order, payment
│   │
│   ├── domain/                     # CAPA 1: DOMINIO
│   │   ├── model/
│   │   │   ├── {Aggregate}.java           # ej: User.java
│   │   │   └── valueobject/
│   │   │       ├── {ValueObject}.java     # ej: Email.java, Username.java
│   │   ├── event/
│   │   │   └── {Entity}{Action}Event.java # ej: UserCreatedEvent.java
│   │   └── exception/
│   │       ├── DomainException.java
│   │       ├── ValidationException.java
│   │       └── {Entity}AlreadyExistsException.java
│   │
│   ├── application/                # CAPA 2: APLICACIÓN
│   │   ├── port/
│   │   │   ├── input/              # LO QUE LA APP OFRECE
│   │   │   │   ├── {Action}{Entity}UseCase.java    # ej: CreateUserUseCase.java
│   │   │   │   ├── {Action}{Entity}Command.java    # ej: CreateUserCommand.java
│   │   │   │   ├── Get{Entity}Query.java           # ej: GetUserQuery.java (CQRS)
│   │   │   │   └── {Entity}Result.java             # ej: UserResult.java
│   │   │   └── output/             # LO QUE LA APP NECESITA
│   │   │       ├── {Entity}Repository.java         # ej: UserRepository.java
│   │   │       └── {Entity}EventPublisher.java     # ej: UserEventPublisher.java
│   │   └── service/
│   │       ├── {Action}{Entity}Service.java        # ej: CreateUserService.java
│   │       └── Get{Entity}QueryHandler.java        # ej: GetUserQueryHandler.java (CQRS)
│   │
│   └── infrastructure/             # CAPA 3: INFRAESTRUCTURA
│       └── adapter/
│           ├── input/              # ADAPTADORES DE ENTRADA
│           │   └── rest/
│           │       ├── {Entity}Controller.java     # ej: UserController.java
│           │       ├── dto/
│           │       │   ├── {Action}{Entity}Request.java   # ej: CreateUserRequest.java
│           │       │   └── {Entity}Response.java          # ej: UserResponse.java
│           │       └── mapper/
│           │           └── {Entity}RestMapper.java        # ej: UserRestMapper.java
│           └── output/             # ADAPTADORES DE SALIDA
│               ├── persistence/
│               │   ├── Jpa{Entity}RepositoryAdapter.java  # ej: JpaUserRepositoryAdapter.java
│               │   ├── {Entity}Entity.java                # ej: UserEntity.java
│               │   ├── SpringData{Entity}Repository.java  # ej: SpringDataUserRepository.java
│               │   └── mapper/
│               │       └── {Entity}EntityMapper.java      # ej: UserEntityMapper.java
│               └── event/
│                   └── {Technology}{Entity}EventPublisherAdapter.java  # ej: KafkaUserEventPublisherAdapter.java
│
└── shared/                         # CÓDIGO COMPARTIDO
    └── infrastructure/
        └── exception/
            ├── GlobalExceptionHandler.java
            └── ErrorResponse.java
```

### Reglas de Ubicación

1. **Bounded Contexts**: Cada módulo de negocio (user, order, payment) tiene su propia carpeta raíz
2. **NO mezclar capas**: Cada archivo va EXACTAMENTE en su carpeta correspondiente
3. **NO crear subcarpetas adicionales** sin justificación arquitectural
4. **Shared solo para infraestructura común** (exception handling, config, etc.)

---

## Nomenclatura Obligatoria

### Tabla de Nomenclatura (SEGUIR AL PIE DE LA LETRA)

| Capa | Tipo | Patrón | Ejemplo | Ubicación |
|------|------|--------|---------|-----------|
| **Application (Input)** | Use Case Interface | `{Action}{Entity}UseCase` | `CreateUserUseCase` | `application/port/input/` |
| **Application (Input)** | Command | `{Action}{Entity}Command` | `CreateUserCommand` | `application/port/input/` |
| **Application (Input)** | Query | `Get{Entity}Query` | `GetUserQuery` | `application/port/input/` |
| **Application (Input)** | Result | `{Entity}Result` | `UserResult` | `application/port/input/` |
| **Application (Output)** | Repository Interface | `{Entity}Repository` | `UserRepository` | `application/port/output/` |
| **Application (Output)** | Event Publisher Interface | `{Entity}EventPublisher` | `UserEventPublisher` | `application/port/output/` |
| **Application (Service)** | Service Implementation | `{Action}{Entity}Service` | `CreateUserService` | `application/service/` |
| **Application (Service)** | Query Handler | `Get{Entity}QueryHandler` | `GetUserQueryHandler` | `application/service/` |
| **Domain** | Aggregate Root | `{Entity}` | `User` | `domain/model/` |
| **Domain** | Value Object | `{Concept}` | `Email`, `Username` | `domain/model/valueobject/` |
| **Domain** | Domain Event | `{Entity}{Action}Event` | `UserCreatedEvent` | `domain/event/` |
| **Domain** | Domain Exception | `{Entity}{Reason}Exception` | `UserAlreadyExistsException` | `domain/exception/` |
| **Infrastructure (Input)** | Controller | `{Entity}Controller` | `UserController` | `infrastructure/adapter/input/rest/` |
| **Infrastructure (Input)** | Request DTO | `{Action}{Entity}Request` | `CreateUserRequest` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | Response DTO | `{Entity}Response` | `UserResponse` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | REST Mapper | `{Entity}RestMapper` | `UserRestMapper` | `infrastructure/adapter/input/rest/mapper/` |
| **Infrastructure (Output)** | JPA Entity | `{Entity}Entity` | `UserEntity` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Repository Adapter | `Jpa{Entity}RepositoryAdapter` | `JpaUserRepositoryAdapter` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Spring Data Repo | `SpringData{Entity}Repository` | `SpringDataUserRepository` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Entity Mapper | `{Entity}EntityMapper` | `UserEntityMapper` | `infrastructure/adapter/output/persistence/mapper/` |
| **Infrastructure (Output)** | Event Publisher Adapter | `{Tech}{Entity}EventPublisherAdapter` | `KafkaUserEventPublisherAdapter` | `infrastructure/adapter/output/event/` |

### Reglas de Naming

1. **PascalCase** para nombres de clases: `CreateUserService`
2. **camelCase** para métodos y variables: `createUser()`, `userResult`
3. **UPPER_SNAKE_CASE** para constantes: `MAX_USERNAME_LENGTH`
4. **Verbos para métodos**: `create()`, `save()`, `find()`, `execute()`
5. **Sustantivos para clases**: `User`, `Email`, `UserController`

---

## Patrones de Implementación

### 1. Domain Layer (Aggregate Roots, Entities)

**SIEMPRE seguir este patrón:**

```java
package com.example.hexarch.user.domain.model;

import com.example.hexarch.user.domain.model.valueobject.Email;
import com.example.hexarch.user.domain.model.valueobject.Username;
import lombok.*;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Aggregate Root
 *
 * REGLAS:
 * - Inmutable (final fields, sin setters)
 * - Factory methods: create() para nuevo, reconstitute() para existente
 * - Métodos de negocio devuelven nueva instancia
 * - Usa Value Objects (no primitivos)
 * - Sin anotaciones de frameworks (solo Lombok)
 */
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class User {

    @EqualsAndHashCode.Include
    private final UUID id;
    private final Username username;  // Value Object
    private final Email email;        // Value Object
    private final boolean enabled;
    private final Instant createdAt;  // SIEMPRE Instant (no LocalDateTime)

    /**
     * Factory Method - Crear nuevo
     */
    public static User create(String username, String email) {
        return new User(
            UUID.randomUUID(),
            Username.of(username),
            Email.of(email),
            true,
            Instant.now()
        );
    }

    /**
     * Factory Method - Reconstruir existente
     */
    public static User reconstitute(UUID id, String username, String email,
                                     boolean enabled, Instant createdAt) {
        return new User(
            id,
            Username.of(username),
            Email.of(email),
            enabled,
            createdAt
        );
    }

    /**
     * Método de negocio - Devuelve nueva instancia (inmutabilidad)
     */
    public User disable() {
        return new User(this.id, this.username, this.email, false, this.createdAt);
    }
}
```

**CHECKLIST Domain:**
- [ ] Clase con Lombok: `@Getter`, `@EqualsAndHashCode(onlyExplicitlyIncluded = true)`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Campos `final`
- [ ] Sin setters públicos
- [ ] Factory method `create()` para nuevos
- [ ] Factory method `reconstitute()` para existentes
- [ ] Métodos de negocio devuelven nueva instancia
- [ ] Usa Value Objects (no String/int directos)
- [ ] Usa `Instant` para timestamps (NO `LocalDateTime`)
- [ ] `equals/hashCode` solo en el ID (agregar `@EqualsAndHashCode.Include` al ID)

---

### 2. Value Objects

**SIEMPRE seguir este patrón:**

```java
package com.example.hexarch.user.domain.model.valueobject;

import com.example.hexarch.user.domain.exception.ValidationException;
import lombok.*;

import java.util.regex.Pattern;

/**
 * DOMAIN LAYER - Value Object
 *
 * REGLAS:
 * - Inmutable (final class, final field)
 * - Auto-valida en el constructor
 * - Factory method: of(String)
 * - Sin setters
 * - Equals por valor (no por identidad)
 */
@Getter
@EqualsAndHashCode
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class Email {

    private static final Pattern EMAIL_PATTERN =
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");

    private final String value;

    /**
     * Factory Method - Crea y valida
     */
    public static Email of(String value) {
        validate(value);
        return new Email(value);
    }

    private static void validate(String value) {
        if (value == null || value.isBlank()) {
            throw new ValidationException("EMAIL_001", "Email no puede estar vacío");
        }
        if (!EMAIL_PATTERN.matcher(value).matches()) {
            throw new ValidationException("EMAIL_002", "Formato de email inválido");
        }
    }
}
```

**CHECKLIST Value Object:**
- [ ] Clase `final`
- [ ] Campo `final`
- [ ] Sin setters
- [ ] Factory method `of(String)` que valida
- [ ] Validación en método privado `validate()`
- [ ] Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Lanza `ValidationException` con código de error

---

### 3. Domain Events

**SIEMPRE usar records:**

```java
package com.example.hexarch.user.domain.event;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Domain Event
 *
 * REGLAS:
 * - Siempre record (inmutable)
 * - Nombrado en PASADO: {Entity}{Action}Event
 * - Contiene Instant occurredAt
 * - Factory method: from()
 */
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}
```

**CHECKLIST Domain Event:**
- [ ] Es un `record`
- [ ] Nombrado en pasado: `{Entity}{Action}Event`
- [ ] Tiene campo `Instant occurredAt`
- [ ] Factory method `from()` que genera `occurredAt`

---

### 4. Application Layer (Use Cases)

**Patrón Interface + Implementation:**

```java
// Interface (Input Port)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Input Port (Use Case)
 *
 * REGLAS:
 * - Interface pura
 * - Método execute() con Command/Query
 * - Retorna Result
 */
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Command (DTO)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Command (CQRS Write)
 *
 * REGLAS:
 * - Siempre record
 * - Solo datos primitivos o inmutables
 * - Sin lógica
 */
public record CreateUserCommand(String username, String email) {}

// Result (DTO)
package com.example.hexarch.user.application.port.input;

import java.time.Instant;
import java.util.UUID;

/**
 * APPLICATION LAYER - Result
 *
 * REGLAS:
 * - Siempre record
 * - Datos primitivos o Instant (NO Value Objects)
 */
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Service (Implementation)
package com.example.hexarch.user.application.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * APPLICATION LAYER - Service (Use Case Implementation)
 *
 * REGLAS:
 * - Implementa UseCase interface
 * - @Service + @Transactional
 * - Constructor injection (no @Autowired)
 * - Orquesta dominio y output ports
 */
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // Constructor injection (preferido)
    public CreateUserService(UserRepository userRepository,
                             UserEventPublisher userEventPublisher) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 1. Validar precondiciones
        if (userRepository.existsByUsername(command.username())) {
            throw new UserAlreadyExistsException(command.username());
        }

        // 2. Crear dominio
        User user = User.create(command.username(), command.email());

        // 3. Persistir
        User savedUser = userRepository.save(user);

        // 4. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 5. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

**CHECKLIST Application Service:**
- [ ] Implementa UseCase interface
- [ ] Anotado con `@Service` y `@Transactional`
- [ ] Constructor injection (NO `@Autowired` en campos)
- [ ] Flujo: validar → crear dominio → persistir → publicar evento → retornar
- [ ] Extrae valores de Value Objects antes de retornar (`.getValue()`)

---

### 5. Infrastructure Layer (Adapters)

**Controller (Input Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

/**
 * INFRASTRUCTURE LAYER - REST Controller
 *
 * REGLAS:
 * - @RestController + @RequestMapping
 * - Constructor injection
 * - Usa UseCase (NO Repository)
 * - Mapea Request ↔ Command y Result ↔ Response
 */
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    private final CreateUserUseCase createUserUseCase;
    private final UserRestMapper mapper;

    public UserController(CreateUserUseCase createUserUseCase,
                          UserRestMapper mapper) {
        this.createUserUseCase = createUserUseCase;
        this.mapper = mapper;
    }

    @PostMapping
    public ResponseEntity<UserResponse> createUser(
        @Valid @RequestBody CreateUserRequest request
    ) {
        // 1. Mapear Request → Command
        CreateUserCommand command = mapper.toCommand(request);

        // 2. Ejecutar UseCase
        UserResult result = createUserUseCase.execute(command);

        // 3. Mapear Result → Response
        UserResponse response = mapper.toResponse(result);

        // 4. Retornar HTTP
        return ResponseEntity.status(201).body(response);
    }
}
```

**Request/Response DTOs (siempre records):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.dto;

import jakarta.validation.constraints.*;

/**
 * INFRASTRUCTURE LAYER - REST Request DTO
 *
 * REGLAS:
 * - Siempre record
 * - Bean Validation: @NotBlank, @Email, @Size, etc.
 */
public record CreateUserRequest(
    @NotBlank(message = "Username no puede estar vacío")
    @Size(min = 3, max = 50, message = "Username debe tener entre 3 y 50 caracteres")
    String username,

    @NotBlank(message = "Email no puede estar vacío")
    @Email(message = "Email debe tener formato válido")
    String email
) {}

public record UserResponse(
    String id,           // UUID como String
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

**Repository Adapter (Output Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - Repository Adapter
 *
 * REGLAS:
 * - @Repository
 * - Implementa interface de Application
 * - Constructor injection
 * - Delega a Spring Data Repository
 * - Mapea Entity ↔ Domain
 */
@Repository
public class JpaUserRepositoryAdapter implements UserRepository {

    private final SpringDataUserRepository springDataRepo;
    private final UserEntityMapper mapper;

    public JpaUserRepositoryAdapter(SpringDataUserRepository springDataRepo,
                                     UserEntityMapper mapper) {
        this.springDataRepo = springDataRepo;
        this.mapper = mapper;
    }

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        UserEntity savedEntity = springDataRepo.save(entity);
        return mapper.toDomain(savedEntity);
    }

    @Override
    public Optional<User> findById(UUID id) {
        return springDataRepo.findById(id)
            .map(mapper::toDomain);
    }
}
```

**JPA Entity:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import jakarta.persistence.*;
import lombok.*;
import java.time.Instant;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - JPA Entity
 *
 * REGLAS:
 * - @Entity, @Table
 * - Mutable (tiene setters para JPA)
 * - NO es el modelo de dominio
 * - Lombok: @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor
 */
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {

    @Id
    private UUID id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
}
```

---

### 6. Mappers (MapStruct)

**SIEMPRE usar MapStruct:**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.mapper;

import org.mapstruct.*;

/**
 * INFRASTRUCTURE LAYER - REST Mapper
 *
 * REGLAS:
 * - @Mapper(componentModel = "spring")
 * - Métodos: toCommand(), toResponse()
 * - Conversiones de tipos (UUID ↔ String)
 */
@Mapper(componentModel = "spring")
public interface UserRestMapper {

    CreateUserCommand toCommand(CreateUserRequest request);

    @Mapping(target = "id", source = "id", qualifiedByName = "uuidToString")
    UserResponse toResponse(UserResult result);

    @Named("uuidToString")
    default String uuidToString(UUID uuid) {
        return uuid != null ? uuid.toString() : null;
    }
}
```

**CHECKLIST Mapper:**
- [ ] Interface (no clase)
- [ ] `@Mapper(componentModel = "spring")`
- [ ] Métodos claros: `toCommand()`, `toResponse()`, `toDomain()`, `toEntity()`
- [ ] Custom mappings con `@Mapping` y `@Named`

---

## Tecnologías y Frameworks

### Versiones Obligatorias

```xml
<properties>
    <java.version>21</java.version>
    <spring-boot.version>3.5.7</spring-boot.version>
    <mapstruct.version>1.6.3</mapstruct.version>
</properties>
```

### Dependencias Permitidas

**Domain Layer:**
- ✅ Java 21 core
- ✅ Lombok (solo para reducir boilerplate)
- ❌ NO Spring
- ❌ NO JPA
- ❌ NO Jackson

**Application Layer:**
- ✅ Domain
- ✅ Spring Core (`@Service`, `@Transactional`)
- ❌ NO Spring Web
- ❌ NO JPA

**Infrastructure Layer:**
- ✅ Application
- ✅ Domain
- ✅ Spring Boot (web, data-jpa, validation)
- ✅ PostgreSQL
- ✅ Flyway
- ✅ MapStruct
- ✅ Lombok

### Anotaciones por Capa

**Domain:**
- ✅ Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor`
- ❌ NO Spring annotations

**Application:**
- ✅ `@Service`
- ✅ `@Transactional`
- ❌ NO `@RestController`, `@Entity`

**Infrastructure:**
- ✅ `@RestController`, `@RequestMapping`
- ✅ `@Repository`, `@Entity`, `@Table`
- ✅ `@Mapper` (MapStruct)
- ✅ `@Valid`, `@NotBlank`, `@Email`

---

## Testing

### Tipos de Tests

**1. Domain Tests (Unit Tests):**
```java
// NO frameworks, solo JUnit + AssertJ
class UserTest {
    @Test
    void shouldCreateUserWithEnabledTrue() {
        User user = User.create("john", "john@example.com");
        assertTrue(user.isEnabled());
    }
}
```

**2. Application Tests (Unit Tests con Mocks):**
```java
@ExtendWith(MockitoExtension.class)
class CreateUserServiceTest {
    @Mock UserRepository userRepository;
    @Mock UserEventPublisher eventPublisher;
    @InjectMocks CreateUserService service;

    @Test
    void shouldCreateUser() {
        when(userRepository.existsByUsername(anyString())).thenReturn(false);
        when(userRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        UserResult result = service.execute(new CreateUserCommand("john", "john@example.com"));

        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

**3. Integration Tests (con Testcontainers):**
```java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine");

    @Autowired MockMvc mockMvc;

    @Test
    void shouldCreateUserViaRestApi() throws Exception {
        mockMvc.perform(post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("""
                {"username": "john", "email": "john@example.com"}
                """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("john"));
    }
}
```

**Naming Convention:**
- Unit tests: `{Class}Test.java`
- Integration tests: `{Class}IntegrationTest.java`

---

## Checklist de Validación

### Antes de Generar/Modificar Código

**VERIFICAR:**

#### Arquitectura
- [ ] ¿La clase está en la capa correcta (Domain/Application/Infrastructure)?
- [ ] ¿Las dependencias apuntan en la dirección correcta?
- [ ] ¿El nombre sigue la convención de nomenclatura?
- [ ] ¿La ubicación del archivo es correcta según el template?

#### Domain Layer
- [ ] ¿Es Java puro (sin Spring, JPA, Jackson)?
- [ ] ¿Los campos son `final`?
- [ ] ¿Tiene factory methods `create()` y `reconstitute()`?
- [ ] ¿Usa Value Objects (no primitivos)?
- [ ] ¿Usa `Instant` para timestamps (no `LocalDateTime`)?
- [ ] ¿Lombok solo para reducir boilerplate?

#### Application Layer
- [ ] ¿Los Use Cases son interfaces?
- [ ] ¿Los Commands/Queries son records?
- [ ] ¿Los Services tienen `@Service` y `@Transactional`?
- [ ] ¿Constructor injection (no `@Autowired` en campos)?
- [ ] ¿No depende de Infrastructure?

#### Infrastructure Layer
- [ ] ¿Los Controllers llaman a Use Cases (no a Repositories)?
- [ ] ¿Los DTOs son records?
- [ ] ¿Request DTOs tienen Bean Validation?
- [ ] ¿Los Mappers son interfaces MapStruct?
- [ ] ¿Las Entities son mutables (para JPA)?

#### Testing
- [ ] ¿Domain tests sin frameworks?
- [ ] ¿Application tests con mocks?
- [ ] ¿Integration tests con Testcontainers?
- [ ] ¿Naming convention correcta (*Test, *IntegrationTest)?

---

## Ejemplos Completos

### Crear una Nueva Entidad: `Order`

**1. Domain Layer:**
```
src/main/java/com/example/hexarch/order/domain/
├── model/
│   ├── Order.java                 # Aggregate Root
│   └── valueobject/
│       └── OrderNumber.java       # Value Object
├── event/
│   └── OrderPlacedEvent.java      # Domain Event
└── exception/
    └── OrderNotFoundException.java
```

**2. Application Layer:**
```
src/main/java/com/example/hexarch/order/application/
├── port/
│   ├── input/
│   │   ├── PlaceOrderUseCase.java
│   │   ├── PlaceOrderCommand.java
│   │   └── OrderResult.java
│   └── output/
│       └── OrderRepository.java
└── service/
    └── PlaceOrderService.java
```

**3. Infrastructure Layer:**
```
src/main/java/com/example/hexarch/order/infrastructure/adapter/
├── input/
│   └── rest/
│       ├── OrderController.java
│       ├── dto/
│       │   ├── PlaceOrderRequest.java
│       │   └── OrderResponse.java
│       └── mapper/
│           └── OrderRestMapper.java
└── output/
    └── persistence/
        ├── JpaOrderRepositoryAdapter.java
        ├── OrderEntity.java
        ├── SpringDataOrderRepository.java
        └── mapper/
            └── OrderEntityMapper.java
```

---

## Respuestas Rápidas a Consultas Comunes

### "¿Dónde pongo este código?"
- Lógica de negocio → **Domain** (model)
- Validaciones de dominio → **Value Object** o **Aggregate**
- Validaciones HTTP → **Request DTO** (Bean Validation)
- Orquestación → **Application** (Service)
- Persistencia → **Infrastructure** (JPA Adapter)
- REST endpoints → **Infrastructure** (Controller)
- Conversiones → **Mapper** (MapStruct)

### "¿Qué tipo de DTO uso?"
- Entrada HTTP → `{Action}{Entity}Request` (record con Bean Validation)
- Entrada Application → `{Action}{Entity}Command` (record sin validación)
- Salida Application → `{Entity}Result` (record)
- Salida HTTP → `{Entity}Response` (record)
- BD → `{Entity}Entity` (clase mutable con JPA)
- Dominio → `{Entity}` (clase inmutable)

### "¿Cuándo usar `@Transactional`?"
- En Services de Application que modifican datos
- NO en Controllers
- NO en Repositories (Spring Data ya lo maneja)

### "¿String o Value Object?"
- Si tiene validación → **Value Object**
- Si es concepto de dominio → **Value Object**
- Si es solo transporte de datos → **String** (en DTOs)

### "¿Instant o LocalDateTime?"
- Para timestamps de sistema/auditoría → **Instant** (UTC)
- Para fechas de negocio sin zona horaria → **LocalDateTime**
- Para fechas con zona horaria → **ZonedDateTime**

---

## Comandos Maven Útiles

```bash
# Build (excluye integration tests)
./mvnw clean install

# Solo unit tests
./mvnw test

# Todos los tests (requiere Docker)
./mvnw test -Pintegration-tests

# Run application
./mvnw spring-boot:run
```

---

## Errores Comunes a Evitar

1. ❌ Poner `@Entity` en clases del Domain → Usar `UserEntity` en Infrastructure
2. ❌ Controller llama a Repository directamente → Llamar a UseCase
3. ❌ Service devuelve Domain Object → Devolver Result DTO
4. ❌ Usar `LocalDateTime` para timestamps → Usar `Instant`
5. ❌ Value Object mutable → Debe ser `final` e inmutable
6. ❌ Factory method `create()` sin validación → Validar en Value Objects
7. ❌ `@Autowired` en campos → Constructor injection
8. ❌ Domain depende de Spring → Solo Lombok permitido

---

## Fin de Guidelines

**RECUERDA:** Estas reglas NO son sugerencias, son **OBLIGATORIAS**. Si generas código que viole estas reglas, el proyecto no compilará o fallará en los tests de arquitectura.

**Ante cualquier duda:** Revisa los ejemplos completos en el proyecto existente y sigue el patrón al pie de la letra.

**Prioridades:**
1. Respeta la Dependency Rule (lo más importante)
2. Sigue la nomenclatura exacta
3. Usa los patrones de implementación
4. Coloca archivos en ubicaciones correctas
5. Escribe tests adecuados

---

**Versión de Guidelines:** 1.0
**Última actualización:** 2025-01-15
