# AI Guidelines - Hexagonal Architecture Project

> **PROPÓSITO:** Este archivo contiene las reglas arquitecturales, patrones y convenciones que DEBES seguir cuando generes, modifiques o sugieras código para este proyecto. Lee este archivo completo antes de hacer cualquier cambio.

---

## 📋 Tabla de Contenidos

1. [Arquitectura General](#arquitectura-general)
2. [Reglas de Dependencias](#reglas-de-dependencias)
3. [Estructura de Directorios](#estructura-de-directorios)
4. [Nomenclatura Obligatoria](#nomenclatura-obligatoria)
5. [Patrones de Implementación](#patrones-de-implementación)
6. [Tecnologías y Frameworks](#tecnologías-y-frameworks)
7. [Testing](#testing)
8. [Checklist de Validación](#checklist-de-validación)
9. [Observabilidad: Logs, Métricas y Trazas](#9-observabilidad-logs-métricas-y-trazas)
10. [Spring Security + JWT Authentication & Authorization](#10-spring-security--jwt-authentication--authorization)

---

## Arquitectura General

### Paradigma: Hexagonal Architecture (Ports & Adapters) + DDD + CQRS ligero

Este proyecto sigue una arquitectura hexagonal estricta con 3 capas claramente separadas:

```
┌─────────────────────────────────────────────────────────┐
│                    INFRASTRUCTURE                        │
│  (Spring, JPA, REST, Kafka, etc.)                        │
│  - Adapters (input: REST, output: JPA, Events)          │
│  - DTOs: Request, Response, Entity                       │
│  - Mappers: MapStruct                                    │
│  - Configuration: Spring Beans, Exception Handlers       │
└──────────────────────┬──────────────────────────────────┘
                       │ depends on (implements ports)
┌──────────────────────▼──────────────────────────────────┐
│                    APPLICATION                           │
│  (Use Cases, Orchestration)                              │
│  - Ports: Input (UseCases), Output (Repositories)       │
│  - Services: Implement UseCases                          │
│  - DTOs: Command, Query, Result                          │
└──────────────────────┬──────────────────────────────────┘
                       │ depends on (uses domain)
┌──────────────────────▼──────────────────────────────────┐
│                       DOMAIN                             │
│  (Business Logic, Pure Java + Lombok)                    │
│  - Model: Aggregates, Entities, Value Objects           │
│  - Events: Domain Events (records)                       │
│  - Exceptions: Domain Exceptions                         │
│  - NO FRAMEWORKS (solo Lombok para reducir boilerplate) │
└─────────────────────────────────────────────────────────┘
```

---

## Reglas de Dependencias

### 🚫 PROHIBIDO (Dependency Rule Violations)

1. ❌ **Domain NO PUEDE depender de Application o Infrastructure**
   - ❌ No imports de Spring en Domain
   - ❌ No imports de JPA (@Entity) en Domain
   - ❌ No imports de Jackson en Domain
   - ✅ Solo: Java core, Lombok, y otros paquetes del Domain

2. ❌ **Application NO PUEDE depender de Infrastructure**
   - ❌ No imports de Controllers en Application
   - ❌ No imports de JPA Entities en Application
   - ❌ No imports de implementaciones concretas (adapters)
   - ✅ Solo: Domain, interfaces propias (ports), y Spring básico (@Service, @Transactional)

3. ❌ **Controllers NO PUEDEN llamar a Repositories directamente**
   - ❌ Controller → Repository (bypass de Application layer)
   - ✅ Controller → UseCase → Repository

### ✅ PERMITIDO (Correct Dependencies)

```
Infrastructure → Application ✅
Infrastructure → Domain     ✅
Application    → Domain     ✅
```

---

## Estructura de Directorios

### Template de Carpetas (RESPETAR ESTRICTAMENTE)

```
src/main/java/com/example/hexarch/
│
├── {bounded-context}/              # ej: user, order, payment
│   │
│   ├── domain/                     # CAPA 1: DOMINIO
│   │   ├── model/
│   │   │   ├── {Aggregate}.java           # ej: User.java
│   │   │   └── valueobject/
│   │   │       ├── {ValueObject}.java     # ej: Email.java, Username.java
│   │   ├── event/
│   │   │   └── {Entity}{Action}Event.java # ej: UserCreatedEvent.java
│   │   └── exception/
│   │       ├── DomainException.java
│   │       ├── ValidationException.java
│   │       └── {Entity}AlreadyExistsException.java
│   │
│   ├── application/                # CAPA 2: APLICACIÓN
│   │   ├── port/
│   │   │   ├── input/              # LO QUE LA APP OFRECE
│   │   │   │   ├── {Action}{Entity}UseCase.java    # ej: CreateUserUseCase.java
│   │   │   │   ├── {Action}{Entity}Command.java    # ej: CreateUserCommand.java
│   │   │   │   ├── Get{Entity}Query.java           # ej: GetUserQuery.java (CQRS)
│   │   │   │   └── {Entity}Result.java             # ej: UserResult.java
│   │   │   └── output/             # LO QUE LA APP NECESITA
│   │   │       ├── {Entity}Repository.java         # ej: UserRepository.java
│   │   │       └── {Entity}EventPublisher.java     # ej: UserEventPublisher.java
│   │   └── service/
│   │       ├── {Action}{Entity}Service.java        # ej: CreateUserService.java
│   │       └── Get{Entity}QueryHandler.java        # ej: GetUserQueryHandler.java (CQRS)
│   │
│   └── infrastructure/             # CAPA 3: INFRAESTRUCTURA
│       └── adapter/
│           ├── input/              # ADAPTADORES DE ENTRADA
│           │   └── rest/
│           │       ├── {Entity}Controller.java     # ej: UserController.java
│           │       ├── dto/
│           │       │   ├── {Action}{Entity}Request.java   # ej: CreateUserRequest.java
│           │       │   └── {Entity}Response.java          # ej: UserResponse.java
│           │       └── mapper/
│           │           └── {Entity}RestMapper.java        # ej: UserRestMapper.java
│           └── output/             # ADAPTADORES DE SALIDA
│               ├── persistence/
│               │   ├── Jpa{Entity}RepositoryAdapter.java  # ej: JpaUserRepositoryAdapter.java
│               │   ├── {Entity}Entity.java                # ej: UserEntity.java
│               │   ├── SpringData{Entity}Repository.java  # ej: SpringDataUserRepository.java
│               │   └── mapper/
│               │       └── {Entity}EntityMapper.java      # ej: UserEntityMapper.java
│               └── event/
│                   └── {Technology}{Entity}EventPublisherAdapter.java  # ej: KafkaUserEventPublisherAdapter.java
│
└── shared/                         # CÓDIGO COMPARTIDO
    └── infrastructure/
        └── exception/
            ├── GlobalExceptionHandler.java
            └── ErrorResponse.java
```

### Reglas de Ubicación

1. **Bounded Contexts**: Cada módulo de negocio (user, order, payment) tiene su propia carpeta raíz
2. **NO mezclar capas**: Cada archivo va EXACTAMENTE en su carpeta correspondiente
3. **NO crear subcarpetas adicionales** sin justificación arquitectural
4. **Shared solo para infraestructura común** (exception handling, config, etc.)

---

## Nomenclatura Obligatoria

### Tabla de Nomenclatura (SEGUIR AL PIE DE LA LETRA)

| Capa | Tipo | Patrón | Ejemplo | Ubicación |
|------|------|--------|---------|-----------|
| **Application (Input)** | Use Case Interface | `{Action}{Entity}UseCase` | `CreateUserUseCase` | `application/port/input/` |
| **Application (Input)** | Command | `{Action}{Entity}Command` | `CreateUserCommand` | `application/port/input/` |
| **Application (Input)** | Query | `Get{Entity}Query` | `GetUserQuery` | `application/port/input/` |
| **Application (Input)** | Result | `{Entity}Result` | `UserResult` | `application/port/input/` |
| **Application (Output)** | Repository Interface | `{Entity}Repository` | `UserRepository` | `application/port/output/` |
| **Application (Output)** | Event Publisher Interface | `{Entity}EventPublisher` | `UserEventPublisher` | `application/port/output/` |
| **Application (Service)** | Service Implementation | `{Action}{Entity}Service` | `CreateUserService` | `application/service/` |
| **Application (Service)** | Query Handler | `Get{Entity}QueryHandler` | `GetUserQueryHandler` | `application/service/` |
| **Domain** | Aggregate Root | `{Entity}` | `User` | `domain/model/` |
| **Domain** | Value Object | `{Concept}` | `Email`, `Username` | `domain/model/valueobject/` |
| **Domain** | Domain Event | `{Entity}{Action}Event` | `UserCreatedEvent` | `domain/event/` |
| **Domain** | Domain Exception | `{Entity}{Reason}Exception` | `UserAlreadyExistsException` | `domain/exception/` |
| **Infrastructure (Input)** | Controller | `{Entity}Controller` | `UserController` | `infrastructure/adapter/input/rest/` |
| **Infrastructure (Input)** | Request DTO | `{Action}{Entity}Request` | `CreateUserRequest` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | Response DTO | `{Entity}Response` | `UserResponse` | `infrastructure/adapter/input/rest/dto/` |
| **Infrastructure (Input)** | REST Mapper | `{Entity}RestMapper` | `UserRestMapper` | `infrastructure/adapter/input/rest/mapper/` |
| **Infrastructure (Output)** | JPA Entity | `{Entity}Entity` | `UserEntity` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Repository Adapter | `Jpa{Entity}RepositoryAdapter` | `JpaUserRepositoryAdapter` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Spring Data Repo | `SpringData{Entity}Repository` | `SpringDataUserRepository` | `infrastructure/adapter/output/persistence/` |
| **Infrastructure (Output)** | Entity Mapper | `{Entity}EntityMapper` | `UserEntityMapper` | `infrastructure/adapter/output/persistence/mapper/` |
| **Infrastructure (Output)** | Event Publisher Adapter | `{Tech}{Entity}EventPublisherAdapter` | `KafkaUserEventPublisherAdapter` | `infrastructure/adapter/output/event/` |

### Reglas de Naming

1. **PascalCase** para nombres de clases: `CreateUserService`
2. **camelCase** para métodos y variables: `createUser()`, `userResult`
3. **UPPER_SNAKE_CASE** para constantes: `MAX_USERNAME_LENGTH`
4. **Verbos para métodos**: `create()`, `save()`, `find()`, `execute()`
5. **Sustantivos para clases**: `User`, `Email`, `UserController`

---

## Patrones de Implementación

### 1. Domain Layer (Aggregate Roots, Entities)

**SIEMPRE seguir este patrón:**

```java
package com.example.hexarch.user.domain.model;

import com.example.hexarch.user.domain.model.valueobject.Email;
import com.example.hexarch.user.domain.model.valueobject.Username;
import lombok.*;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Aggregate Root
 *
 * REGLAS:
 * - Inmutable (final fields, sin setters)
 * - Factory methods: create() para nuevo, reconstitute() para existente
 * - Métodos de negocio devuelven nueva instancia
 * - Usa Value Objects (no primitivos)
 * - Sin anotaciones de frameworks (solo Lombok)
 */
@Getter
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class User {

    @EqualsAndHashCode.Include
    private final UUID id;
    private final Username username;  // Value Object
    private final Email email;        // Value Object
    private final boolean enabled;
    private final Instant createdAt;  // SIEMPRE Instant (no LocalDateTime)

    /**
     * Factory Method - Crear nuevo
     */
    public static User create(String username, String email) {
        return new User(
            UUID.randomUUID(),
            Username.of(username),
            Email.of(email),
            true,
            Instant.now()
        );
    }

    /**
     * Factory Method - Reconstruir existente
     */
    public static User reconstitute(UUID id, String username, String email,
                                     boolean enabled, Instant createdAt) {
        return new User(
            id,
            Username.of(username),
            Email.of(email),
            enabled,
            createdAt
        );
    }

    /**
     * Método de negocio - Devuelve nueva instancia (inmutabilidad)
     */
    public User disable() {
        return new User(this.id, this.username, this.email, false, this.createdAt);
    }
}
```

**CHECKLIST Domain:**
- [ ] Clase con Lombok: `@Getter`, `@EqualsAndHashCode(onlyExplicitlyIncluded = true)`, `@ToString`, `@AllArgsConstructor(access = PRIVATE)`
- [ ] Campos `final`
- [ ] Sin setters públicos
- [ ] Factory method `create()` para nuevos
- [ ] Factory method `reconstitute()` para existentes
- [ ] Métodos de negocio devuelven nueva instancia
- [ ] Usa Value Objects (no String/int directos)
- [ ] Usa `Instant` para timestamps (NO `LocalDateTime`)
- [ ] `equals/hashCode` solo en el ID (agregar `@EqualsAndHashCode.Include` al ID)

---

### 2. Value Objects

**RECOMENDADO: Usar Records (Java 21) con Compact Constructor**

```java
package com.example.hexarch.user.domain.model.valueobject;

import com.example.hexarch.user.domain.exception.ValidationException;

/**
 * DOMAIN LAYER - Value Object (Java 21 Record)
 *
 * REGLAS:
 * - Inmutable (record garantiza inmutabilidad)
 * - Auto-valida en compact constructor
 * - Factory method: of(String) (opcional, para compatibilidad)
 * - Equals/hashCode/toString automáticos
 */
public record Email(String value) {

    /**
     * Compact Constructor - Valida antes de asignar
     */
    public Email {
        validate(value);
    }

    /**
     * Factory Method - Alternativa explícita al constructor
     */
    public static Email of(String value) {
        return new Email(value);
    }

    private static void validate(String value) {
        if (value == null || value.isBlank()) {
            throw new ValidationException("Email no puede estar vacío", "EMAIL_001");
        }
        if (!value.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$")) {
            throw new ValidationException("Formato de email inválido", "EMAIL_002");
        }
    }

    /**
     * Método getValue() para compatibilidad con código legacy
     */
    public String getValue() {
        return value;
    }
}
```

**ALTERNATIVA: Clase tradicional con Lombok (para casos complejos)**

Si el Value Object necesita lógica compleja o múltiples campos, usa clase:

```java
@Getter
@EqualsAndHashCode
@ToString
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public final class ComplexValueObject {
    private final String field1;
    private final int field2;

    public static ComplexValueObject of(String field1, int field2) {
        validate(field1, field2);
        return new ComplexValueObject(field1, field2);
    }
}
```

**CHECKLIST Value Object:**
- [ ] **Record (preferido)**: Compact constructor con validación
- [ ] **Clase (alternativa)**: `final` class, campos `final`, sin setters
- [ ] Factory method `of(...)` que valida
- [ ] Validación en método privado `validate()`
- [ ] Lanza `ValidationException` con código y mensaje
- [ ] Método `getValue()` para compatibilidad (si es necesario)

---

### 3. Domain Events

**SIEMPRE usar records:**

```java
package com.example.hexarch.user.domain.event;

import java.time.Instant;
import java.util.UUID;

/**
 * DOMAIN LAYER - Domain Event
 *
 * REGLAS:
 * - Siempre record (inmutable)
 * - Nombrado en PASADO: {Entity}{Action}Event
 * - Contiene Instant occurredAt
 * - Factory method: from()
 */
public record UserCreatedEvent(
    UUID userId,
    String username,
    String email,
    Instant occurredAt
) {
    public static UserCreatedEvent from(UUID userId, String username, String email) {
        return new UserCreatedEvent(userId, username, email, Instant.now());
    }
}
```

**CHECKLIST Domain Event:**
- [ ] Es un `record`
- [ ] Nombrado en pasado: `{Entity}{Action}Event`
- [ ] Tiene campo `Instant occurredAt`
- [ ] Factory method `from()` que genera `occurredAt`

---

### 4. Application Layer (Use Cases)

**Patrón Interface + Implementation:**

```java
// Interface (Input Port)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Input Port (Use Case)
 *
 * REGLAS:
 * - Interface pura
 * - Método execute() con Command/Query
 * - Retorna Result
 */
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Command (DTO)
package com.example.hexarch.user.application.port.input;

/**
 * APPLICATION LAYER - Command (CQRS Write)
 *
 * REGLAS:
 * - Siempre record
 * - Solo datos primitivos o inmutables
 * - Sin lógica
 */
public record CreateUserCommand(String username, String email) {}

// Result (DTO)
package com.example.hexarch.user.application.port.input;

import java.time.Instant;
import java.util.UUID;

/**
 * APPLICATION LAYER - Result
 *
 * REGLAS:
 * - Siempre record
 * - Datos primitivos o Instant (NO Value Objects)
 */
public record UserResult(
    UUID id,
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}

// Service (Implementation)
package com.example.hexarch.user.application.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * APPLICATION LAYER - Service (Use Case Implementation)
 *
 * REGLAS:
 * - Implementa UseCase interface
 * - @Service + @Transactional
 * - Constructor injection (no @Autowired)
 * - Orquesta dominio y output ports
 */
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // Constructor injection (preferido)
    public CreateUserService(UserRepository userRepository,
                             UserEventPublisher userEventPublisher) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 1. Validar precondiciones
        if (userRepository.existsByUsername(command.username())) {
            throw new UserAlreadyExistsException(command.username());
        }

        // 2. Crear dominio
        User user = User.create(command.username(), command.email());

        // 3. Persistir
        User savedUser = userRepository.save(user);

        // 4. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 5. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

**CHECKLIST Application Service:**
- [ ] Implementa UseCase interface
- [ ] Anotado con `@Service` y `@Transactional`
- [ ] Constructor injection (NO `@Autowired` en campos)
- [ ] Flujo: validar → crear dominio → persistir → publicar evento → retornar
- [ ] Extrae valores de Value Objects antes de retornar (`.getValue()`)

---

#### ⚠️ IMPORTANTE: ¿Cuándo usar Interface (UseCase) vs Service sin interface?

**Esta es una pregunta frecuente y crítica en arquitectura hexagonal.**

##### UseCase = Interface + Service (Input Ports)

**Cuándo SÍ usar interface:**
- ✅ **Puntos de entrada a la aplicación** (Input Ports)
- ✅ Casos de uso que el exterior invoca (Controllers, CLI, etc.)
- ✅ Operaciones de negocio principales (Commands/Queries CQRS)
- ✅ Cuando necesitas **inversión de dependencias**

**Ejemplo:**
```java
// Interface - Input Port (lo que la aplicación OFRECE)
public interface CreateUserUseCase {
    UserResult execute(CreateUserCommand command);
}

// Service - Implementación
@Service
public class CreateUserService implements CreateUserUseCase {
    // Implementación...
}

// Controller - Depende de la interfaz (no de la implementación)
@RestController
public class UserController {
    private final CreateUserUseCase createUserUseCase;  // ← Interface
}
```

**Razón:**
1. **Inversión de dependencias**: Infrastructure depende de abstracción (interface), no de implementación
2. **Testabilidad**: Controllers pueden usar mocks de la interface
3. **Port explícito**: La interface documenta claramente "qué ofrece la aplicación"
4. **Flexibilidad**: Puedes cambiar la implementación sin afectar el Controller

##### Service SIN interface (Servicios internos)

**Cuándo NO usar interface:**
- ✅ **Servicios de aplicación internos** (no son Input Ports)
- ✅ Servicios que solo otros componentes de Application/Infrastructure invocan
- ✅ Servicios técnicos (email, notificaciones, caching)
- ✅ Cuando NO necesitas inversión de dependencias

**Ejemplo:**
```java
// Service directo - NO es un Input Port
@Service
public class EmailService {
    @CircuitBreaker(name = "emailService", fallbackMethod = "sendEmailFallback")
    public void sendWelcomeEmail(String email, String username) {
        // Enviar email...
    }
}

// Kafka Consumer - Depende directamente del servicio
@Component
public class UserEventsKafkaConsumer {
    private final EmailService emailService;  // ← Clase directa

    public void consume(UserCreatedEvent event) {
        emailService.sendWelcomeEmail(...);
    }
}
```

**Razón:**
1. **No es un Input Port**: El Kafka Consumer (Infrastructure) llama a EmailService, pero no es un "punto de entrada" desde el exterior de la aplicación
2. **Simplicidad**: No hay necesidad de abstracción adicional
3. **Servicio técnico**: EmailService es un detalle de implementación, no lógica de negocio principal
4. **Sin inversión de dependencias necesaria**: El Consumer ya está en Infrastructure, no hay capa externa que dependa de él

##### Tabla Comparativa

| Aspecto | UseCase (con interface) | Service (sin interface) |
|---------|-------------------------|-------------------------|
| **Propósito** | Input Port - Punto de entrada | Servicio interno |
| **Quién lo invoca** | Controllers (Infrastructure) | Otros services o consumers (Application/Infrastructure) |
| **Inversión de dependencias** | SÍ - Infrastructure depende de abstracción | NO - Dependencia directa |
| **Lógica** | Orquestación de negocio principal | Lógica técnica o secundaria |
| **Testabilidad** | Mock de interface | Mock o spy de clase |
| **Ejemplos** | CreateUserUseCase, GetUserQuery | EmailService, CacheService, MetricsService |

##### Regla Práctica

```
¿Es un CASO DE USO de negocio invocado desde el exterior (Controller, CLI)?
    SÍ → UseCase interface + Service implementation
    NO → Service directo sin interface

¿Es un servicio técnico/auxiliar usado internamente?
    SÍ → Service directo sin interface
    NO → Probablemente es un UseCase
```

##### Ejemplo Completo

```
✅ CreateUserUseCase (interface)
   → Punto de entrada desde UserController
   → Caso de uso de negocio principal
   → Implementado por CreateUserService

✅ EmailService (clase directa, NO interface)
   → Invocado desde UserEventsKafkaConsumer
   → Servicio técnico de notificaciones
   → No es un punto de entrada al negocio

✅ GetUserQuery (interface)
   → Punto de entrada desde UserController
   → Query CQRS
   → Implementado por GetUserQueryHandler

✅ CacheService (clase directa, NO interface)
   → Invocado internamente desde varios services
   → Servicio técnico de caching
   → Detalle de implementación
```

**Conclusión:** NO todo service necesita interface. Solo los **Input Ports** (puntos de entrada al negocio) necesitan abstracción para mantener la inversión de dependencias de arquitectura hexagonal

---

### 5. Infrastructure Layer (Adapters)

**Controller (Input Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import jakarta.validation.Valid;

/**
 * INFRASTRUCTURE LAYER - REST Controller
 *
 * REGLAS:
 * - @RestController + @RequestMapping
 * - Constructor injection
 * - Usa UseCase (NO Repository)
 * - Mapea Request ↔ Command y Result ↔ Response
 */
@RestController
@RequestMapping("/api/v1/users")
public class UserController {

    private final CreateUserUseCase createUserUseCase;
    private final UserRestMapper mapper;

    public UserController(CreateUserUseCase createUserUseCase,
                          UserRestMapper mapper) {
        this.createUserUseCase = createUserUseCase;
        this.mapper = mapper;
    }

    @PostMapping
    public ResponseEntity<UserResponse> createUser(
        @Valid @RequestBody CreateUserRequest request
    ) {
        // 1. Mapear Request → Command
        CreateUserCommand command = mapper.toCommand(request);

        // 2. Ejecutar UseCase
        UserResult result = createUserUseCase.execute(command);

        // 3. Mapear Result → Response
        UserResponse response = mapper.toResponse(result);

        // 4. Retornar HTTP
        return ResponseEntity.status(201).body(response);
    }
}
```

**Request/Response DTOs (siempre records):**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.dto;

import jakarta.validation.constraints.*;

/**
 * INFRASTRUCTURE LAYER - REST Request DTO
 *
 * REGLAS:
 * - Siempre record
 * - Bean Validation: @NotBlank, @Email, @Size, etc.
 */
public record CreateUserRequest(
    @NotBlank(message = "Username no puede estar vacío")
    @Size(min = 3, max = 50, message = "Username debe tener entre 3 y 50 caracteres")
    String username,

    @NotBlank(message = "Email no puede estar vacío")
    @Email(message = "Email debe tener formato válido")
    String email
) {}

public record UserResponse(
    String id,           // UUID como String
    String username,
    String email,
    boolean enabled,
    Instant createdAt
) {}
```

**Repository Adapter (Output Adapter):**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import org.springframework.stereotype.Repository;
import java.util.Optional;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - Repository Adapter
 *
 * REGLAS:
 * - @Repository
 * - Implementa interface de Application
 * - Constructor injection
 * - Delega a Spring Data Repository
 * - Mapea Entity ↔ Domain
 */
@Repository
public class JpaUserRepositoryAdapter implements UserRepository {

    private final SpringDataUserRepository springDataRepo;
    private final UserEntityMapper mapper;

    public JpaUserRepositoryAdapter(SpringDataUserRepository springDataRepo,
                                     UserEntityMapper mapper) {
        this.springDataRepo = springDataRepo;
        this.mapper = mapper;
    }

    @Override
    public User save(User user) {
        UserEntity entity = mapper.toEntity(user);
        UserEntity savedEntity = springDataRepo.save(entity);
        return mapper.toDomain(savedEntity);
    }

    @Override
    public Optional<User> findById(UUID id) {
        return springDataRepo.findById(id)
            .map(mapper::toDomain);
    }
}
```

**JPA Entity:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.persistence;

import jakarta.persistence.*;
import lombok.*;
import java.time.Instant;
import java.util.UUID;

/**
 * INFRASTRUCTURE LAYER - JPA Entity
 *
 * REGLAS:
 * - @Entity, @Table
 * - Mutable (tiene setters para JPA)
 * - NO es el modelo de dominio
 * - Lombok: @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor
 */
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserEntity {

    @Id
    private UUID id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false)
    private boolean enabled;

    @Column(name = "created_at", nullable = false)
    private Instant createdAt;
}
```

---

### 6. Mappers (MapStruct)

**SIEMPRE usar MapStruct:**

```java
package com.example.hexarch.user.infrastructure.adapter.input.rest.mapper;

import org.mapstruct.*;

/**
 * INFRASTRUCTURE LAYER - REST Mapper
 *
 * REGLAS:
 * - @Mapper(componentModel = "spring")
 * - Métodos: toCommand(), toResponse()
 * - Conversiones de tipos (UUID ↔ String)
 */
@Mapper(componentModel = "spring")
public interface UserRestMapper {

    CreateUserCommand toCommand(CreateUserRequest request);

    @Mapping(target = "id", source = "id", qualifiedByName = "uuidToString")
    UserResponse toResponse(UserResult result);

    @Named("uuidToString")
    default String uuidToString(UUID uuid) {
        return uuid != null ? uuid.toString() : null;
    }
}
```

**CHECKLIST Mapper:**
- [ ] Interface (no clase)
- [ ] `@Mapper(componentModel = "spring")`
- [ ] Métodos claros: `toCommand()`, `toResponse()`, `toDomain()`, `toEntity()`
- [ ] Custom mappings con `@Mapping` y `@Named`

---

### 7. Kafka Integration + Circuit Breaker + DLT

**Patrón: Event-Driven Architecture con Resilience**

Este proyecto implementa comunicación asíncrona entre microservicios usando Apache Kafka con patrones de resiliencia empresariales.

#### 7.1. Event Publisher Adapter (Output Adapter)

**SIEMPRE seguir este patrón:**

```java
package com.example.hexarch.user.infrastructure.adapter.output.event;

import com.example.hexarch.user.application.port.output.UserEventPublisher;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

/**
 * INFRASTRUCTURE LAYER - Kafka Event Publisher
 *
 * REGLAS:
 * - @Component (no @Service, es un adapter)
 * - Implementa interface de output port
 * - Usa KafkaTemplate<String, Event>
 * - Key = ID de la entidad (para particionamiento)
 * - Fire-and-forget: no bloquea el flujo principal
 */
@Component
public class KafkaUserEventPublisherAdapter implements UserEventPublisher {

    private static final String TOPIC = "user.created";

    private final KafkaTemplate<String, UserCreatedEvent> kafkaTemplate;

    public KafkaUserEventPublisherAdapter(KafkaTemplate<String, UserCreatedEvent> kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

    @Override
    public void publish(UserCreatedEvent event) {
        kafkaTemplate.send(
            TOPIC,
            event.userId().toString(),  // Key = userId (garantiza orden)
            event
        ).whenComplete((result, ex) -> {
            if (ex != null) {
                log.error("❌ Failed to publish event to Kafka", ex);
            } else {
                log.info("📤 Published UserCreatedEvent: userId={}", event.userId());
            }
        });
    }
}
```

**CHECKLIST Kafka Publisher:**
- [ ] Implementa output port interface
- [ ] Usa `KafkaTemplate<String, EventType>`
- [ ] Key = ID de entidad (para orden y particionamiento)
- [ ] Logs de éxito/error (no lanza excepciones)
- [ ] Constante para el topic name

#### 7.2. Kafka Consumer (Input Adapter)

**SIEMPRE seguir este patrón:**

```java
package com.example.hexarch.notifications.infrastructure.kafka.consumer;

import com.example.hexarch.notifications.application.service.EmailService;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.handler.annotation.Header;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.stereotype.Component;

/**
 * INFRASTRUCTURE LAYER - Kafka Consumer
 *
 * REGLAS:
 * - @Component (no @Service, es un adapter)
 * - @KafkaListener con topic y groupId
 * - Protegido por Circuit Breaker (en el service)
 * - NO propaga excepciones (maneja errores)
 * - Spring Kafka reintenta automáticamente
 */
@Component
public class UserEventsKafkaConsumer {

    private final EmailService emailService;  // Con Circuit Breaker

    public UserEventsKafkaConsumer(EmailService emailService) {
        this.emailService = emailService;
    }

    @KafkaListener(
        topics = "user.created",
        groupId = "notifications-service",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void consume(
        @Payload UserCreatedEvent event,
        @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
        @Header(KafkaHeaders.OFFSET) long offset,
        @Header(value = KafkaHeaders.RECEIVED_KEY, required = false) String key
    ) {
        log.info("📥 Consuming UserCreatedEvent: userId={}, partition={}, offset={}",
                 event.userId(), partition, offset);

        try {
            // Llamar a servicio con Circuit Breaker
            emailService.sendWelcomeEmail(event.email(), event.username());
        } catch (Exception ex) {
            // NO propagar: evita enviar a DLT por errores no críticos
            log.error("❌ Error processing event, but won't retry: {}", ex.getMessage());
        }
    }
}
```

**CHECKLIST Kafka Consumer:**
- [ ] `@Component` + `@KafkaListener`
- [ ] Topic y groupId configurados
- [ ] Headers de Kafka (partition, offset, key)
- [ ] Try-catch: NO propaga excepciones críticas
- [ ] Llama a services con Circuit Breaker

#### 7.3. Circuit Breaker Pattern (Resilience4j)

**SIEMPRE usar en servicios externos (SMTP, HTTP APIs, etc.):**

```java
package com.example.hexarch.notifications.application.service;

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import org.springframework.stereotype.Service;

/**
 * APPLICATION LAYER - Service con Circuit Breaker
 *
 * REGLAS:
 * - @CircuitBreaker con name y fallbackMethod
 * - Fallback method con misma firma + Throwable
 * - Fallback NO lanza excepción (loguea y degrada gracefully)
 * - Estados: CLOSED → OPEN → HALF_OPEN
 */
@Service
public class EmailService {

    @CircuitBreaker(name = "emailService", fallbackMethod = "sendEmailFallback")
    public void sendWelcomeEmail(String email, String username) {
        // Simula llamada a servicio externo (SMTP, API, etc.)
        if (new Random().nextInt(100) > 70) {  // 30% chance de fallo
            throw new RuntimeException("Email service temporarily unavailable");
        }
        log.info("✅ Email sent to {}", email);
    }

    /**
     * Fallback - Se ejecuta cuando Circuit Breaker está OPEN
     *
     * IMPORTANTE:
     * - Misma firma que método principal + Throwable
     * - NO lanza excepción
     * - Loguea warning
     * - Puede encolar para retry manual
     */
    private void sendEmailFallback(String email, String username, Throwable ex) {
        log.warn("⚠️ Circuit breaker OPEN - Email not sent to {}: {}",
                 email, ex.getMessage());
        // Opcional: Encolar en sistema de retry o base de datos
    }
}
```

**Configuración Circuit Breaker (application.yml):**

```yaml
resilience4j:
  circuitbreaker:
    instances:
      emailService:
        sliding-window-size: 10          # Ventana de 10 llamadas
        minimum-number-of-calls: 5       # Mínimo 5 llamadas para calcular
        failure-rate-threshold: 50       # Si 50% fallan → OPEN
        wait-duration-in-open-state: 10s # Espera 10s antes de HALF_OPEN
        permitted-number-of-calls-in-half-open-state: 3
```

**CHECKLIST Circuit Breaker:**
- [ ] `@CircuitBreaker(name, fallbackMethod)`
- [ ] Fallback con misma firma + Throwable
- [ ] Fallback NO lanza excepciones
- [ ] Configuración en application.yml
- [ ] Solo en llamadas a servicios externos

#### 7.4. Dead Letter Topic (DLT) Consumer

**Cuando un mensaje falla N veces, va al DLT automáticamente:**

```java
package com.example.hexarch.notifications.infrastructure.kafka.consumer;

import com.example.hexarch.user.domain.event.UserCreatedEvent;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;
import java.nio.charset.StandardCharsets;

/**
 * INFRASTRUCTURE LAYER - Dead Letter Topic Consumer
 *
 * REGLAS:
 * - Topic: {original-topic}.dlt
 * - NO reintenta (ya falló múltiples veces)
 * - Loguea error para investigación
 * - Extrae headers de error de Kafka
 * - Puede persistir en BD para análisis posterior
 */
@Component
public class UserCreatedEventDLTConsumer {

    @KafkaListener(
        topics = "user.created.dlt",
        groupId = "notifications-service-dlt"
    )
    public void consumeFailedMessage(
        @Payload UserCreatedEvent event,
        ConsumerRecord<String, UserCreatedEvent> record,
        @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
        @Header(KafkaHeaders.OFFSET) long offset,
        @Header(value = KafkaHeaders.RECEIVED_KEY, required = false) String key
    ) {
        // Extraer headers del DLT
        String originalTopic = extractHeader(record, "kafka_dlt-original-topic");
        String exceptionMessage = extractHeader(record, "kafka_dlt-exception-message");
        String stackTrace = extractHeader(record, "kafka_dlt-exception-stacktrace");

        log.error("""
            💀 [DLT CONSUMER] Failed message received
            ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            Topic: user.created.dlt
            Partition: {} | Offset: {} | Key: {}
            Event: userId={}, username={}, email={}
            Original Topic: {}
            Exception: {}
            Stack Trace (first 500 chars):
            {}
            ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            """,
            partition, offset, key,
            event.userId(), event.username(), event.email(),
            originalTopic,
            exceptionMessage,
            stackTrace.substring(0, Math.min(500, stackTrace.length()))
        );

        // Opcional: Persistir en BD para análisis
        // dltRepository.save(new FailedMessage(...));
    }

    private String extractHeader(ConsumerRecord<?, ?> record, String headerKey) {
        byte[] headerValue = record.headers().lastHeader(headerKey).value();
        return new String(headerValue, StandardCharsets.UTF_8);
    }
}
```

**Headers que Spring Kafka añade al DLT:**
- `kafka_dlt-original-topic`: Topic original
- `kafka_dlt-exception-message`: Mensaje del error
- `kafka_dlt-exception-stacktrace`: Stack trace completo
- `kafka_dlt-original-offset`: Offset original
- `kafka_dlt-original-partition`: Partición original

**CHECKLIST DLT Consumer:**
- [ ] Topic = `{original}.dlt`
- [ ] NO reintenta (es el fin de la línea)
- [ ] Extrae y loguea headers de error
- [ ] Opcional: Persiste en BD para análisis
- [ ] GroupId diferente del consumer principal

#### 7.5. Kafka Configuration (KafkaConfig.java)

**Configuración de reintentos y DLT:**

```java
@Configuration
public class KafkaConfig {

    @Bean
    public DefaultErrorHandler errorHandler(
        DeadLetterPublishingRecoverer recoverer
    ) {
        // Backoff exponencial: 1s, 2s, 4s
        FixedBackOff backOff = new FixedBackOff(1000L, 3);  // 3 reintentos

        DefaultErrorHandler errorHandler = new DefaultErrorHandler(recoverer, backOff);

        // NO reintentar para errores de deserialización
        errorHandler.addNotRetryableExceptions(
            SerializationException.class,
            DeserializationException.class
        );

        return errorHandler;
    }

    @Bean
    public DeadLetterPublishingRecoverer deadLetterPublishingRecoverer(
        KafkaTemplate<String, Object> kafkaTemplate
    ) {
        return new DeadLetterPublishingRecoverer(
            kafkaTemplate,
            (record, ex) -> new TopicPartition(
                record.topic() + ".dlt",  // Añade .dlt al topic
                record.partition()
            )
        );
    }
}
```

**CHECKLIST Kafka Config:**
- [ ] `DefaultErrorHandler` con backoff
- [ ] `DeadLetterPublishingRecoverer` para DLT
- [ ] Reintentos limitados (3-5 máximo)
- [ ] Excluir errores no recuperables (deserialización)

---

## Tecnologías y Frameworks

### Versiones Obligatorias

```xml
<properties>
    <java.version>21</java.version>
    <spring-boot.version>3.5.7</spring-boot.version>
    <mapstruct.version>1.6.3</mapstruct.version>
</properties>
```

### Dependencias Permitidas

**Domain Layer:**
- ✅ Java 21 core
- ✅ Lombok (solo para reducir boilerplate)
- ❌ NO Spring
- ❌ NO JPA
- ❌ NO Jackson

**Application Layer:**
- ✅ Domain
- ✅ Spring Core (`@Service`, `@Transactional`)
- ❌ NO Spring Web
- ❌ NO JPA

**Infrastructure Layer:**
- ✅ Application
- ✅ Domain
- ✅ Spring Boot (web, data-jpa, validation)
- ✅ PostgreSQL
- ✅ Flyway
- ✅ MapStruct
- ✅ Lombok

### Anotaciones por Capa

**Domain:**
- ✅ Lombok: `@Getter`, `@EqualsAndHashCode`, `@ToString`, `@AllArgsConstructor`
- ❌ NO Spring annotations

**Application:**
- ✅ `@Service`
- ✅ `@Transactional`
- ❌ NO `@RestController`, `@Entity`

**Infrastructure:**
- ✅ `@RestController`, `@RequestMapping`
- ✅ `@Repository`, `@Entity`, `@Table`
- ✅ `@Mapper` (MapStruct)
- ✅ `@Valid`, `@NotBlank`, `@Email`

---

## Testing

### Tipos de Tests

**1. Domain Tests (Unit Tests):**
```java
// NO frameworks, solo JUnit + AssertJ
class UserTest {
    @Test
    void shouldCreateUserWithEnabledTrue() {
        User user = User.create("john", "john@example.com");
        assertTrue(user.isEnabled());
    }
}
```

**2. Application Tests (Unit Tests con Mocks):**
```java
@ExtendWith(MockitoExtension.class)
class CreateUserServiceTest {
    @Mock UserRepository userRepository;
    @Mock UserEventPublisher eventPublisher;
    @InjectMocks CreateUserService service;

    @Test
    void shouldCreateUser() {
        when(userRepository.existsByUsername(anyString())).thenReturn(false);
        when(userRepository.save(any())).thenAnswer(i -> i.getArgument(0));

        UserResult result = service.execute(new CreateUserCommand("john", "john@example.com"));

        assertNotNull(result);
        verify(userRepository).save(any(User.class));
    }
}
```

**3. Integration Tests (con Testcontainers):**
```java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine");

    @Autowired MockMvc mockMvc;

    @Test
    void shouldCreateUserViaRestApi() throws Exception {
        mockMvc.perform(post("/api/v1/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("""
                {"username": "john", "email": "john@example.com"}
                """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("john"));
    }
}
```

**Naming Convention:**
- Unit tests: `{Class}Test.java`
- Integration tests: `{Class}IntegrationTest.java`

---

## Checklist de Validación

### Antes de Generar/Modificar Código

**VERIFICAR:**

#### Arquitectura
- [ ] ¿La clase está en la capa correcta (Domain/Application/Infrastructure)?
- [ ] ¿Las dependencias apuntan en la dirección correcta?
- [ ] ¿El nombre sigue la convención de nomenclatura?
- [ ] ¿La ubicación del archivo es correcta según el template?

#### Domain Layer
- [ ] ¿Es Java puro (sin Spring, JPA, Jackson)?
- [ ] ¿Los campos son `final`?
- [ ] ¿Tiene factory methods `create()` y `reconstitute()`?
- [ ] ¿Usa Value Objects (no primitivos)?
- [ ] ¿Usa `Instant` para timestamps (no `LocalDateTime`)?
- [ ] ¿Lombok solo para reducir boilerplate?

#### Application Layer
- [ ] ¿Los Use Cases son interfaces?
- [ ] ¿Los Commands/Queries son records?
- [ ] ¿Los Services tienen `@Service` y `@Transactional`?
- [ ] ¿Constructor injection (no `@Autowired` en campos)?
- [ ] ¿No depende de Infrastructure?

#### Infrastructure Layer
- [ ] ¿Los Controllers llaman a Use Cases (no a Repositories)?
- [ ] ¿Los DTOs son records?
- [ ] ¿Request DTOs tienen Bean Validation?
- [ ] ¿Los Mappers son interfaces MapStruct?
- [ ] ¿Las Entities son mutables (para JPA)?

#### Testing
- [ ] ¿Domain tests sin frameworks?
- [ ] ¿Application tests con mocks?
- [ ] ¿Integration tests con Testcontainers?
- [ ] ¿Naming convention correcta (*Test, *IntegrationTest)?

---

## Ejemplos Completos

### Crear una Nueva Entidad: `Order`

**1. Domain Layer:**
```
src/main/java/com/example/hexarch/order/domain/
├── model/
│   ├── Order.java                 # Aggregate Root
│   └── valueobject/
│       └── OrderNumber.java       # Value Object
├── event/
│   └── OrderPlacedEvent.java      # Domain Event
└── exception/
    └── OrderNotFoundException.java
```

**2. Application Layer:**
```
src/main/java/com/example/hexarch/order/application/
├── port/
│   ├── input/
│   │   ├── PlaceOrderUseCase.java
│   │   ├── PlaceOrderCommand.java
│   │   └── OrderResult.java
│   └── output/
│       └── OrderRepository.java
└── service/
    └── PlaceOrderService.java
```

**3. Infrastructure Layer:**
```
src/main/java/com/example/hexarch/order/infrastructure/adapter/
├── input/
│   └── rest/
│       ├── OrderController.java
│       ├── dto/
│       │   ├── PlaceOrderRequest.java
│       │   └── OrderResponse.java
│       └── mapper/
│           └── OrderRestMapper.java
└── output/
    └── persistence/
        ├── JpaOrderRepositoryAdapter.java
        ├── OrderEntity.java
        ├── SpringDataOrderRepository.java
        └── mapper/
            └── OrderEntityMapper.java
```

---

## Respuestas Rápidas a Consultas Comunes

### "¿Dónde pongo este código?"
- Lógica de negocio → **Domain** (model)
- Validaciones de dominio → **Value Object** o **Aggregate**
- Validaciones HTTP → **Request DTO** (Bean Validation)
- Orquestación → **Application** (Service)
- Persistencia → **Infrastructure** (JPA Adapter)
- REST endpoints → **Infrastructure** (Controller)
- Conversiones → **Mapper** (MapStruct)

### "¿Qué tipo de DTO uso?"
- Entrada HTTP → `{Action}{Entity}Request` (record con Bean Validation)
- Entrada Application → `{Action}{Entity}Command` (record sin validación)
- Salida Application → `{Entity}Result` (record)
- Salida HTTP → `{Entity}Response` (record)
- BD → `{Entity}Entity` (clase mutable con JPA)
- Dominio → `{Entity}` (clase inmutable)

### "¿Cuándo usar `@Transactional`?"
- En Services de Application que modifican datos
- NO en Controllers
- NO en Repositories (Spring Data ya lo maneja)

### "¿String o Value Object?"
- Si tiene validación → **Value Object**
- Si es concepto de dominio → **Value Object**
- Si es solo transporte de datos → **String** (en DTOs)

### "¿Instant o LocalDateTime?"
- Para timestamps de sistema/auditoría → **Instant** (UTC)
- Para fechas de negocio sin zona horaria → **LocalDateTime**
- Para fechas con zona horaria → **ZonedDateTime**

---

## Comandos Maven Útiles

```bash
# Build (excluye integration tests)
./mvnw clean install

# Solo unit tests
./mvnw test

# Todos los tests (requiere Docker)
./mvnw test -Pintegration-tests

# Run application
./mvnw spring-boot:run
```

---

## Errores Comunes a Evitar

1. ❌ Poner `@Entity` en clases del Domain → Usar `UserEntity` en Infrastructure
2. ❌ Controller llama a Repository directamente → Llamar a UseCase
3. ❌ Service devuelve Domain Object → Devolver Result DTO
4. ❌ Usar `LocalDateTime` para timestamps → Usar `Instant`
5. ❌ Value Object mutable → Debe ser `final` e inmutable
6. ❌ Factory method `create()` sin validación → Validar en Value Objects
7. ❌ `@Autowired` en campos → Constructor injection
8. ❌ Domain depende de Spring → Solo Lombok permitido

---

## 9. Observabilidad: Logs, Métricas y Trazas

### 9.1. Los 3 Pilares de Observabilidad

La observabilidad permite entender qué está pasando en la aplicación en producción mediante **3 pilares complementarios**:

1. **LOGS** 📝: Eventos discretos con timestamp (¿Qué pasó?)
2. **MÉTRICAS** 📈: Valores numéricos agregados en el tiempo (¿Cómo está funcionando?)
3. **TRAZAS** 🔗: Seguimiento de requests a través de servicios (¿Dónde está el cuello de botella?)

**IMPORTANTE:** Los 3 pilares DEBEN usarse juntos para observabilidad completa.

---

### 9.2. Logs Estructurados (SLF4J + Logback)

#### 9.2.1. Niveles de Log y Cuándo Usarlos

| Nivel | Cuándo Usar | Ejemplo | En Producción |
|-------|-------------|---------|---------------|
| **ERROR** | Errores críticos que requieren atención inmediata | `log.error("Failed to process payment", ex)` | ✅ ON |
| **WARN** | Problemas recuperables, configuración subóptima | `log.warn("Retrying failed request: attempt {}", retryCount)` | ✅ ON |
| **INFO** | Eventos de negocio importantes | `log.info("User created: userId={}", userId)` | ✅ ON |
| **DEBUG** | Información de desarrollo, debugging | `log.debug("Query params: {}", params)` | ❌ OFF |
| **TRACE** | Debugging de librerías, muy detallado | `log.trace("Method entered: {}", methodName)` | ❌ OFF |

#### 9.2.2. Implementación OBLIGATORIA

```java
// En CUALQUIER Service o clase de Application layer:
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
public class CreateUserService implements CreateUserUseCase {

    // 1. Declarar logger (OBLIGATORIO en todos los Services)
    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    @Override
    public UserResult execute(CreateUserCommand command) {
        // 2. LOG INFO: Inicio de operación de negocio importante
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        // 3. LOG WARN: Problemas recuperables
        if (userRepository.existsByUsername(command.username())) {
            log.warn("Username already exists: {}", command.username());
            throw new UserAlreadyExistsException(command.username());
        }

        User savedUser = userRepository.save(user);

        // 4. LOG INFO: Operación exitosa con datos clave
        log.info("User created successfully: userId={}, username={}",
                 savedUser.getId(), savedUser.getUsername().getValue());

        return result;
    }
}
```

#### 9.2.3. Best Practices de Logging

**✅ HACER:**
```java
// 1. Usar placeholders {} para performance
log.info("User {} performed action {}", userId, action);

// 2. Log de excepciones con stacktrace
log.error("Failed to send email to {}", email, exception);

// 3. Structured logging con datos clave
log.info("Order created: orderId={}, customerId={}, amount={}",
         orderId, customerId, amount);
```

**❌ NO HACER:**
```java
// 1. Concatenación de strings (bajo performance)
log.info("User " + userId + " performed " + action);  // ❌ MAL

// 2. Log de información sensible
log.info("User password: {}", password);  // ❌ NUNCA

// 3. Log excesivo en loops
for (User user : users) {
    log.info("Processing {}", user);  // ❌ Genera miles de logs
}
```

#### 9.2.4. Correlation ID y Trace ID

El proyecto usa **Micrometer Tracing** para correlacionar logs de un mismo request:

```
2024-01-15 10:30:00 [f47ac10b,1a2b3c4d] 550e8400 INFO - User created: userId=123
                    │         │         │
                    TraceId   SpanId    CorrelationId
```

**NO necesitas implementar esto manualmente** - Micrometer lo hace automáticamente.

---

### 9.3. Métricas Custom (Micrometer + Prometheus)

#### 9.3.1. Tipos de Métricas

| Tipo | Uso | Ejemplo |
|------|-----|---------|
| **Counter** | Valores que solo aumentan | `users.created.total`, `orders.failed.total` |
| **Gauge** | Valores que suben y bajan | `active.connections`, `queue.size` |
| **Histogram** | Distribución de valores | `http.request.duration`, `order.amount` |
| **Timer** | Mide duración de eventos | `method.execution.time` |

#### 9.3.2. Implementación OBLIGATORIA de Métricas Custom

```java
@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    // 1. Inyectar MeterRegistry (OBLIGATORIO para métricas custom)
    private final MeterRegistry meterRegistry;

    // 2. Inyectar environment para tags
    private final String environment;

    public CreateUserService(
            UserRepository userRepository,
            UserEventPublisher userEventPublisher,
            MeterRegistry meterRegistry,
            @Value("${ENVIRONMENT:local}") String environment
    ) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
        this.meterRegistry = meterRegistry;
        this.environment = environment;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        try {
            User savedUser = userRepository.save(user);

            // 3. Incrementar métrica custom de NEGOCIO
            meterRegistry.counter("users.created.total",
                                  "status", "success",
                                  "environment", environment)
                         .increment();

            log.info("User created successfully: userId={}", savedUser.getId());
            return result;

        } catch (Exception ex) {
            // 4. Métrica de errores
            meterRegistry.counter("users.created.total",
                                  "status", "error",
                                  "environment", environment)
                         .increment();
            throw ex;
        }
    }
}
```

#### 9.3.3. Convenciones de Nombres de Métricas

**Formato:** `{entity}.{action}.{unit}`

```java
// ✅ BIEN (formato snake_case, claro, con unit)
"users.created.total"      // Counter: usuarios creados
"orders.amount.dollars"    // Gauge: monto en dólares
"email.sent.total"         // Counter: emails enviados
"payment.duration.seconds" // Timer: duración de pagos

// ❌ MAL (sin formato claro)
"userCreated"              // camelCase (usar snake_case)
"created"                  // Falta entity
"users"                    // Falta action
"users.created"            // Falta unit
```

#### 9.3.4. Tags Obligatorios

**SIEMPRE incluir tags para dimensionalidad:**
```java
// ✅ BIEN: Con tags para filtrar y agrupar
meterRegistry.counter("users.created.total",
                      "status", "success",        // success/error
                      "environment", environment) // local/dev/prod
             .increment();

// ❌ MAL: Sin tags (no puedes filtrar por status o environment)
meterRegistry.counter("users.created.total").increment();
```

#### 9.3.5. Dónde Ver las Métricas

**Endpoint de Prometheus:**
```bash
# Ver todas las métricas en formato Prometheus
curl http://localhost:8080/actuator/prometheus

# Filtrar métricas custom
curl http://localhost:8080/actuator/prometheus | grep users_created
```

**Grafana Dashboards:**
- Métricas JVM: `jvm_memory_used_bytes`, `jvm_gc_pause_seconds`
- Métricas HTTP: `http_server_requests_seconds_count`
- Métricas custom: `users_created_total`

---

### 9.4. Trazas Distribuidas (Zipkin + Micrometer)

#### 9.4.1. Qué Son las Trazas

Las trazas distribuidas permiten seguir un request a través de múltiples servicios:

```
POST /api/v1/users (250ms total)
  ├─ CreateUserUseCase (200ms)
  │  ├─ PostgreSQL INSERT (40ms)
  │  └─ Kafka publish (150ms) ← 60% del tiempo aquí
  └─ Response (10ms)
```

#### 9.4.2. Configuración (Ya Incluida)

**application.yaml:**
```yaml
management:
  tracing:
    sampling:
      probability: 1.0  # 100% en desarrollo, 0.1 (10%) en producción
  zipkin:
    tracing:
      endpoint: http://localhost:9411/api/v2/spans
```

**NO necesitas código adicional** - Micrometer Tracing lo hace automáticamente.

#### 9.4.3. Cómo Ver Trazas

**Zipkin UI:**
```bash
# 1. Levantar Zipkin con docker-compose
docker-compose -f docker-compose-observability.yml up -d

# 2. Acceder a Zipkin UI
http://localhost:9411

# 3. Buscar trazas por:
- Service name: hexarch
- Span name: POST /api/v1/users
- TraceId: del log
```

---

### 9.5. Checklist de Observabilidad

Cuando crees o modifiques un Service:

- [ ] **Logs:**
  - [ ] Añadir `private static final Logger log = ...`
  - [ ] Log INFO al inicio de operación de negocio
  - [ ] Log WARN para problemas recuperables
  - [ ] Log ERROR con stacktrace para excepciones
  - [ ] Log INFO al finalizar exitosamente con datos clave
  - [ ] Usar placeholders `{}` para parámetros

- [ ] **Métricas Custom:**
  - [ ] Inyectar `MeterRegistry` y `@Value("${ENVIRONMENT:local}")` en constructor
  - [ ] Crear Counter para operaciones de negocio (`{entity}.{action}.total`)
  - [ ] Añadir tags `status` (success/error) y `environment`
  - [ ] Incrementar métrica en caso exitoso
  - [ ] Incrementar métrica en caso de error

- [ ] **Trazas:**
  - [ ] NO necesitas código adicional (automático con Micrometer)
  - [ ] Verificar que `management.tracing.sampling.probability` esté configurado

---

### 9.6. Ejemplo Completo de Service con Observabilidad

```java
package com.example.hexarch.user.application.service;

import com.example.hexarch.user.application.port.input.CreateUserCommand;
import com.example.hexarch.user.application.port.input.CreateUserUseCase;
import com.example.hexarch.user.application.port.input.UserResult;
import com.example.hexarch.user.application.port.output.UserEventPublisher;
import com.example.hexarch.user.application.port.output.UserRepository;
import com.example.hexarch.user.domain.event.UserCreatedEvent;
import com.example.hexarch.user.domain.exception.UserAlreadyExistsException;
import com.example.hexarch.user.domain.model.User;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class CreateUserService implements CreateUserUseCase {

    // 1. Logger (OBLIGATORIO)
    private static final Logger log = LoggerFactory.getLogger(CreateUserService.class);

    // 2. Dependencies
    private final UserRepository userRepository;
    private final UserEventPublisher userEventPublisher;

    // 3. Observability (OBLIGATORIO)
    private final MeterRegistry meterRegistry;
    private final String environment;

    // 4. Constructor con inyección de dependencias
    public CreateUserService(
            UserRepository userRepository,
            UserEventPublisher userEventPublisher,
            MeterRegistry meterRegistry,
            @Value("${ENVIRONMENT:local}") String environment
    ) {
        this.userRepository = userRepository;
        this.userEventPublisher = userEventPublisher;
        this.meterRegistry = meterRegistry;
        this.environment = environment;
    }

    @Override
    public UserResult execute(CreateUserCommand command) {

        // 5. LOG INFO: Inicio de operación de negocio
        log.info("Creating user: username={}, email={}", command.username(), command.email());

        // 6. Validaciones con LOG WARN
        if (userRepository.existsByUsername(command.username())) {
            log.warn("Username already exists: {}", command.username());
            throw new UserAlreadyExistsException(command.username());
        }

        if (userRepository.existsByEmail(command.email())) {
            log.warn("Email already exists: {}", command.email());
            throw new UserAlreadyExistsException(command.email());
        }

        // 7. Lógica de negocio
        User user = User.create(command.username(), command.email());
        User savedUser = userRepository.save(user);

        // 8. LOG INFO: Operación exitosa con datos clave
        log.info("User created successfully: userId={}, username={}, email={}",
                savedUser.getId(),
                savedUser.getUsername().getValue(),
                savedUser.getEmail().getValue());

        // 9. Publicar evento
        UserCreatedEvent event = UserCreatedEvent.from(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue()
        );
        userEventPublisher.publish(event);

        // 10. MÉTRICA CUSTOM: Contador de usuarios creados
        meterRegistry.counter("users.created.total",
                              "status", "success",
                              "environment", environment)
                     .increment();

        // 11. Retornar resultado
        return new UserResult(
            savedUser.getId(),
            savedUser.getUsername().getValue(),
            savedUser.getEmail().getValue(),
            savedUser.isEnabled(),
            savedUser.getCreatedAt()
        );
    }
}
```

---

### 9.7. Errores Comunes de Observabilidad

**❌ Error 1: No usar placeholders en logs**
```java
// ❌ MAL: Concatenación de strings (bajo performance)
log.info("User " + userId + " created");

// ✅ BIEN: Placeholders (SLF4J optimiza)
log.info("User {} created", userId);
```

**❌ Error 2: Log de información sensible**
```java
// ❌ NUNCA loguear passwords, tokens, credit cards
log.info("User password: {}", password);
log.info("JWT token: {}", token);

// ✅ BIEN: Loguear solo identificadores
log.info("User authenticated: userId={}", userId);
```

**❌ Error 3: Métricas sin tags**
```java
// ❌ MAL: No puedes filtrar por status o environment
meterRegistry.counter("users.created.total").increment();

// ✅ BIEN: Con tags para dimensionalidad
meterRegistry.counter("users.created.total",
                      "status", "success",
                      "environment", environment)
             .increment();
```

**❌ Error 4: Usar System.out.println en lugar de logger**
```java
// ❌ MAL: No aparece en logs estructurados, no tiene timestamp, no tiene level
System.out.println("User created");

// ✅ BIEN: Usar logger con nivel apropiado
log.info("User created: userId={}", userId);
```

---

### 9.8. Documentación de Referencia

Para aprender más sobre observabilidad en este proyecto:
- **Guía completa**: [docs/07-Monitoring-Observability.md](docs/07-Monitoring-Observability.md)
- **README**: Sección "Observabilidad: Monitorizar la Aplicación"
- **Bruno Collection**: Endpoint `/api/v1/monitoring/Prometheus.bru`

---

## 10. Spring Security + JWT Authentication & Authorization

### 10.1. Conceptos Clave

**Autenticación vs Autorización:**
- **Autenticación (Authentication)**: ¿QUIÉN eres? → Validar token JWT
- **Autorización (Authorization)**: ¿QUÉ puedes hacer? → Verificar roles

**Stateless JWT:**
- Sin sesiones HTTP (SessionCreationPolicy.STATELESS)
- Cada request incluye token JWT en header `Authorization: Bearer {token}`
- Token contiene: username + roles + timestamp

### 10.2. Estructura de Archivos (OBLIGATORIA)

```
src/main/java/com/example/hexarch/
│
├── shared/                                 ← Cross-cutting concerns
│   ├── domain/
│   │   └── security/
│   │       └── Role.java                   ← Enum de roles (DOMAIN)
│   │
│   └── infrastructure/
│       └── security/
│           ├── SecurityConfig.java         ← Configuración Spring Security
│           └── jwt/
│               ├── JwtProperties.java      ← @ConfigurationProperties
│               ├── JwtTokenProvider.java   ← Core: genera/valida tokens
│               ├── JwtAuthenticationFilter.java  ← Filtro HTTP
│               └── JwtAuthenticationEntryPoint.java  ← Errores 401
```

**REGLA:** Security es **transversal** → va en `shared/`, NO en bounded context específico

### 10.3. Role Enum (Domain Layer)

```java
// shared/domain/security/Role.java
public enum Role {
    ADMIN,      // Acceso completo
    MANAGER,    // Puede crear/leer usuarios
    VIEWER,     // Solo lectura
    SUPPLIER;   // Acceso limitado

    // Spring Security espera prefijo ROLE_
    public String getAuthority() {
        return "ROLE_" + this.name();
    }

    // Convertir desde String (case-insensitive, con/sin ROLE_)
    public static Role fromString(String roleName) {
        String cleanName = roleName.toUpperCase().replace("ROLE_", "");
        return Role.valueOf(cleanName);
    }
}
```

**¿Por qué en Domain?**
- Los roles son concepto de negocio (no técnico)
- Son independientes del framework (Spring Security)
- Se usan en múltiples bounded contexts

### 10.4. JwtTokenProvider (Core Component)

```java
// shared/infrastructure/security/jwt/JwtTokenProvider.java
@Component
@RequiredArgsConstructor
@Slf4j
public class JwtTokenProvider {
    private final JwtProperties jwtProperties;
    private SecretKey secretKey;

    @PostConstruct
    public void init() {
        byte[] keyBytes = jwtProperties.getSecret().getBytes(StandardCharsets.UTF_8);
        this.secretKey = Keys.hmacShaKeyFor(keyBytes);
    }

    // Genera token JWT con username y roles
    public String generateToken(String username, List<Role> roles) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtProperties.getExpiration());

        List<String> roleNames = roles.stream()
            .map(Role::name)
            .collect(Collectors.toList());

        return Jwts.builder()
            .subject(username)
            .claim("roles", roleNames)
            .issuedAt(now)
            .expiration(expiryDate)
            .signWith(secretKey, Jwts.SIG.HS256)
            .compact();
    }

    // Valida token (firma + expiración)
    public boolean validateToken(String token) {
        try {
            getClaimsFromToken(token);
            return true;
        } catch (JwtException ex) {
            log.error("Invalid JWT: {}", ex.getMessage());
            return false;
        }
    }

    // Extrae username del token
    public String getUsernameFromToken(String token) {
        return getClaimsFromToken(token).getSubject();
    }

    // Extrae roles del token
    public List<Role> getRolesFromToken(String token) {
        Claims claims = getClaimsFromToken(token);
        List<String> roleNames = claims.get("roles", List.class);
        return roleNames.stream().map(Role::fromString).collect(Collectors.toList());
    }

    private Claims getClaimsFromToken(String token) {
        return Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }
}
```

### 10.5. JwtAuthenticationFilter (HTTP Filter)

```java
// shared/infrastructure/security/jwt/JwtAuthenticationFilter.java
@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider jwtTokenProvider;

    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {

        String token = extractTokenFromRequest(request);

        if (token != null && jwtTokenProvider.validateToken(token)) {
            String username = jwtTokenProvider.getUsernameFromToken(token);
            List<Role> roles = jwtTokenProvider.getRolesFromToken(token);

            List<SimpleGrantedAuthority> authorities = roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.getAuthority()))
                .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(username, null, authorities);

            authentication.setDetails(
                new WebAuthenticationDetailsSource().buildDetails(request)
            );

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 10.6. SecurityConfig (Configuración Principal)

```java
// shared/infrastructure/security/SecurityConfig.java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                // Endpoints públicos
                .requestMatchers("/actuator/health", "/swagger-ui/**").permitAll()

                // Endpoints protegidos por rol
                .requestMatchers(HttpMethod.POST, "/api/users")
                    .hasAnyRole("ADMIN", "MANAGER")

                .requestMatchers(HttpMethod.GET, "/api/users/**")
                    .authenticated()

                .anyRequest().authenticated()
            )
            .addFilterBefore(
                jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class
            );

        return http.build();
    }
}
```

**IMPORTANTE:**
- `.hasAnyRole("ADMIN")` → Spring añade prefijo `ROLE_` automáticamente
- NO uses `.hasAnyRole("ROLE_ADMIN")` (doble prefijo)

### 10.7. Configuración (application.yaml)

```yaml
jwt:
  # Secret key para firmar tokens (256 bits mínimo para HS256)
  # ⚠️ En producción: usar ${JWT_SECRET} (variable de entorno)
  secret: 5JYzCkNP8xQ2mVnRwTaFbGdKeShXrUvYy3t6v9yBxE4=

  # Expiración en milisegundos (24 horas)
  expiration: 86400000
```

### 10.8. Matriz de Autorización

| Endpoint | Método | ADMIN | MANAGER | VIEWER | SUPPLIER | Sin Auth |
|----------|--------|-------|---------|--------|----------|----------|
| `/api/users` | POST | ✅ | ✅ | ❌ | ❌ | ❌ |
| `/api/users/{id}` | GET | ✅ | ✅ | ✅ | ✅ | ❌ |
| `/actuator/health` | GET | ✅ | ✅ | ✅ | ✅ | ✅ |

### 10.9. Testing de Seguridad

**Unit Tests:**

```java
// shared/infrastructure/security/jwt/JwtTokenProviderTest.java
@DisplayName("JWT Token Provider Unit Tests")
class JwtTokenProviderTest {
    private JwtTokenProvider jwtTokenProvider;

    @BeforeEach
    void setUp() {
        JwtProperties props = new JwtProperties();
        props.setSecret("test-secret-key-256-bits...");
        props.setExpiration(86400000L);

        jwtTokenProvider = new JwtTokenProvider(props);
        jwtTokenProvider.init();
    }

    @Test
    void shouldGenerateValidJwtToken() {
        String token = jwtTokenProvider.generateToken("user", List.of(Role.ADMIN));

        assertThat(token).isNotNull();
        assertThat(jwtTokenProvider.validateToken(token)).isTrue();
    }
}
```

**Integration Tests:**

```java
// security/SecurityIntegrationTest.java
@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class SecurityIntegrationTest {
    @Autowired private MockMvc mockMvc;
    @Autowired private JwtTokenProvider jwtTokenProvider;

    private String adminToken;

    @BeforeEach
    void setUp() {
        adminToken = "Bearer " + jwtTokenProvider.generateToken(
            "admin", List.of(Role.ADMIN)
        );
    }

    @Test
    void shouldReturn401WhenCreatingUserWithoutToken() throws Exception {
        mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content("{\"username\":\"test\",\"email\":\"test@test.com\"}"))
        .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldCreateUserWithAdminRole() throws Exception {
        mockMvc.perform(post("/api/users")
            .header("Authorization", adminToken)
            .contentType(MediaType.APPLICATION_JSON)
            .content("{\"username\":\"test\",\"email\":\"test@test.com\"}"))
        .andExpect(status().isCreated());
    }
}
```

### 10.10. Best Practices OBLIGATORIAS

**1. NUNCA hardcodear secret en código:**
```java
// ❌ MAL
private static final String SECRET = "my-secret";

// ✅ BIEN
@Value("${jwt.secret}")
private String secret;
```

**2. Secret key mínimo 256 bits (32 caracteres) para HS256**

**3. En producción: usar variables de entorno**
```yaml
jwt:
  secret: ${JWT_SECRET}  # Variable de entorno
```

**4. HTTPS obligatorio en producción**
- JWT en HTTP plano → vulnerable a ataques

**5. Expiración razonable:**
- Desarrollo/educación: 24 horas
- Producción: 15-60 minutos + refresh token

**6. Validar SIEMPRE:**
- Firma del token (con secret key)
- Expiración (exp claim)
- Formato (3 partes separadas por puntos)

### 10.11. Errores Comunes

**❌ Error 1: Usar ROLE_ dos veces**
```java
.hasAnyRole("ROLE_ADMIN")  // Spring añade ROLE_ automáticamente → ROLE_ROLE_ADMIN
```
✅ Correcto:
```java
.hasAnyRole("ADMIN")  // Spring lo convierte a ROLE_ADMIN
```

**❌ Error 2: Token sin prefijo Bearer**
```java
request.setHeader("Authorization", token);  // Sin "Bearer "
```
✅ Correcto:
```java
request.setHeader("Authorization", "Bearer " + token);
```

**❌ Error 3: Secret key muy corto**
```yaml
jwt:
  secret: short  # < 256 bits → WeakKeyException
```
✅ Correcto:
```yaml
jwt:
  secret: 5JYzCkNP8xQ2mVnRwTaFbGdKeShXrUvYy3t6v9yBxE4=  # 256 bits
```

### 10.12. Checklist de Implementación

Cuando añadas seguridad JWT:

- [ ] Crear `Role` enum en `shared/domain/security/`
- [ ] Crear `JwtProperties` con `@ConfigurationProperties`
- [ ] Crear `JwtTokenProvider` con métodos generate/validate/extract
- [ ] Crear `JwtAuthenticationFilter` extends `OncePerRequestFilter`
- [ ] Crear `JwtAuthenticationEntryPoint` implements `AuthenticationEntryPoint`
- [ ] Crear `SecurityConfig` con `@EnableWebSecurity`
- [ ] Configurar `application.yaml` con secret y expiration
- [ ] Añadir autorización por endpoint en `SecurityConfig`
- [ ] Escribir unit tests para `JwtTokenProvider` y `Role`
- [ ] Escribir integration tests para endpoints protegidos
- [ ] Documentar en guía `docs/08-Spring-Security-JWT.md`

---

## Fin de Guidelines

**RECUERDA:** Estas reglas NO son sugerencias, son **OBLIGATORIAS**. Si generas código que viole estas reglas, el proyecto no compilará o fallará en los tests de arquitectura.

**Ante cualquier duda:** Revisa los ejemplos completos en el proyecto existente y sigue el patrón al pie de la letra.

**Prioridades:**
1. Respeta la Dependency Rule (lo más importante)
2. Sigue la nomenclatura exacta
3. Usa los patrones de implementación
4. Coloca archivos en ubicaciones correctas
5. Escribe tests adecuados

---

**Versión de Guidelines:** 1.2 (Actualizado con Records para Value Objects)
**Última actualización:** 2025-01-30
