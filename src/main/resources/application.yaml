# ===================================================================
# CONFIGURACIÓN DE LA APLICACIÓN
# ===================================================================
# Configuración para el proyecto hexarch con arquitectura hexagonal

# ===================================================================
# CONFIGURACIÓN DE LA APLICACIÓN
# ===================================================================
spring:
  application:
    name: hexarch

  # ===================================================================
  # LIFECYCLE - Graceful Shutdown
  # ===================================================================
  lifecycle:
    # Tiempo máximo para completar requests en curso durante shutdown
    # Después de este tiempo, se fuerza el shutdown
    # PRODUCTION: 30-60 segundos (depende de la duración de tus requests más largos)
    timeout-per-shutdown-phase: 30s

  # ===================================================================
  # CONFIGURACIÓN DE BASE DE DATOS - POSTGRESQL
  # ===================================================================
  datasource:
    # URL de conexión a PostgreSQL
    # Formato: jdbc:postgresql://host:port/database
    url: jdbc:postgresql://localhost:5432/hexarch_db
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver

    # Configuración de HikariCP (pool de conexiones)
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 300000

  # ===================================================================
  # CONFIGURACIÓN DE JPA / HIBERNATE
  # ===================================================================
  jpa:
    # Dialecto de PostgreSQL
    database-platform: org.hibernate.dialect.PostgreSQLDialect

    # NO crear/actualizar esquema automáticamente (usamos Flyway)
    hibernate:
      ddl-auto: validate

    # Mostrar SQL en consola (útil para desarrollo, desactivar en producción)
    show-sql: true

    # Configuración adicional de Hibernate
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

  # ===================================================================
  # CONFIGURACIÓN DE FLYWAY
  # ===================================================================
  flyway:
    # Habilitar Flyway para migraciones de BD
    enabled: true

    # Ubicación de los scripts de migración
    locations: classpath:db/migration

    # Baseline on migrate: crea una versión base si la BD no está vacía
    baseline-on-migrate: true

    # Validar migraciones al iniciar
    validate-on-migrate: true

  # ===================================================================
  # CONFIGURACIÓN DE JACKSON (JSON)
  # ===================================================================
  jackson:
    # Instant se serializa automáticamente a formato ISO-8601 con UTC (ej: 2024-01-15T10:30:00.123Z)
    # No necesitamos configuración especial para Instant

    # Incluir solo propiedades no nulas en JSON
    default-property-inclusion: non_null

    serialization:
      # Pretty print JSON (útil para desarrollo, desactivar en producción)
      indent_output: true

      # Serializar fechas como timestamps ISO-8601 (no como números)
      write-dates-as-timestamps: false

  # ===================================================================
  # CONFIGURACIÓN DE KAFKA
  # ===================================================================
  kafka:
    # Dirección del broker Kafka
    # localhost:9092 para desarrollo local (docker-compose)
    bootstrap-servers: localhost:9092

    # Configuración del PRODUCER (publicar eventos)
    producer:
      # Serializar clave como String
      key-serializer: org.apache.kafka.common.serialization.StringSerializer

      # Serializar valor como JSON
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

      # Propiedades adicionales del producer
      properties:
        # Habilitar idempotencia (evita duplicados en caso de reenvíos)
        enable.idempotence: true

        # Número de acknowledgments requeridos antes de considerar exitoso el envío
        # all = esperar confirmación de todos los replicas (máxima durabilidad)
        acks: all

        # Número de reintentos en caso de error
        retries: 3

    # Configuración del CONSUMER (consumir eventos)
    consumer:
      # Deserializar clave como String
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer

      # Deserializar valor desde JSON
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer

      # Grupo de consumers
      # Consumers con mismo group-id comparten la carga (load balancing)
      group-id: hexarch-user-service

      # Estrategia de lectura si no hay offset guardado
      # earliest = leer desde el principio (útil para desarrollo/testing)
      # latest = leer solo mensajes nuevos (útil para producción)
      auto-offset-reset: earliest

      # Propiedades adicionales del consumer
      properties:
        # Paquetes confiables para deserialización
        # ⚠️ En producción, especifica paquetes exactos en lugar de "*"
        # Ejemplo: spring.json.trusted.packages: com.example.hexarch.user.domain.event
        spring.json.trusted.packages: "*"

    # Configuración del LISTENER (@KafkaListener)
    listener:
      # Modo de confirmación de mensajes (ack)
      # record = confirmar cada mensaje individualmente (más seguro)
      # batch = confirmar lote completo (más performante)
      ack-mode: record

  # ===================================================================
  # CONFIGURACIÓN DE RESILIENCE4J (Circuit Breaker, Retry, etc.)
  # ===================================================================
resilience4j:
  circuitbreaker:
    instances:
      # Circuit Breaker para EmailService
      emailService:
        # Tamaño de la ventana deslizante para calcular tasa de fallos
        # COUNT_BASED = cuenta número de llamadas
        # TIME_BASED = cuenta en ventana de tiempo
        sliding-window-type: COUNT_BASED

        # Número de llamadas en la ventana deslizante
        # Circuit Breaker evalúa fallos sobre las últimas 10 llamadas
        sliding-window-size: 10

        # Número mínimo de llamadas antes de evaluar tasa de fallos
        # Si hay menos de 5 llamadas, el circuit NO se abre (aunque todas fallen)
        minimum-number-of-calls: 5

        # Porcentaje de fallos para abrir el circuit
        # Si >= 50% de las últimas 10 llamadas fallan → Circuit pasa a OPEN
        failure-rate-threshold: 50

        # Cuánto tiempo permanece OPEN antes de cambiar a HALF_OPEN
        # Después de 10 segundos, permite llamadas de prueba
        wait-duration-in-open-state: 10s

        # Número de llamadas permitidas en estado HALF_OPEN (prueba)
        # Permite 3 llamadas de prueba para ver si el servicio se recuperó
        permitted-number-of-calls-in-half-open-state: 3

        # Si en HALF_OPEN, cuántas llamadas deben fallar para volver a OPEN
        # Si >= 50% de las 3 llamadas de prueba fallan → Vuelve a OPEN
        # Si < 50% fallan → Cambia a CLOSED ✅
        slow-call-rate-threshold: 50

        # Llamada se considera "lenta" si tarda más de esto
        # Llamadas lentas también cuentan como fallos
        slow-call-duration-threshold: 5s

        # Registrar eventos para debugging/monitoring
        register-health-indicator: true
        record-exceptions:
          - java.lang.RuntimeException
          - java.io.IOException
          - java.util.concurrent.TimeoutException

# ===================================================================
# CONFIGURACIÓN DEL SERVIDOR
# ===================================================================
server:
  port: 8080

  # Graceful shutdown para evitar pérdida de requests en rolling updates
  # Espera a que las requests en curso terminen antes de apagar el servidor
  shutdown: graceful

# ===================================================================
# CONFIGURACIÓN DE LOGGING
# ===================================================================
logging:
  # Nivel de log general
  level:
    root: INFO

    # Nivel de log para nuestro paquete
    com.example.hexarch: DEBUG

    # Nivel de log para SQL (mostrar parámetros de queries)
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

    # Nivel de log para Spring
    org.springframework.web: DEBUG

  # Patrón de log con Trace ID, Span ID y Correlation ID para distributed tracing
  pattern:
    # Formato: timestamp [traceId,spanId] correlationId level - message
    # traceId: identifica la transacción completa (Micrometer Tracing)
    # spanId: identifica una operación específica dentro del trace
    # correlationId: identifica el flujo de negocio completo entre servicios
    console: "%d{yyyy-MM-dd HH:mm:ss} [%X{traceId},%X{spanId}] %X{correlationId} %5p - %msg%n"

# ===================================================================
# CONFIGURACIÓN DE ACTUATOR (Monitoreo)
# ===================================================================
management:
  endpoints:
    web:
      exposure:
        # Exponer endpoints de actuator
        # Incluye prometheus para métricas en formato Prometheus
        include: health,info,metrics,prometheus

  endpoint:
    health:
      # Mostrar detalles del health endpoint
      show-details: always

      # Habilitar Kubernetes-style health probes
      # Endpoints: /actuator/health/liveness y /actuator/health/readiness
      probes:
        enabled: true

  # ===================================================================
  # HEALTH INDICATORS - Kubernetes Probes
  # ===================================================================
  health:
    # Liveness Probe: ¿La aplicación está viva?
    # Si falla, Kubernetes reinicia el pod
    livenessState:
      enabled: true

    # Readiness Probe: ¿La aplicación está lista para recibir tráfico?
    # Si falla, Kubernetes deja de enviar requests al pod
    readinessState:
      enabled: true

  # ===================================================================
  # DISTRIBUTED TRACING - Micrometer Tracing
  # ===================================================================
  tracing:
    # Sampling probability (0.0 a 1.0)
    # 1.0 = 100% de requests son traced (recomendado para desarrollo)
    # 0.1 = 10% de requests son traced (recomendado para producción con alto tráfico)
    sampling:
      probability: ${TRACING_SAMPLING_PROBABILITY:1.0}

  # ===================================================================
  # ZIPKIN REPORTER (Opcional)
  # ===================================================================
  # Zipkin recibe y visualiza traces distribuidos
  # Si no tienes Zipkin corriendo, los traces solo se logearán
  zipkin:
    tracing:
      # URL de Zipkin server
      # Si no está disponible, los traces solo aparecen en logs (no causa errores)
      endpoint: ${ZIPKIN_ENDPOINT:http://localhost:9411/api/v2/spans}

  # ===================================================================
  # PROMETHEUS METRICS
  # ===================================================================
  metrics:
    distribution:
      # Histogramas para medir latencias
      percentiles-histogram:
        http.server.requests: true

    # Tags adicionales en todas las métricas
    tags:
      application: ${spring.application.name}
      environment: ${ENVIRONMENT:local}

# ===================================================================
# CONFIGURACIÓN DE JWT (JSON Web Token)
# ===================================================================
jwt:
  # Clave secreta para firmar tokens JWT
  # ⚠️ IMPORTANTE: Usar variable de entorno JWT_SECRET en producción
  # ⚠️ NO commitear secretos reales a Git
  #
  # DEVELOPMENT:
  # El valor por defecto (después de ":") solo se usa si JWT_SECRET no está definido
  # Es seguro para desarrollo/educación local
  #
  # PRODUCTION:
  # Siempre definir JWT_SECRET como variable de entorno:
  # - Docker: -e JWT_SECRET=your-production-secret
  # - Kubernetes: Secret / ConfigMap
  # - Cloud: AWS Secrets Manager / Azure Key Vault / HashiCorp Vault
  #
  # GENERAR SECRET SEGURO:
  # openssl rand -base64 32
  #
  # REQUISITOS:
  # - Mínimo 256 bits (32 caracteres) para HMAC-SHA256
  # - Debe ser aleatoria y compleja
  # - Cambiar en cada entorno (dev, staging, prod)
  secret: ${JWT_SECRET:5JYzCkNP8xQ2mVnRwTaFbGdKeShXrUvYy3t6v9yBxE4=}

  # Tiempo de expiración del token en milisegundos
  # Configurable vía variable de entorno JWT_EXPIRATION
  #
  # BEST PRACTICES:
  # - Access tokens: 15 min - 1 hora (short-lived)
  # - Refresh tokens: 7-30 días (long-lived)
  #
  # DEFAULT: 24 horas para este proyecto educativo
  # PRODUCTION: Reducir a 15-60 minutos
  expiration: ${JWT_EXPIRATION:86400000}  # Default: 24 horas

# ===================================================================
# CONFIGURACIÓN DE CORS (Cross-Origin Resource Sharing)
# ===================================================================
cors:
  # Orígenes permitidos para requests CORS
  # Configurable vía variable de entorno CORS_ALLOWED_ORIGINS
  #
  # DEVELOPMENT:
  # Permisivo: permite localhost en puertos comunes de frameworks frontend
  # - 3000: React (create-react-app), Next.js
  # - 4200: Angular
  # - 8081: Vue.js
  #
  # PRODUCTION:
  # Restrictivo: solo dominios específicos de tu aplicación
  # Ejemplos:
  # - https://app.example.com
  # - https://admin.example.com
  #
  # MULTIPLE ORIGINS:
  # Separar por comas sin espacios:
  # allowed-origins: https://app.example.com,https://admin.example.com
  #
  # ⚠️ NUNCA usar "*" (wildcard) en producción con credentials
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:4200,http://localhost:8081}
