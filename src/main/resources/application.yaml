# ===================================================================
# CONFIGURACIÓN DE LA APLICACIÓN
# ===================================================================
# Configuración para el proyecto hexarch con arquitectura hexagonal

# ===================================================================
# CONFIGURACIÓN DE LA APLICACIÓN
# ===================================================================
spring:
  application:
    name: hexarch

  # ===================================================================
  # CONFIGURACIÓN DE BASE DE DATOS - POSTGRESQL
  # ===================================================================
  datasource:
    # URL de conexión a PostgreSQL
    # Formato: jdbc:postgresql://host:port/database
    url: jdbc:postgresql://localhost:5432/hexarch_db
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver

    # Configuración de HikariCP (pool de conexiones)
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 20000
      idle-timeout: 300000

  # ===================================================================
  # CONFIGURACIÓN DE JPA / HIBERNATE
  # ===================================================================
  jpa:
    # Dialecto de PostgreSQL
    database-platform: org.hibernate.dialect.PostgreSQLDialect

    # NO crear/actualizar esquema automáticamente (usamos Flyway)
    hibernate:
      ddl-auto: validate

    # Mostrar SQL en consola (útil para desarrollo, desactivar en producción)
    show-sql: true

    # Configuración adicional de Hibernate
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

  # ===================================================================
  # CONFIGURACIÓN DE FLYWAY
  # ===================================================================
  flyway:
    # Habilitar Flyway para migraciones de BD
    enabled: true

    # Ubicación de los scripts de migración
    locations: classpath:db/migration

    # Baseline on migrate: crea una versión base si la BD no está vacía
    baseline-on-migrate: true

    # Validar migraciones al iniciar
    validate-on-migrate: true

  # ===================================================================
  # CONFIGURACIÓN DE JACKSON (JSON)
  # ===================================================================
  jackson:
    # Instant se serializa automáticamente a formato ISO-8601 con UTC (ej: 2024-01-15T10:30:00.123Z)
    # No necesitamos configuración especial para Instant

    # Incluir solo propiedades no nulas en JSON
    default-property-inclusion: non_null

    serialization:
      # Pretty print JSON (útil para desarrollo, desactivar en producción)
      indent_output: true

      # Serializar fechas como timestamps ISO-8601 (no como números)
      write-dates-as-timestamps: false

  # ===================================================================
  # CONFIGURACIÓN DE KAFKA
  # ===================================================================
  kafka:
    # Dirección del broker Kafka
    # localhost:9092 para desarrollo local (docker-compose)
    bootstrap-servers: localhost:9092

    # Configuración del PRODUCER (publicar eventos)
    producer:
      # Serializar clave como String
      key-serializer: org.apache.kafka.common.serialization.StringSerializer

      # Serializar valor como JSON
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

      # Propiedades adicionales del producer
      properties:
        # Habilitar idempotencia (evita duplicados en caso de reenvíos)
        enable.idempotence: true

        # Número de acknowledgments requeridos antes de considerar exitoso el envío
        # all = esperar confirmación de todos los replicas (máxima durabilidad)
        acks: all

        # Número de reintentos en caso de error
        retries: 3

    # Configuración del CONSUMER (consumir eventos)
    consumer:
      # Deserializar clave como String
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer

      # Deserializar valor desde JSON
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer

      # Grupo de consumers
      # Consumers con mismo group-id comparten la carga (load balancing)
      group-id: hexarch-user-service

      # Estrategia de lectura si no hay offset guardado
      # earliest = leer desde el principio (útil para desarrollo/testing)
      # latest = leer solo mensajes nuevos (útil para producción)
      auto-offset-reset: earliest

      # Propiedades adicionales del consumer
      properties:
        # Paquetes confiables para deserialización
        # ⚠️ En producción, especifica paquetes exactos en lugar de "*"
        # Ejemplo: spring.json.trusted.packages: com.example.hexarch.user.domain.event
        spring.json.trusted.packages: "*"

    # Configuración del LISTENER (@KafkaListener)
    listener:
      # Modo de confirmación de mensajes (ack)
      # record = confirmar cada mensaje individualmente (más seguro)
      # batch = confirmar lote completo (más performante)
      ack-mode: record

  # ===================================================================
  # CONFIGURACIÓN DE RESILIENCE4J (Circuit Breaker, Retry, etc.)
  # ===================================================================
resilience4j:
  circuitbreaker:
    instances:
      # Circuit Breaker para EmailService
      emailService:
        # Tamaño de la ventana deslizante para calcular tasa de fallos
        # COUNT_BASED = cuenta número de llamadas
        # TIME_BASED = cuenta en ventana de tiempo
        sliding-window-type: COUNT_BASED

        # Número de llamadas en la ventana deslizante
        # Circuit Breaker evalúa fallos sobre las últimas 10 llamadas
        sliding-window-size: 10

        # Número mínimo de llamadas antes de evaluar tasa de fallos
        # Si hay menos de 5 llamadas, el circuit NO se abre (aunque todas fallen)
        minimum-number-of-calls: 5

        # Porcentaje de fallos para abrir el circuit
        # Si >= 50% de las últimas 10 llamadas fallan → Circuit pasa a OPEN
        failure-rate-threshold: 50

        # Cuánto tiempo permanece OPEN antes de cambiar a HALF_OPEN
        # Después de 10 segundos, permite llamadas de prueba
        wait-duration-in-open-state: 10s

        # Número de llamadas permitidas en estado HALF_OPEN (prueba)
        # Permite 3 llamadas de prueba para ver si el servicio se recuperó
        permitted-number-of-calls-in-half-open-state: 3

        # Si en HALF_OPEN, cuántas llamadas deben fallar para volver a OPEN
        # Si >= 50% de las 3 llamadas de prueba fallan → Vuelve a OPEN
        # Si < 50% fallan → Cambia a CLOSED ✅
        slow-call-rate-threshold: 50

        # Llamada se considera "lenta" si tarda más de esto
        # Llamadas lentas también cuentan como fallos
        slow-call-duration-threshold: 5s

        # Registrar eventos para debugging/monitoring
        register-health-indicator: true
        record-exceptions:
          - java.lang.RuntimeException
          - java.io.IOException
          - java.util.concurrent.TimeoutException

# ===================================================================
# CONFIGURACIÓN DEL SERVIDOR
# ===================================================================
server:
  port: 8080

# ===================================================================
# CONFIGURACIÓN DE LOGGING
# ===================================================================
logging:
  # Nivel de log general
  level:
    root: INFO

    # Nivel de log para nuestro paquete
    com.example.hexarch: DEBUG

    # Nivel de log para SQL (mostrar parámetros de queries)
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

    # Nivel de log para Spring
    org.springframework.web: DEBUG

  # Patrón de log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"

# ===================================================================
# CONFIGURACIÓN DE ACTUATOR (Monitoreo)
# ===================================================================
management:
  endpoints:
    web:
      exposure:
        # Exponer endpoints de actuator
        include: health,info,metrics

  endpoint:
    health:
      # Mostrar detalles del health endpoint
      show-details: always
